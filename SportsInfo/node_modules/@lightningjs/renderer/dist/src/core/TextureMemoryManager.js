import { bytesToMb } from './utils.js';
/**
 * LRU (Least Recently Used) style memory manager for textures
 *
 * @remarks
 * This class is responsible for managing the memory usage of textures
 * in the Renderer. It keeps track of the memory used by each texture
 * and triggers a cleanup when the memory usage exceeds a critical
 * threshold (`criticalThreshold`).
 *
 * The cleanup process will free up non-renderable textures until the
 * memory usage is below a target threshold (`targetThresholdLevel`).
 *
 * The memory manager's clean up process will also be triggered when the
 * scene is idle for a certain amount of time (`cleanupInterval`).
 */
export class TextureMemoryManager {
    stage;
    memUsed = 0;
    loadedTextures = new Map();
    criticalThreshold;
    targetThreshold;
    cleanupInterval;
    debugLogging;
    lastCleanupTime = 0;
    criticalCleanupRequested = false;
    /**
     * The current frame time in milliseconds
     *
     * @remarks
     * This is used to determine when to perform Idle Texture Cleanups.
     *
     * Set by stage via `updateFrameTime` method.
     */
    frameTime = 0;
    constructor(stage, settings) {
        this.stage = stage;
        const { criticalThreshold } = settings;
        this.criticalThreshold = Math.round(criticalThreshold);
        const targetFraction = Math.max(0, Math.min(1, settings.targetThresholdLevel));
        this.targetThreshold = Math.round(criticalThreshold * targetFraction);
        this.cleanupInterval = settings.cleanupInterval;
        this.debugLogging = settings.debugLogging;
        if (settings.debugLogging) {
            let lastMemUse = 0;
            setInterval(() => {
                if (lastMemUse !== this.memUsed) {
                    lastMemUse = this.memUsed;
                    console.log(`[TextureMemoryManager] Memory used: ${bytesToMb(this.memUsed)} mb / ${bytesToMb(this.criticalThreshold)} mb (${((this.memUsed / this.criticalThreshold) *
                        100).toFixed(1)}%)`);
                }
            }, 1000);
        }
        // If the threshold is 0, we disable the memory manager by replacing the
        // setTextureMemUse method with a no-op function.
        if (criticalThreshold === 0) {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.setTextureMemUse = () => { };
        }
    }
    setTextureMemUse(texture, byteSize) {
        if (this.loadedTextures.has(texture)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.memUsed -= this.loadedTextures.get(texture);
        }
        if (byteSize === 0) {
            this.loadedTextures.delete(texture);
            return;
        }
        else {
            this.memUsed += byteSize;
            this.loadedTextures.set(texture, byteSize);
        }
        if (this.memUsed > this.criticalThreshold) {
            this.criticalCleanupRequested = true;
        }
    }
    checkCleanup() {
        return (this.criticalCleanupRequested ||
            (this.memUsed > this.targetThreshold &&
                this.frameTime - this.lastCleanupTime >= this.cleanupInterval));
    }
    cleanup() {
        const critical = this.criticalCleanupRequested;
        this.lastCleanupTime = this.frameTime;
        this.criticalCleanupRequested = false;
        if (critical) {
            this.stage.queueFrameEvent('criticalCleanup', {
                memUsed: this.memUsed,
                criticalThreshold: this.criticalThreshold,
            });
        }
        if (this.debugLogging) {
            console.log(`[TextureMemoryManager] Cleaning up textures. Critical: ${critical}`);
        }
        /**
         * Sort the loaded textures by renderability, then by last touch time.
         *
         * This will ensure that the array is ordered by the following:
         * - Non-renderable textures, starting at the least recently rendered
         * - Renderable textures, starting at the least recently rendered
         */
        const textures = [...this.loadedTextures.keys()].sort((textureA, textureB) => {
            const txARenderable = textureA.renderable;
            const txBRenderable = textureB.renderable;
            if (txARenderable === txBRenderable) {
                return (textureA.lastRenderableChangeTime -
                    textureB.lastRenderableChangeTime);
            }
            else if (txARenderable) {
                return 1;
            }
            else if (txBRenderable) {
                return -1;
            }
            return 0;
        });
        // Free non-renderable textures until we reach the target threshold
        const memTarget = this.targetThreshold;
        const txManager = this.stage.txManager;
        for (const texture of textures) {
            if (texture.renderable) {
                // Stop at the first renderable texture (The rest are renderable because of the sort above)
                // We don't want to free renderable textures because they will just likely be reloaded in the next frame
                break;
            }
            if (texture.preventCleanup === false) {
                texture.ctxTexture.free();
                txManager.removeTextureFromCache(texture);
            }
            if (this.memUsed <= memTarget) {
                // Stop once we've freed enough textures to reach under the target threshold
                break;
            }
        }
        if (this.memUsed >= this.criticalThreshold) {
            this.stage.queueFrameEvent('criticalCleanupFailed', {
                memUsed: this.memUsed,
                criticalThreshold: this.criticalThreshold,
            });
            console.warn(`[TextureMemoryManager] Memory usage above critical threshold after cleanup: ${this.memUsed}`);
        }
    }
    /**
     * Get the current texture memory usage information
     *
     * @remarks
     * This method is for debugging purposes and returns information about the
     * current memory usage of the textures in the Renderer.
     */
    getMemoryInfo() {
        let renderableTexturesLoaded = 0;
        const renderableMemUsed = [...this.loadedTextures.keys()].reduce(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        (acc, texture) => {
            renderableTexturesLoaded += texture.renderable ? 1 : 0;
            return (acc + (texture.renderable ? this.loadedTextures.get(texture) : 0));
        }, 0);
        return {
            criticalThreshold: this.criticalThreshold,
            targetThreshold: this.targetThreshold,
            renderableMemUsed,
            memUsed: this.memUsed,
            renderableTexturesLoaded,
            loadedTextures: this.loadedTextures.size,
        };
    }
}
//# sourceMappingURL=TextureMemoryManager.js.map
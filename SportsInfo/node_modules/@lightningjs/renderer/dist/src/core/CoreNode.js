/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2023 Comcast Cable Communications Management, LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { assertTruthy, getNewId, mergeColorAlphaPremultiplied, } from '../utils.js';
import { EventEmitter } from '../common/EventEmitter.js';
import { copyRect, intersectRect, createBound, boundInsideBound, boundLargeThanBound, createPreloadBounds, } from './lib/utils.js';
import { Matrix3d } from './lib/Matrix3d.js';
import { RenderCoords } from './lib/RenderCoords.js';
import { CoreAnimation } from './animations/CoreAnimation.js';
import { CoreAnimationController } from './animations/CoreAnimationController.js';
export var CoreNodeRenderState;
(function (CoreNodeRenderState) {
    CoreNodeRenderState[CoreNodeRenderState["Init"] = 0] = "Init";
    CoreNodeRenderState[CoreNodeRenderState["OutOfBounds"] = 2] = "OutOfBounds";
    CoreNodeRenderState[CoreNodeRenderState["InBounds"] = 4] = "InBounds";
    CoreNodeRenderState[CoreNodeRenderState["InViewport"] = 8] = "InViewport";
})(CoreNodeRenderState || (CoreNodeRenderState = {}));
const CoreNodeRenderStateMap = new Map();
CoreNodeRenderStateMap.set(CoreNodeRenderState.Init, 'init');
CoreNodeRenderStateMap.set(CoreNodeRenderState.OutOfBounds, 'outOfBounds');
CoreNodeRenderStateMap.set(CoreNodeRenderState.InBounds, 'inBounds');
CoreNodeRenderStateMap.set(CoreNodeRenderState.InViewport, 'inViewport');
export var UpdateType;
(function (UpdateType) {
    /**
     * Child updates
     */
    UpdateType[UpdateType["Children"] = 1] = "Children";
    /**
     * Scale/Rotate transform update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `scaleRotateTransform`
     */
    UpdateType[UpdateType["ScaleRotate"] = 2] = "ScaleRotate";
    /**
     * Translate transform update (x/y/width/height/pivot/mount)
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `localTransform`
     */
    UpdateType[UpdateType["Local"] = 4] = "Local";
    /**
     * Global Transform update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `globalTransform`
     * - `renderCoords`
     * - `renderBound`
     */
    UpdateType[UpdateType["Global"] = 8] = "Global";
    /**
     * Clipping rect update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `clippingRect`
     */
    UpdateType[UpdateType["Clipping"] = 16] = "Clipping";
    /**
     * Calculated ZIndex update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `calcZIndex`
     */
    UpdateType[UpdateType["CalculatedZIndex"] = 32] = "CalculatedZIndex";
    /**
     * Z-Index Sorted Children update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `children` (sorts children by their `calcZIndex`)
     */
    UpdateType[UpdateType["ZIndexSortedChildren"] = 64] = "ZIndexSortedChildren";
    /**
     * Premultiplied Colors update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `premultipliedColorTl`
     * - `premultipliedColorTr`
     * - `premultipliedColorBl`
     * - `premultipliedColorBr`
     */
    UpdateType[UpdateType["PremultipliedColors"] = 128] = "PremultipliedColors";
    /**
     * World Alpha update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `worldAlpha` = `parent.worldAlpha` * `alpha`
     */
    UpdateType[UpdateType["WorldAlpha"] = 256] = "WorldAlpha";
    /**
     * Render State update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `renderState`
     */
    UpdateType[UpdateType["RenderState"] = 512] = "RenderState";
    /**
     * Is Renderable update
     *
     * @remarks
     * CoreNode Properties Updated:
     * - `isRenderable`
     */
    UpdateType[UpdateType["IsRenderable"] = 1024] = "IsRenderable";
    /**
     * Render Texture update
     */
    UpdateType[UpdateType["RenderTexture"] = 2048] = "RenderTexture";
    /**
     * Track if parent has render texture
     */
    UpdateType[UpdateType["ParentRenderTexture"] = 4096] = "ParentRenderTexture";
    /**
     * Render Bounds update
     */
    UpdateType[UpdateType["RenderBounds"] = 8192] = "RenderBounds";
    /**
     * None
     */
    UpdateType[UpdateType["None"] = 0] = "None";
    /**
     * All
     */
    UpdateType[UpdateType["All"] = 14335] = "All";
})(UpdateType || (UpdateType = {}));
/**
 * A visual Node in the Renderer scene graph.
 *
 * @remarks
 * CoreNode is an internally used class that represents a Renderer Node in the
 * scene graph. See INode.ts for the public APIs exposed to Renderer users
 * that include generic types for Shaders.
 */
export class CoreNode extends EventEmitter {
    stage;
    children = [];
    _id = getNewId();
    props;
    updateType = UpdateType.All;
    childUpdateType = UpdateType.None;
    globalTransform;
    scaleRotateTransform;
    localTransform;
    renderCoords;
    renderBound;
    strictBound;
    preloadBound;
    clippingRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        valid: false,
    };
    isRenderable = false;
    renderState = CoreNodeRenderState.Init;
    worldAlpha = 1;
    premultipliedColorTl = 0;
    premultipliedColorTr = 0;
    premultipliedColorBl = 0;
    premultipliedColorBr = 0;
    calcZIndex = 0;
    hasRTTupdates = false;
    parentHasRenderTexture = false;
    constructor(stage, props) {
        super();
        this.stage = stage;
        this.props = {
            ...props,
            parent: null,
            texture: null,
            src: null,
            rtt: false,
        };
        // Assign props to instance
        this.parent = props.parent;
        this.texture = props.texture;
        this.src = props.src;
        this.rtt = props.rtt;
        this.setUpdateType(UpdateType.ScaleRotate |
            UpdateType.Local |
            UpdateType.RenderBounds |
            UpdateType.RenderState);
    }
    //#region Textures
    loadTexture() {
        const { texture } = this.props;
        assertTruthy(texture);
        // If texture is already loaded / failed, trigger loaded event manually
        // so that users get a consistent event experience.
        // We do this in a microtask to allow listeners to be attached in the same
        // synchronous task after calling loadTexture()
        queueMicrotask(() => {
            texture.preventCleanup = this.props.preventCleanup;
            // Preload texture if required
            if (this.textureOptions.preload) {
                texture.ctxTexture.load();
            }
            texture.on('loaded', this.onTextureLoaded);
            texture.on('failed', this.onTextureFailed);
            texture.on('freed', this.onTextureFreed);
            // If the parent is a render texture, the initial texture status
            // will be set to freed until the texture is processed by the
            // Render RTT nodes. So we only need to listen fo changes and
            // no need to check the texture.state until we restructure how
            // textures are being processed.
            if (this.parentHasRenderTexture) {
                this.notifyParentRTTOfUpdate();
                return;
            }
            if (texture.state === 'loaded') {
                assertTruthy(texture.dimensions);
                this.onTextureLoaded(texture, texture.dimensions);
            }
            else if (texture.state === 'failed') {
                assertTruthy(texture.error);
                this.onTextureFailed(texture, texture.error);
            }
            else if (texture.state === 'freed') {
                this.onTextureFreed(texture);
            }
        });
    }
    unloadTexture() {
        if (this.texture !== null) {
            this.texture.off('loaded', this.onTextureLoaded);
            this.texture.off('failed', this.onTextureFailed);
            this.texture.off('freed', this.onTextureFreed);
            this.texture.setRenderableOwner(this, false);
        }
    }
    autosizeNode(dimensions) {
        if (this.autosize) {
            this.width = dimensions.width;
            this.height = dimensions.height;
        }
    }
    onTextureLoaded = (_, dimensions) => {
        this.autosizeNode(dimensions);
        // Texture was loaded. In case the RAF loop has already stopped, we request
        // a render to ensure the texture is rendered.
        this.stage.requestRender();
        // If parent has a render texture, flag that we need to update
        if (this.parentHasRenderTexture) {
            this.notifyParentRTTOfUpdate();
        }
        this.emit('loaded', {
            type: 'texture',
            dimensions,
        });
        // Trigger a local update if the texture is loaded and the resizeMode is 'contain'
        if (this.props.textureOptions?.resizeMode?.type === 'contain') {
            this.setUpdateType(UpdateType.Local);
        }
    };
    onTextureFailed = (_, error) => {
        // If parent has a render texture, flag that we need to update
        if (this.parentHasRenderTexture) {
            this.notifyParentRTTOfUpdate();
        }
        this.emit('failed', {
            type: 'texture',
            error,
        });
    };
    onTextureFreed = () => {
        // If parent has a render texture, flag that we need to update
        if (this.parentHasRenderTexture) {
            this.notifyParentRTTOfUpdate();
        }
        this.emit('freed', {
            type: 'texture',
        });
    };
    //#endregion Textures
    /**
     * Change types types is used to determine the scope of the changes being applied
     *
     * @remarks
     * See {@link UpdateType} for more information on each type
     *
     * @param type
     */
    setUpdateType(type) {
        this.updateType |= type;
        const parent = this.props.parent;
        if (!parent)
            return;
        if ((parent.updateType & UpdateType.Children) === 0) {
            // Inform the parent if it doesn’t already have a child update
            parent.setUpdateType(UpdateType.Children);
        }
    }
    sortChildren() {
        this.children.sort((a, b) => a.calcZIndex - b.calcZIndex);
    }
    updateScaleRotateTransform() {
        const { rotation, scaleX, scaleY } = this.props;
        // optimize simple translation cases
        if (rotation === 0 && scaleX === 1 && scaleY === 1) {
            this.scaleRotateTransform = undefined;
            return;
        }
        this.scaleRotateTransform = Matrix3d.rotate(rotation, this.scaleRotateTransform).scale(scaleX, scaleY);
    }
    updateLocalTransform() {
        const { x, y, width, height } = this.props;
        const mountTranslateX = this.props.mountX * width;
        const mountTranslateY = this.props.mountY * height;
        if (this.scaleRotateTransform) {
            const pivotTranslateX = this.props.pivotX * width;
            const pivotTranslateY = this.props.pivotY * height;
            this.localTransform = Matrix3d.translate(x - mountTranslateX + pivotTranslateX, y - mountTranslateY + pivotTranslateY, this.localTransform)
                .multiply(this.scaleRotateTransform)
                .translate(-pivotTranslateX, -pivotTranslateY);
        }
        else {
            this.localTransform = Matrix3d.translate(x - mountTranslateX, y - mountTranslateY, this.localTransform);
        }
        // Handle 'contain' resize mode
        const texture = this.props.texture;
        if (texture &&
            texture.dimensions &&
            this.props.textureOptions?.resizeMode?.type === 'contain') {
            let resizeModeScaleX = 1;
            let resizeModeScaleY = 1;
            let extraX = 0;
            let extraY = 0;
            const { width: tw, height: th } = texture.dimensions;
            const txAspectRatio = tw / th;
            const nodeAspectRatio = width / height;
            if (txAspectRatio > nodeAspectRatio) {
                // Texture is wider than node
                // Center the node vertically (shift down by extraY)
                // Scale the node vertically to maintain original aspect ratio
                const scaleX = width / tw;
                const scaledTxHeight = th * scaleX;
                extraY = (height - scaledTxHeight) / 2;
                resizeModeScaleY = scaledTxHeight / height;
            }
            else {
                // Texture is taller than node (or equal)
                // Center the node horizontally (shift right by extraX)
                // Scale the node horizontally to maintain original aspect ratio
                const scaleY = height / th;
                const scaledTxWidth = tw * scaleY;
                extraX = (width - scaledTxWidth) / 2;
                resizeModeScaleX = scaledTxWidth / width;
            }
            // Apply the extra translation and scale to the local transform
            this.localTransform
                .translate(extraX, extraY)
                .scale(resizeModeScaleX, resizeModeScaleY);
        }
        this.setUpdateType(UpdateType.Global);
    }
    /**
     * @todo: test for correct calculation flag
     * @param delta
     */
    update(delta, parentClippingRect) {
        if (this.updateType & UpdateType.ScaleRotate) {
            this.updateScaleRotateTransform();
            this.setUpdateType(UpdateType.Local);
        }
        if (this.updateType & UpdateType.Local) {
            this.updateLocalTransform();
            this.setUpdateType(UpdateType.Global);
        }
        const parent = this.props.parent;
        let renderState = null;
        // Handle specific RTT updates at this node level
        if (this.updateType & UpdateType.RenderTexture && this.rtt) {
            // Only the RTT node itself triggers `renderToTexture`
            this.hasRTTupdates = true;
            this.stage.renderer?.renderToTexture(this);
        }
        if (this.updateType & UpdateType.Global) {
            assertTruthy(this.localTransform);
            this.globalTransform = Matrix3d.copy(parent?.globalTransform || this.localTransform, this.globalTransform);
            if (this.parentHasRenderTexture && this.props.parent?.rtt) {
                this.globalTransform = Matrix3d.identity();
            }
            if (parent) {
                this.globalTransform.multiply(this.localTransform);
            }
            this.calculateRenderCoords();
            this.updateBoundingRect();
            this.setUpdateType(UpdateType.RenderState | UpdateType.Children);
            this.childUpdateType |= UpdateType.Global;
            if (this.clipping === true) {
                this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds);
                this.childUpdateType |= UpdateType.RenderBounds;
            }
        }
        if (this.updateType & UpdateType.RenderBounds) {
            this.createRenderBounds();
            this.setUpdateType(UpdateType.RenderState);
            this.setUpdateType(UpdateType.Children);
        }
        if (this.updateType & UpdateType.RenderState) {
            renderState = this.checkRenderBounds();
            this.setUpdateType(UpdateType.IsRenderable);
            // if we're not going out of bounds, update the render state
            // this is done so the update loop can finish before we mark a node
            // as out of bounds
            if (renderState !== CoreNodeRenderState.OutOfBounds) {
                this.updateRenderState(renderState);
            }
        }
        if (this.updateType & UpdateType.WorldAlpha) {
            if (parent) {
                this.worldAlpha = parent.worldAlpha * this.props.alpha;
            }
            else {
                this.worldAlpha = this.props.alpha;
            }
            this.setUpdateType(UpdateType.Children |
                UpdateType.PremultipliedColors |
                UpdateType.IsRenderable);
            this.childUpdateType |= UpdateType.WorldAlpha;
        }
        if (this.updateType & UpdateType.IsRenderable) {
            this.updateIsRenderable();
        }
        if (this.updateType & UpdateType.Clipping) {
            this.calculateClippingRect(parentClippingRect);
            this.setUpdateType(UpdateType.Children);
            this.childUpdateType |= UpdateType.Clipping;
            this.childUpdateType |= UpdateType.RenderBounds;
        }
        if (this.updateType & UpdateType.PremultipliedColors) {
            this.premultipliedColorTl = mergeColorAlphaPremultiplied(this.props.colorTl, this.worldAlpha, true);
            // If all the colors are the same just sent them all to the same value
            if (this.props.colorTl === this.props.colorTr &&
                this.props.colorBl === this.props.colorBr &&
                this.props.colorTl === this.props.colorBl) {
                this.premultipliedColorTr =
                    this.premultipliedColorBl =
                        this.premultipliedColorBr =
                            this.premultipliedColorTl;
            }
            else {
                this.premultipliedColorTr = mergeColorAlphaPremultiplied(this.props.colorTr, this.worldAlpha, true);
                this.premultipliedColorBl = mergeColorAlphaPremultiplied(this.props.colorBl, this.worldAlpha, true);
                this.premultipliedColorBr = mergeColorAlphaPremultiplied(this.props.colorBr, this.worldAlpha, true);
            }
        }
        // No need to update zIndex if there is no parent
        if (parent !== null && this.updateType & UpdateType.CalculatedZIndex) {
            this.calculateZIndex();
            // Tell parent to re-sort children
            parent.setUpdateType(UpdateType.ZIndexSortedChildren);
        }
        if (this.props.strictBounds === true &&
            this.renderState === CoreNodeRenderState.OutOfBounds) {
            return;
        }
        if (this.updateType & UpdateType.Children && this.children.length > 0) {
            for (let i = 0, length = this.children.length; i < length; i++) {
                const child = this.children[i];
                child.setUpdateType(this.childUpdateType);
                if (child.updateType === 0) {
                    continue;
                }
                child.update(delta, this.clippingRect);
            }
        }
        // If the node has an RTT parent and requires a texture re-render, inform the RTT parent
        // if (this.parentHasRenderTexture && this.updateType & UpdateType.RenderTexture) {
        // @TODO have a more scoped down updateType for RTT updates
        if (this.parentHasRenderTexture && this.updateType > 0) {
            this.notifyParentRTTOfUpdate();
        }
        // Sorting children MUST happen after children have been updated so
        // that they have the oppotunity to update their calculated zIndex.
        if (this.updateType & UpdateType.ZIndexSortedChildren) {
            // reorder z-index
            this.sortChildren();
        }
        // If we're out of bounds, apply the render state now
        // this is done so nodes can finish their entire update loop before
        // being marked as out of bounds
        if (renderState === CoreNodeRenderState.OutOfBounds) {
            this.updateRenderState(renderState);
            this.updateIsRenderable();
        }
        // reset update type
        this.updateType = 0;
        this.childUpdateType = 0;
    }
    notifyParentRTTOfUpdate() {
        if (this.parent === null) {
            return;
        }
        let rttNode = this.parent;
        // Traverse up to find the RTT root node
        while (rttNode && !rttNode.rtt) {
            rttNode = rttNode.parent;
        }
        if (!rttNode) {
            return;
        }
        // If an RTT node is found, mark it for re-rendering
        rttNode.hasRTTupdates = true;
        rttNode.setUpdateType(UpdateType.RenderTexture);
        // if rttNode is nested, also make it update its RTT parent
        if (rttNode.parentHasRenderTexture === true) {
            rttNode.notifyParentRTTOfUpdate();
        }
    }
    //check if CoreNode is renderable based on props
    hasRenderableProperties() {
        if (this.props.texture) {
            return true;
        }
        if (!this.props.width || !this.props.height) {
            return false;
        }
        if (this.props.shader !== this.stage.defShaderCtr) {
            return true;
        }
        if (this.props.clipping) {
            return true;
        }
        if (this.props.color !== 0) {
            return true;
        }
        // Consider removing these checks and just using the color property check above.
        // Maybe add a forceRender prop for nodes that should always render.
        if (this.props.colorTop !== 0) {
            return true;
        }
        if (this.props.colorBottom !== 0) {
            return true;
        }
        if (this.props.colorLeft !== 0) {
            return true;
        }
        if (this.props.colorRight !== 0) {
            return true;
        }
        if (this.props.colorTl !== 0) {
            return true;
        }
        if (this.props.colorTr !== 0) {
            return true;
        }
        if (this.props.colorBl !== 0) {
            return true;
        }
        if (this.props.colorBr !== 0) {
            return true;
        }
        return false;
    }
    checkRenderBounds() {
        assertTruthy(this.renderBound);
        assertTruthy(this.strictBound);
        assertTruthy(this.preloadBound);
        if (boundInsideBound(this.renderBound, this.strictBound)) {
            return CoreNodeRenderState.InViewport;
        }
        if (boundInsideBound(this.renderBound, this.preloadBound)) {
            return CoreNodeRenderState.InBounds;
        }
        // check if we're larger then our parent, we're definitely in the viewport
        if (boundLargeThanBound(this.renderBound, this.strictBound)) {
            return CoreNodeRenderState.InViewport;
        }
        // check if we dont have dimensions, take our parent's render state
        if (this.parent !== null &&
            (this.props.width === 0 || this.props.height === 0)) {
            return this.parent.renderState;
        }
        return CoreNodeRenderState.OutOfBounds;
    }
    updateBoundingRect() {
        const { renderCoords, globalTransform: transform } = this;
        assertTruthy(transform);
        assertTruthy(renderCoords);
        const { tb, tc } = transform;
        const { x1, y1, x3, y3 } = renderCoords;
        if (tb === 0 || tc === 0) {
            this.renderBound = createBound(x1, y1, x3, y3, this.renderBound);
        }
        else {
            const { x2, x4, y2, y4 } = renderCoords;
            this.renderBound = createBound(Math.min(x1, x2, x3, x4), Math.min(y1, y2, y3, y4), Math.max(x1, x2, x3, x4), Math.max(y1, y2, y3, y4), this.renderBound);
        }
    }
    createRenderBounds() {
        assertTruthy(this.stage);
        if (this.parent !== null && this.parent.strictBound !== undefined) {
            // we have a parent with a valid bound, copy it
            const parentBound = this.parent.strictBound;
            this.strictBound = createBound(parentBound.x1, parentBound.y1, parentBound.x2, parentBound.y2);
            this.preloadBound = createPreloadBounds(this.strictBound, this.stage.boundsMargin);
        }
        else {
            // no parent or parent does not have a bound, take the stage boundaries
            this.strictBound = this.stage.strictBound;
            this.preloadBound = this.stage.preloadBound;
        }
        // if clipping is disabled, we're done
        if (this.props.clipping === false) {
            return;
        }
        // only create local clipping bounds if node itself is in bounds
        // this can only be done if we have a render bound already
        if (this.renderBound === undefined) {
            return;
        }
        // if we're out of bounds, we're done
        if (boundInsideBound(this.renderBound, this.strictBound) === false) {
            return;
        }
        // clipping is enabled and we are in bounds create our own bounds
        const { x, y, width, height } = this.props;
        const { tx, ty } = this.globalTransform || {};
        const _x = tx ?? x;
        const _y = ty ?? y;
        this.strictBound = createBound(_x, _y, _x + width, _y + height, this.strictBound);
        this.preloadBound = createPreloadBounds(this.strictBound, this.stage.boundsMargin);
    }
    updateRenderState(renderState) {
        if (renderState === this.renderState) {
            return;
        }
        const previous = this.renderState;
        this.renderState = renderState;
        const event = CoreNodeRenderStateMap.get(renderState);
        assertTruthy(event);
        this.emit(event, {
            previous,
            current: renderState,
        });
    }
    /**
     * This function updates the `isRenderable` property based on certain conditions.
     *
     * @returns
     */
    updateIsRenderable() {
        let newIsRenderable;
        if (this.worldAlpha === 0 || !this.hasRenderableProperties()) {
            newIsRenderable = false;
        }
        else {
            newIsRenderable = this.renderState > CoreNodeRenderState.OutOfBounds;
        }
        if (this.isRenderable !== newIsRenderable) {
            this.isRenderable = newIsRenderable;
            this.onChangeIsRenderable(newIsRenderable);
        }
    }
    onChangeIsRenderable(isRenderable) {
        this.texture?.setRenderableOwner(this, isRenderable);
    }
    calculateRenderCoords() {
        const { width, height, globalTransform: transform } = this;
        assertTruthy(transform);
        const { tx, ty, ta, tb, tc, td } = transform;
        if (tb === 0 && tc === 0) {
            const minX = tx;
            const maxX = tx + width * ta;
            const minY = ty;
            const maxY = ty + height * td;
            this.renderCoords = RenderCoords.translate(
            //top-left
            minX, minY, 
            //top-right
            maxX, minY, 
            //bottom-right
            maxX, maxY, 
            //bottom-left
            minX, maxY, this.renderCoords);
        }
        else {
            this.renderCoords = RenderCoords.translate(
            //top-left
            tx, ty, 
            //top-right
            tx + width * ta, ty + width * tc, 
            //bottom-right
            tx + width * ta + height * tb, ty + width * tc + height * td, 
            //bottom-left
            tx + height * tb, ty + height * td, this.renderCoords);
        }
    }
    /**
     * This function calculates the clipping rectangle for a node.
     *
     * The function then checks if the node is rotated. If the node requires clipping and is not rotated, a new clipping rectangle is created based on the node's global transform and dimensions.
     * If a parent clipping rectangle exists, it is intersected with the node's clipping rectangle (if it exists), or replaces the node's clipping rectangle.
     *
     * Finally, the node's parentClippingRect and clippingRect properties are updated.
     */
    calculateClippingRect(parentClippingRect) {
        assertTruthy(this.globalTransform);
        const { clippingRect, props, globalTransform: gt } = this;
        const { clipping } = props;
        const isRotated = gt.tb !== 0 || gt.tc !== 0;
        if (clipping === true && isRotated === false) {
            clippingRect.x = gt.tx;
            clippingRect.y = gt.ty;
            clippingRect.width = this.width * gt.ta;
            clippingRect.height = this.height * gt.td;
            clippingRect.valid = true;
        }
        else {
            clippingRect.valid = false;
        }
        if (parentClippingRect.valid === true && clippingRect.valid === true) {
            // Intersect parent clipping rect with node clipping rect
            intersectRect(parentClippingRect, clippingRect, clippingRect);
        }
        else if (parentClippingRect.valid === true) {
            // Copy parent clipping rect
            copyRect(parentClippingRect, clippingRect);
            clippingRect.valid = true;
        }
    }
    calculateZIndex() {
        const props = this.props;
        const z = props.zIndex || 0;
        const p = props.parent?.zIndex || 0;
        let zIndex = z;
        if (props.parent?.zIndexLocked) {
            zIndex = z < p ? z : p;
        }
        this.calcZIndex = zIndex;
    }
    /**
     * Destroy the node and cleanup all resources
     */
    destroy() {
        this.unloadTexture();
        this.clippingRect.valid = false;
        this.isRenderable = false;
        this.renderCoords = undefined;
        this.renderBound = undefined;
        this.strictBound = undefined;
        this.preloadBound = undefined;
        this.globalTransform = undefined;
        this.scaleRotateTransform = undefined;
        this.localTransform = undefined;
        this.props.texture = null;
        this.props.shader = this.stage.defShaderCtr;
        while (this.children.length > 0) {
            this.children[0]?.destroy();
        }
        // This very action will also remove the node from the parent's children array
        this.parent = null;
        if (this.rtt) {
            this.stage.renderer.removeRTTNode(this);
        }
        this.removeAllListeners();
    }
    renderQuads(renderer) {
        // Prevent quad rendering if parent has a render texture
        // and renderer is not currently rendering to a texture
        if (this.parentHasRenderTexture) {
            if (!renderer.renderToTextureActive) {
                return;
            }
            // Prevent quad rendering if parent render texture is not the active render texture
            if (this.parentRenderTexture !== renderer.activeRttNode) {
                return;
            }
        }
        assertTruthy(this.globalTransform);
        assertTruthy(this.renderCoords);
        // add to list of renderables to be sorted before rendering
        renderer.addQuad({
            width: this.props.width,
            height: this.props.height,
            colorTl: this.premultipliedColorTl,
            colorTr: this.premultipliedColorTr,
            colorBl: this.premultipliedColorBl,
            colorBr: this.premultipliedColorBr,
            texture: this.texture,
            textureOptions: this.textureOptions,
            zIndex: this.zIndex,
            shader: this.shader.shader,
            shaderProps: this.shader.getResolvedProps(),
            alpha: this.worldAlpha,
            clippingRect: this.clippingRect,
            tx: this.globalTransform.tx,
            ty: this.globalTransform.ty,
            ta: this.globalTransform.ta,
            tb: this.globalTransform.tb,
            tc: this.globalTransform.tc,
            td: this.globalTransform.td,
            renderCoords: this.renderCoords,
            rtt: this.rtt,
            parentHasRenderTexture: this.parentHasRenderTexture,
            framebufferDimensions: this.framebufferDimensions,
        });
    }
    //#region Properties
    get id() {
        return this._id;
    }
    get data() {
        return this.props.data;
    }
    set data(d) {
        this.props.data = d;
    }
    get x() {
        return this.props.x;
    }
    set x(value) {
        if (this.props.x !== value) {
            this.props.x = value;
            this.setUpdateType(UpdateType.Local);
        }
    }
    get absX() {
        return (this.props.x +
            -this.props.width * this.props.mountX +
            (this.props.parent?.absX || this.props.parent?.globalTransform?.tx || 0));
    }
    get absY() {
        return (this.props.y +
            -this.props.height * this.props.mountY +
            (this.props.parent?.absY ?? 0));
    }
    get y() {
        return this.props.y;
    }
    set y(value) {
        if (this.props.y !== value) {
            this.props.y = value;
            this.setUpdateType(UpdateType.Local);
        }
    }
    get width() {
        return this.props.width;
    }
    set width(value) {
        if (this.props.width !== value) {
            this.props.width = value;
            this.setUpdateType(UpdateType.Local);
            if (this.props.rtt) {
                this.texture = this.stage.txManager.loadTexture('RenderTexture', {
                    width: this.width,
                    height: this.height,
                });
                this.textureOptions.preload = true;
                this.setUpdateType(UpdateType.RenderTexture);
            }
        }
    }
    get height() {
        return this.props.height;
    }
    set height(value) {
        if (this.props.height !== value) {
            this.props.height = value;
            this.setUpdateType(UpdateType.Local);
            if (this.props.rtt) {
                this.texture = this.stage.txManager.loadTexture('RenderTexture', {
                    width: this.width,
                    height: this.height,
                });
                this.textureOptions.preload = true;
                this.setUpdateType(UpdateType.RenderTexture);
            }
        }
    }
    get scale() {
        // The CoreNode `scale` property is only used by Animations.
        // Unlike INode, `null` should never be possibility for Animations.
        return this.scaleX;
    }
    set scale(value) {
        // The CoreNode `scale` property is only used by Animations.
        // Unlike INode, `null` should never be possibility for Animations.
        this.scaleX = value;
        this.scaleY = value;
    }
    get scaleX() {
        return this.props.scaleX;
    }
    set scaleX(value) {
        if (this.props.scaleX !== value) {
            this.props.scaleX = value;
            this.setUpdateType(UpdateType.ScaleRotate);
        }
    }
    get scaleY() {
        return this.props.scaleY;
    }
    set scaleY(value) {
        if (this.props.scaleY !== value) {
            this.props.scaleY = value;
            this.setUpdateType(UpdateType.ScaleRotate);
        }
    }
    get mount() {
        return this.props.mount;
    }
    set mount(value) {
        if (this.props.mountX !== value || this.props.mountY !== value) {
            this.props.mountX = value;
            this.props.mountY = value;
            this.props.mount = value;
            this.setUpdateType(UpdateType.Local);
        }
    }
    get mountX() {
        return this.props.mountX;
    }
    set mountX(value) {
        if (this.props.mountX !== value) {
            this.props.mountX = value;
            this.setUpdateType(UpdateType.Local);
        }
    }
    get mountY() {
        return this.props.mountY;
    }
    set mountY(value) {
        if (this.props.mountY !== value) {
            this.props.mountY = value;
            this.setUpdateType(UpdateType.Local);
        }
    }
    get pivot() {
        return this.props.pivot;
    }
    set pivot(value) {
        if (this.props.pivotX !== value || this.props.pivotY !== value) {
            this.props.pivotX = value;
            this.props.pivotY = value;
            this.props.pivot = value;
            this.setUpdateType(UpdateType.Local);
        }
    }
    get pivotX() {
        return this.props.pivotX;
    }
    set pivotX(value) {
        if (this.props.pivotX !== value) {
            this.props.pivotX = value;
            this.setUpdateType(UpdateType.Local);
        }
    }
    get pivotY() {
        return this.props.pivotY;
    }
    set pivotY(value) {
        if (this.props.pivotY !== value) {
            this.props.pivotY = value;
            this.setUpdateType(UpdateType.Local);
        }
    }
    get rotation() {
        return this.props.rotation;
    }
    set rotation(value) {
        if (this.props.rotation !== value) {
            this.props.rotation = value;
            this.setUpdateType(UpdateType.ScaleRotate);
        }
    }
    get alpha() {
        return this.props.alpha;
    }
    set alpha(value) {
        this.props.alpha = value;
        this.setUpdateType(UpdateType.PremultipliedColors |
            UpdateType.WorldAlpha |
            UpdateType.Children |
            UpdateType.IsRenderable);
        this.childUpdateType |= UpdateType.WorldAlpha;
    }
    get autosize() {
        return this.props.autosize;
    }
    set autosize(value) {
        this.props.autosize = value;
    }
    get clipping() {
        return this.props.clipping;
    }
    set clipping(value) {
        this.props.clipping = value;
        this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds | UpdateType.Children);
        this.childUpdateType |= UpdateType.Global | UpdateType.Clipping;
    }
    get color() {
        return this.props.color;
    }
    set color(value) {
        this.colorTop = value;
        this.colorBottom = value;
        this.colorLeft = value;
        this.colorRight = value;
        this.props.color = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    get colorTop() {
        return this.props.colorTop;
    }
    set colorTop(value) {
        if (this.props.colorTl !== value || this.props.colorTr !== value) {
            this.colorTl = value;
            this.colorTr = value;
        }
        this.props.colorTop = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    get colorBottom() {
        return this.props.colorBottom;
    }
    set colorBottom(value) {
        if (this.props.colorBl !== value || this.props.colorBr !== value) {
            this.colorBl = value;
            this.colorBr = value;
        }
        this.props.colorBottom = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    get colorLeft() {
        return this.props.colorLeft;
    }
    set colorLeft(value) {
        if (this.props.colorTl !== value || this.props.colorBl !== value) {
            this.colorTl = value;
            this.colorBl = value;
        }
        this.props.colorLeft = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    get colorRight() {
        return this.props.colorRight;
    }
    set colorRight(value) {
        if (this.props.colorTr !== value || this.props.colorBr !== value) {
            this.colorTr = value;
            this.colorBr = value;
        }
        this.props.colorRight = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    get colorTl() {
        return this.props.colorTl;
    }
    set colorTl(value) {
        this.props.colorTl = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    get colorTr() {
        return this.props.colorTr;
    }
    set colorTr(value) {
        this.props.colorTr = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    get colorBl() {
        return this.props.colorBl;
    }
    set colorBl(value) {
        this.props.colorBl = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    get colorBr() {
        return this.props.colorBr;
    }
    set colorBr(value) {
        this.props.colorBr = value;
        this.setUpdateType(UpdateType.PremultipliedColors);
    }
    // we're only interested in parent zIndex to test
    // if we should use node zIndex is higher then parent zIndex
    get zIndexLocked() {
        return this.props.zIndexLocked || 0;
    }
    set zIndexLocked(value) {
        this.props.zIndexLocked = value;
        this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
        for (let i = 0, length = this.children.length; i < length; i++) {
            this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
        }
    }
    get zIndex() {
        return this.props.zIndex;
    }
    set zIndex(value) {
        this.props.zIndex = value;
        this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
        for (let i = 0, length = this.children.length; i < length; i++) {
            this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
        }
    }
    get parent() {
        return this.props.parent;
    }
    set parent(newParent) {
        const oldParent = this.props.parent;
        if (oldParent === newParent) {
            return;
        }
        this.props.parent = newParent;
        if (oldParent) {
            const index = oldParent.children.indexOf(this);
            assertTruthy(index !== -1, "CoreNode.parent: Node not found in old parent's children!");
            oldParent.children.splice(index, 1);
            oldParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
        }
        if (newParent) {
            newParent.children.push(this);
            // Since this node has a new parent, to be safe, have it do a full update.
            this.setUpdateType(UpdateType.All);
            // Tell parent that it's children need to be updated and sorted.
            newParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
            // If the new parent has an RTT enabled, apply RTT inheritance
            if (newParent.rtt || newParent.parentHasRenderTexture) {
                this.applyRTTInheritance(newParent);
            }
        }
        this.updateScaleRotateTransform();
        // fetch render bounds from parent
        this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
    }
    get preventCleanup() {
        return this.props.preventCleanup;
    }
    set preventCleanup(value) {
        this.props.preventCleanup = value;
    }
    get rtt() {
        return this.props.rtt;
    }
    set rtt(value) {
        if (this.props.rtt === value) {
            return;
        }
        this.props.rtt = value;
        if (value) {
            this.initRenderTexture();
            this.markChildrenWithRTT();
        }
        else {
            this.cleanupRenderTexture();
        }
        this.setUpdateType(UpdateType.RenderTexture);
        if (this.parentHasRenderTexture) {
            this.notifyParentRTTOfUpdate();
        }
    }
    initRenderTexture() {
        this.texture = this.stage.txManager.loadTexture('RenderTexture', {
            width: this.width,
            height: this.height,
        });
        this.textureOptions.preload = true;
        this.stage.renderer?.renderToTexture(this); // Only this RTT node
    }
    cleanupRenderTexture() {
        this.unloadTexture();
        this.clearRTTInheritance();
        this.stage.renderer?.removeRTTNode(this);
        this.hasRTTupdates = false;
        this.texture = null;
    }
    markChildrenWithRTT(node = null) {
        const parent = node || this;
        for (const child of parent.children) {
            child.setUpdateType(UpdateType.All);
            child.parentHasRenderTexture = true;
            child.markChildrenWithRTT();
        }
    }
    // Apply RTT inheritance when a node has an RTT-enabled parent
    applyRTTInheritance(parent) {
        if (parent.rtt) {
            // Only the RTT node should be added to `renderToTexture`
            parent.setUpdateType(UpdateType.RenderTexture);
        }
        // Propagate `parentHasRenderTexture` downwards
        this.markChildrenWithRTT(parent);
    }
    // Clear RTT inheritance when detaching from an RTT chain
    clearRTTInheritance() {
        // if this node is RTT itself stop the propagation important for nested RTT nodes
        // for the initial RTT node this is already handled in `set rtt`
        if (this.rtt) {
            return;
        }
        for (const child of this.children) {
            // force child to update everything as the RTT inheritance has changed
            child.parentHasRenderTexture = false;
            child.setUpdateType(UpdateType.All);
            child.clearRTTInheritance();
        }
    }
    get shader() {
        return this.props.shader;
    }
    set shader(value) {
        if (this.props.shader === value) {
            return;
        }
        this.props.shader = value;
        this.setUpdateType(UpdateType.IsRenderable);
    }
    get src() {
        return this.props.src;
    }
    set src(imageUrl) {
        if (this.props.src === imageUrl) {
            return;
        }
        this.props.src = imageUrl;
        if (!imageUrl) {
            this.texture = null;
            return;
        }
        this.texture = this.stage.txManager.loadTexture('ImageTexture', {
            src: imageUrl,
            width: this.props.width,
            height: this.props.height,
            type: this.props.imageType,
            sx: this.props.srcX,
            sy: this.props.srcY,
            sw: this.props.srcWidth,
            sh: this.props.srcHeight,
        });
    }
    set imageType(type) {
        if (this.props.imageType === type) {
            return;
        }
        this.props.imageType = type;
    }
    get imageType() {
        return this.props.imageType || null;
    }
    get srcHeight() {
        return this.props.srcHeight;
    }
    set srcHeight(value) {
        this.props.srcHeight = value;
    }
    get srcWidth() {
        return this.props.srcWidth;
    }
    set srcWidth(value) {
        this.props.srcWidth = value;
    }
    get srcX() {
        return this.props.srcX;
    }
    set srcX(value) {
        this.props.srcX = value;
    }
    get srcY() {
        return this.props.srcY;
    }
    set srcY(value) {
        this.props.srcY = value;
    }
    /**
     * Returns the framebuffer dimensions of the node.
     * If the node has a render texture, the dimensions are the same as the node's dimensions.
     * If the node does not have a render texture, the dimensions are inherited from the parent.
     * If the node parent has a render texture and the node is a render texture, the nodes dimensions are used.
     */
    get framebufferDimensions() {
        if (this.parentHasRenderTexture && !this.rtt && this.parent) {
            return this.parent.framebufferDimensions;
        }
        return { width: this.width, height: this.height };
    }
    /**
     * Returns the parent render texture node if it exists.
     */
    get parentRenderTexture() {
        let parent = this.parent;
        while (parent) {
            if (parent.rtt) {
                return parent;
            }
            parent = parent.parent;
        }
        return null;
    }
    get texture() {
        return this.props.texture;
    }
    set texture(value) {
        if (this.props.texture === value) {
            return;
        }
        const oldTexture = this.props.texture;
        if (oldTexture) {
            oldTexture.setRenderableOwner(this, false);
            this.unloadTexture();
        }
        this.props.texture = value;
        if (value) {
            value.setRenderableOwner(this, this.isRenderable);
            this.loadTexture();
        }
        this.setUpdateType(UpdateType.IsRenderable);
    }
    set textureOptions(value) {
        this.props.textureOptions = value;
    }
    get textureOptions() {
        return this.props.textureOptions;
    }
    get strictBounds() {
        return this.props.strictBounds;
    }
    set strictBounds(v) {
        if (v === this.props.strictBounds) {
            return;
        }
        this.props.strictBounds = v;
        this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
        this.childUpdateType |= UpdateType.RenderBounds | UpdateType.Children;
    }
    animate(props, settings) {
        const animation = new CoreAnimation(this, props, settings);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
        const controller = new CoreAnimationController(this.stage.animationManager, animation);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return controller;
    }
    flush() {
        // no-op
    }
}
//# sourceMappingURL=CoreNode.js.map
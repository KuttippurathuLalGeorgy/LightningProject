import type { TextRenderer, TextRendererMap, TrProps, TextRendererState } from './text-rendering/renderers/TextRenderer.js';
import { CoreNode, type CoreNodeProps } from './CoreNode.js';
import type { Stage } from './Stage.js';
import type { CoreRenderer } from './renderers/CoreRenderer.js';
import type { RectWithValid } from './lib/utils.js';
export interface CoreTextNodeProps extends CoreNodeProps, TrProps {
    /**
     * Force Text Node to use a specific Text Renderer
     *
     * @remarks
     * By default, Text Nodes resolve the Text Renderer to use based on the font
     * that is matched using the font family and other font selection properties.
     *
     * If two fonts supported by two separate Text Renderers are matched setting
     * this override forces the Text Node to resolve to the Text Renderer defined
     * here.
     *
     * @default null
     */
    textRendererOverride: keyof TextRendererMap | null;
}
/**
 * An CoreNode in the Renderer scene graph that renders text.
 *
 * @remarks
 * A Text Node is the second graphical building block of the Renderer scene
 * graph. It renders text using a specific text renderer that is automatically
 * chosen based on the font requested and what type of fonts are installed
 * into an app.
 *
 * The text renderer can be overridden by setting the `textRendererOverride`
 *
 * The `texture` and `shader` properties are managed by loaded text renderer and
 * should not be set directly.
 *
 * For non-text rendering, see {@link CoreNode}.
 */
export declare class CoreTextNode extends CoreNode implements CoreTextNodeProps {
    textRenderer: TextRenderer;
    trState: TextRendererState;
    private _textRendererOverride;
    constructor(stage: Stage, props: CoreTextNodeProps, textRenderer: TextRenderer);
    private onTextLoaded;
    private onTextFailed;
    get width(): number;
    set width(value: number);
    get height(): number;
    set height(value: number);
    get color(): number;
    set color(value: number);
    get text(): string;
    set text(value: string);
    get textRendererOverride(): CoreTextNodeProps['textRendererOverride'];
    set textRendererOverride(value: CoreTextNodeProps['textRendererOverride']);
    get fontSize(): CoreTextNodeProps['fontSize'];
    set fontSize(value: CoreTextNodeProps['fontSize']);
    get fontFamily(): CoreTextNodeProps['fontFamily'];
    set fontFamily(value: CoreTextNodeProps['fontFamily']);
    get fontStretch(): CoreTextNodeProps['fontStretch'];
    set fontStretch(value: CoreTextNodeProps['fontStretch']);
    get fontStyle(): CoreTextNodeProps['fontStyle'];
    set fontStyle(value: CoreTextNodeProps['fontStyle']);
    get fontWeight(): CoreTextNodeProps['fontWeight'];
    set fontWeight(value: CoreTextNodeProps['fontWeight']);
    get textAlign(): CoreTextNodeProps['textAlign'];
    set textAlign(value: CoreTextNodeProps['textAlign']);
    get contain(): CoreTextNodeProps['contain'];
    set contain(value: CoreTextNodeProps['contain']);
    get scrollable(): CoreTextNodeProps['scrollable'];
    set scrollable(value: CoreTextNodeProps['scrollable']);
    get scrollY(): CoreTextNodeProps['scrollY'];
    set scrollY(value: CoreTextNodeProps['scrollY']);
    get offsetY(): CoreTextNodeProps['offsetY'];
    set offsetY(value: CoreTextNodeProps['offsetY']);
    get letterSpacing(): CoreTextNodeProps['letterSpacing'];
    set letterSpacing(value: CoreTextNodeProps['letterSpacing']);
    get lineHeight(): CoreTextNodeProps['lineHeight'];
    set lineHeight(value: CoreTextNodeProps['lineHeight']);
    get maxLines(): CoreTextNodeProps['maxLines'];
    set maxLines(value: CoreTextNodeProps['maxLines']);
    get textBaseline(): CoreTextNodeProps['textBaseline'];
    set textBaseline(value: CoreTextNodeProps['textBaseline']);
    get verticalAlign(): CoreTextNodeProps['verticalAlign'];
    set verticalAlign(value: CoreTextNodeProps['verticalAlign']);
    get overflowSuffix(): CoreTextNodeProps['overflowSuffix'];
    set overflowSuffix(value: CoreTextNodeProps['overflowSuffix']);
    get debug(): CoreTextNodeProps['debug'];
    set debug(value: CoreTextNodeProps['debug']);
    update(delta: number, parentClippingRect: RectWithValid): void;
    hasRenderableProperties(): boolean;
    onChangeIsRenderable(isRenderable: boolean): void;
    renderQuads(renderer: CoreRenderer): void;
    /**
     * Destroy the node and cleanup all resources
     */
    destroy(): void;
    /**
     * Resolve a text renderer and a new state based on the current text renderer props provided
     * @param props
     * @returns
     */
    private createState;
}

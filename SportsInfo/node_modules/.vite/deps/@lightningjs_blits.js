var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/@lightningjs/blits/src/lib/symbols.js
var symbols_default = {
  currentView: Symbol("currentView"),
  cursorTagStart: Symbol("cursorTagStart"),
  computedKeys: Symbol("computedKeys"),
  destroy: Symbol("destroy"),
  getChildren: Symbol("getChildren"),
  holder: Symbol("holder"),
  id: Symbol("id"),
  identifier: Symbol("identifier"),
  index: Symbol("index"),
  init: Symbol("init"),
  inputEvents: Symbol("inputEvents"),
  intervals: Symbol("intervals"),
  launched: Symbol("launched"),
  level: Symbol("level"),
  methodKeys: Symbol("methodKeys"),
  originalState: Symbol("originalState"),
  propKeys: Symbol("propKeys"),
  raw: Symbol("raw"),
  ready: Symbol("ready"),
  renderer: Symbol("renderer"),
  routes: Symbol("routes"),
  settings: Symbol("settings"),
  state: Symbol("state"),
  stateKeys: Symbol("stateKeys"),
  textnode: Symbol("textnode"),
  timeouts: Symbol("timeouts"),
  type: Symbol("type"),
  watchers: Symbol("watchers"),
  watchKeys: Symbol("watchKeys"),
  wrapper: Symbol("wrapper"),
  /* Utilizing the global Symbol registry for the following purposes */
  // Symbol 'children' utilized within generated code
  children: Symbol.for("children"),
  // Symbol 'components' utilized within generated code
  components: Symbol.for("components"),
  // Symbol 'isSlot' utilized within generated code
  isSlot: Symbol.for("isSlot"),
  // Symbol 'props' utilized within generated code
  props: Symbol.for("props"),
  // Symbol 'slots' utilized within generated code
  slots: Symbol.for("slots"),
  // Symbol 'componentType' utilized within generated code
  componentType: Symbol.for("componentType"),
  // Symbol 'isComponent' utilized within generated code
  isComponent: Symbol.for("isComponent"),
  // Symbol 'effects' utilized within generated code
  effects: Symbol.for("effects")
};

// node_modules/@lightningjs/blits/src/settings.js
var settings = {
  [symbols_default.settings]: {},
  get(key, defaultValue = null) {
    if (key in this[symbols_default.settings]) {
      return this[symbols_default.settings][key];
    } else {
      return defaultValue;
    }
  },
  set(key, value) {
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        this.set(k, key[k]);
      });
    } else {
      this[symbols_default.settings][key] = value;
    }
  }
};
var settings_default = settings;

// node_modules/@lightningjs/blits/src/lib/log.js
var n = () => {
};
var time = () => (/* @__PURE__ */ new Date()).toLocaleTimeString([], {
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
});
var logger = (context) => {
  const level = settings_default.get("debugLevel");
  const log = {};
  Object.defineProperty(log, "info", {
    get() {
      return (level >= 1 || Array.isArray(level) && level.indexOf("info") > -1) && console.info.bind(
        window.console,
        `%c ⚡️ ${context} %c ${time()}`,
        "background-color: #0284c7; color: white; padding: 3px 6px 3px 1px; border-radius: 3px",
        "color: ##94a3b8;"
      ) || n;
    }
  });
  Object.defineProperty(log, "warn", {
    get() {
      return (level >= 1 || Array.isArray(level) && level.indexOf("warn") > -1) && console.warn.bind(
        window.console,
        `%c ⚡️ ${context} %c ${time()}`,
        "background-color: #fbbf24; color: white; padding: 3px 6px 3px 1px; border-radius: 3px",
        "color: ##94a3b8;"
      ) || n;
    }
  });
  Object.defineProperty(log, "error", {
    get() {
      return (level >= 1 || Array.isArray(level) && level.indexOf("error") > -1) && console.error.bind(
        window.console,
        `%c ⚡️ ${context} %c ${time()}`,
        "background-color: #dc2626; color: white; padding: 3px 6px 3px 1px; border-radius: 3px",
        "color: ##94a3b8;"
      ) || n;
    }
  });
  Object.defineProperty(log, "debug", {
    get() {
      return (level >= 2 || Array.isArray(level) && level.indexOf("debug") > -1) && console.debug.bind(
        window.console,
        `%c ⚡️ ${context} %c (${(/* @__PURE__ */ new Date()).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        })})`,
        "background-color: #e2e8f0; color: #334155; padding: 3px 6px 3px 1px; border-radius: 3px",
        "color: ##94a3b8;"
      ) || n;
    }
  });
  return log;
};
var log_default = logger;
var Log;
var initLog = () => {
  Log = logger("Blits");
};

// node_modules/@lightningjs/blits/src/lib/colors/htmlColors.js
var htmlColors_default = {
  aliceblue: "0xf0f8ffff",
  antiquewhite: "0xfaebd7ff",
  aqua: "0xffffff00",
  aquamarine: "0x7fffd4ff",
  azure: "0xf0ffffff",
  beige: "0xf5f5dcff",
  bisque: "0xffe4c4ff",
  black: "0x000000ff",
  blanchedalmond: "0xffebcdff",
  blue: "0x0000ffff",
  blueviolet: "0x8a2be2ff",
  brown: "0xa52a2aff",
  burlywood: "0xdeb887ff",
  cadetblue: "0x5f9ea0ff",
  chartreuse: "0x7fff00ff",
  chocolate: "0xd2691eff",
  coral: "0xff7f50ff",
  cornflowerblue: "0x6495edff",
  cornsilk: "0xfff8dcff",
  crimson: "0xdc143cff",
  cyan: "0x00ffffff",
  darkblue: "0x00008bff",
  darkcyan: "0x008b8bff",
  darkgoldenrod: "0xb8860bff",
  darkgray: "0xa9a9a9ff",
  darkgreen: "0x006400ff",
  darkgrey: "0xa9a9a9ff",
  darkkhaki: "0xbdb76bff",
  darkmagenta: "0x8b008bff",
  darkolivegreen: "0x556b2fff",
  darkorange: "0xff8c00ff",
  darkorchid: "0x9932ccff",
  darkred: "0x8b0000ff",
  darksalmon: "0xe9967aff",
  darkseagreen: "0x8fbc8fff",
  darkslateblue: "0x483d8bff",
  darkslategray: "0x2f4f4fff",
  darkslategrey: "0x2f4f4fff",
  darkturquoise: "0x00ced1ff",
  darkviolet: "0x9400d3ff",
  deeppink: "0xff1493ff",
  deepskyblue: "0x00bfffff",
  dimgray: "0x696969ff",
  dimgrey: "0x696969ff",
  dodgerblue: "0x1e90ffff",
  firebrick: "0xb22222ff",
  floralwhite: "0xfffaf0ff",
  forestgreen: "0x228b22ff",
  fuchsia: "0xff00ffff",
  gainsboro: "0xdcdcdcff",
  ghostwhite: "0xf8f8ffff",
  gold: "0xffd700ff",
  goldenrod: "0xdaa520ff",
  gray: "0x808080ff",
  green: "0x008000ff",
  greenyellow: "0xadff2fff",
  grey: "0x808080ff",
  honeydew: "0xf0fff0ff",
  hotpink: "0xff69b4ff",
  indianred: "0xcd5c5cff",
  indigo: "0x4b0082ff",
  ivory: "0xfffff0ff",
  khaki: "0xf0e68cff",
  lavender: "0xe6e6faff",
  lavenderblush: "0xfff0f5ff",
  lawngreen: "0x7cfc00ff",
  lemonchiffon: "0xfffacdff",
  lightblue: "0xadd8e6ff",
  lightcoral: "0xf08080ff",
  lightcyan: "0xe0ffffff",
  lightgoldenrodyellow: "0xfafad2ff",
  lightgray: "0xd3d3d3ff",
  lightgreen: "0x90ee90ff",
  lightgrey: "0xd3d3d3ff",
  lightpink: "0xffb6c1ff",
  lightsalmon: "0xffa07aff",
  lightseagreen: "0x20b2aaff",
  lightskyblue: "0x87cefaff",
  lightslategray: "0x778899ff",
  lightslategrey: "0x778899ff",
  lightsteelblue: "0xb0c4deff",
  lightyellow: "0xffffe0ff",
  lime: "0x00ff00ff",
  limegreen: "0x32cd32ff",
  linen: "0xfaf0e6ff",
  magenta: "0xff00ffff",
  maroon: "0x800000ff",
  mediumaquamarine: "0x66cdaaff",
  mediumblue: "0x0000cdff",
  mediumorchid: "0xba55d3ff",
  mediumpurple: "0x9370dbff",
  mediumseagreen: "0x3cb371ff",
  mediumslateblue: "0x7b68eeff",
  mediumspringgreen: "0x00fa9aff",
  mediumturquoise: "0x48d1ccff",
  mediumvioletred: "0xc71585ff",
  midnightblue: "0x191970ff",
  mintcream: "0xf5fffaff",
  mistyrose: "0xffe4e1ff",
  moccasin: "0xffe4b5ff",
  navajowhite: "0xffdeadff",
  navy: "0x000080ff",
  oldlace: "0xfdf5e6ff",
  olive: "0x808000ff",
  olivedrab: "0x6b8e23ff",
  orange: "0xffa500ff",
  orangered: "0xff4500ff",
  orchid: "0xda70d6ff",
  palegoldenrod: "0xeee8aaff",
  palegreen: "0x98fb98ff",
  paleturquoise: "0xafeeeeff",
  palevioletred: "0xdb7093ff",
  papayawhip: "0xffefd5ff",
  peachpuff: "0xffdab9ff",
  peru: "0xcd853fff",
  pink: "0xffc0cbff",
  plum: "0xdda0ddff",
  powderblue: "0xb0e0e6ff",
  purple: "0x800080ff",
  rebeccapurple: "0x663399ff",
  red: "0xff0000ff",
  rosybrown: "0xbc8f8fff",
  royalblue: "0x4169e1ff",
  saddlebrown: "0x8b4513ff",
  salmon: "0xfa8072ff",
  sandybrown: "0xf4a460ff",
  seagreen: "0x2e8b57ff",
  seashell: "0xfff5eeff",
  sienna: "0xa0522dff",
  silver: "0xc0c0c0ff",
  skyblue: "0x87ceebff",
  slateblue: "0x6a5acdff",
  slategray: "0x708090ff",
  slategrey: "0x708090ff",
  snow: "0xfffafaff",
  springgreen: "0x00ff7fff",
  steelblue: "0x4682b4ff",
  tan: "0xd2b48cff",
  teal: "0x008080ff",
  thistle: "0xd8bfd8ff",
  tomato: "0xff6347ff",
  transparent: "0x00000000",
  turquoise: "0x40e0d0ff",
  violet: "0xee82eeff",
  wheat: "0xf5deb3ff",
  white: "0xffffffff",
  whitesmoke: "0xf5f5f5ff",
  yellow: "0xffff00ff",
  yellowgreen: "0x9acd32ff"
};

// node_modules/@lightningjs/blits/src/lib/colors/colors.js
var hex = /^#?([0-9a-f]{3}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
var rgba = /^(rgba?)\((\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\s*),(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\s*),(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\s*)(,(\s*(-?\d+(?:\.\d+)?)\s*))?\)$/;
var hsla = /^(hsla?)\((\s*(360|3[0-5][0-9]|[12]?[0-9]{1,2})\s*),(\s*(100|[1-9]?[0-9])\s*)%,(\s*(100|[1-9]?[0-9])\s*)%(,(\s*(1|0(?:\.\d+)?)\s*))?\)$/;
var hexLookup = {};
var decimalToHex = (decimal) => {
  if (hexLookup[decimal] !== void 0) {
    return hexLookup[decimal];
  }
  const resp = parseInt(decimal).toString(16).padStart(2, "0");
  hexLookup[decimal] = resp;
  return resp;
};
var colors_default = {
  normalize: (color = "", defaultColor = "0xffffffff") => {
    color = color.toString();
    if (color.startsWith("0x") && color.length === 10) {
      return color;
    }
    if (htmlColors_default[color] !== void 0) {
      return htmlColors_default[color];
    }
    if (hex.test(color)) {
      color = color.replace("#", "").toLowerCase();
      if (color.length === 3) {
        color = color.split("").map((c) => c + c).join("");
      }
      const colorRGBA = "0x" + color.padEnd(8, "f");
      htmlColors_default[color] = colorRGBA;
      return colorRGBA;
    }
    const rgbaMatch = rgba.exec(color);
    if (rgbaMatch) {
      const r = decimalToHex(rgbaMatch[3]);
      const g = decimalToHex(rgbaMatch[5]);
      const b = decimalToHex(rgbaMatch[7]);
      let a = "ff";
      if (rgbaMatch[10] && rgbaMatch[1] === "rgba") {
        const alpha = Math.min(Math.max(Math.round(parseFloat(rgbaMatch[10]) * 255), 0), 255);
        a = decimalToHex(alpha);
      }
      const resp = "0x" + r + g + b + a;
      htmlColors_default[color] = resp;
      return resp;
    }
    if (hsla.test(color)) {
      console.warn("HSL(A) color format is not supported yet");
      return "0xffffffff";
    }
    return defaultColor;
  }
};

// node_modules/@lightningjs/blits/src/lib/templateparser/parser.js
var parser_default = (template = "", componentName, parentComponent, filePath = null) => {
  let cursor = 0;
  let prevCursor = 0;
  let tags = [];
  let currentTag = null;
  let currentLevel = 0;
  const tagStartRegex = /^<\/?([a-zA-Z0-9_\-.]+)\s*/;
  const tagEndRegex = /^\s*(\/?>)\s*/;
  const attrNameRegex = /^([A-Za-z0-9:.\-_@$]+)=\s*(["'])/;
  const emptyTagStartRegex = /^<>\s*/;
  const emptyTagEndRegex = /^\s*(<\/>)\s*/;
  const parse = () => {
    template = clean(template);
    try {
      parseLoop(parseEmptyTagStart);
      return format(tags);
    } catch (error) {
      if (error.name == "TemplateParseError" || error.name == "TemplateStructureError") {
        error.message = `${error.message}
${error.context}`;
      }
      throw error;
    }
  };
  const parseLoop = (next) => {
    if (cursor >= template.length) {
      return;
    }
    next();
  };
  const clean = (templateText) => {
    return templateText.replace(/<!--.*?-->/gms, "").replace(/\r?\n\s*\r\n/gm, " ").replace(/\r?\n\s*(\S)/gm, " $1").replace(/\r?\n/g, "").trim();
  };
  const moveCursorOnMatch = (regex) => {
    const match = template.slice(cursor).match(regex);
    if (match) {
      prevCursor = cursor;
      cursor += match[0].length;
    }
    return match;
  };
  const parseEmptyTagStart = () => {
    const match = moveCursorOnMatch(emptyTagStartRegex);
    if (match) {
      tags.push({
        [Symbol.for("componentType")]: null,
        [symbols_default.type]: "opening",
        [symbols_default.level]: currentLevel,
        [symbols_default.cursorTagStart]: prevCursor
      });
      currentLevel++;
      parseLoop(parseEmptyTagStart);
    } else {
      parseLoop(parseEmptyTagEnd);
    }
  };
  const parseEmptyTagEnd = () => {
    const match = moveCursorOnMatch(emptyTagEndRegex);
    if (match) {
      currentLevel--;
      tags.push({
        [Symbol.for("componentType")]: null,
        [symbols_default.type]: "closing",
        [symbols_default.level]: currentLevel
      });
      parseLoop(parseEmptyTagStart);
    } else {
      parseLoop(parseTag);
    }
  };
  const parseTag = () => {
    const match = moveCursorOnMatch(tagStartRegex);
    if (match) {
      currentTag = {
        [Symbol.for("componentType")]: match[1],
        [symbols_default.level]: currentLevel,
        [symbols_default.cursorTagStart]: prevCursor
      };
      if (match[0].startsWith("</")) {
        currentLevel--;
        currentTag[symbols_default.type] = "closing";
        currentTag[symbols_default.level] = currentLevel;
      } else {
        currentTag[symbols_default.type] = "opening";
        currentLevel++;
      }
      parseLoop(parseTagEnd);
    } else {
      throw TemplateParseError("InvalidTag");
    }
  };
  const parseTagEnd = () => {
    const match = moveCursorOnMatch(tagEndRegex);
    if (match) {
      if (match[1] === "/>") {
        if (currentTag[symbols_default.type] === "closing") {
          throw TemplateParseError("InvalidClosingTag");
        }
        currentTag[symbols_default.type] = "self-closing";
        currentLevel--;
      }
      if (currentTag[symbols_default.type] === "opening") {
        const tagContent = template.slice(cursor, template.indexOf("<", cursor));
        if (tagContent) {
          currentTag.content = tagContent;
          cursor += tagContent.length;
        }
      }
      tags.push(currentTag);
      parseLoop(parseEmptyTagStart);
    } else {
      parseLoop(parseAttributes);
    }
  };
  const parseAttributes = () => {
    const attrNameMatch = moveCursorOnMatch(attrNameRegex);
    if (attrNameMatch) {
      if (currentTag[symbols_default.type] === "closing") {
        throw TemplateParseError("AttributesInClosingTag");
      }
      const delimiter = attrNameMatch[2];
      const attrValueRegex = new RegExp(`^(.*?)${delimiter}\\s*`);
      const attrValueMatch = moveCursorOnMatch(attrValueRegex);
      if (attrValueMatch) {
        const attr = formatAttribute(attrNameMatch[1], attrValueMatch[1]);
        currentTag[attr.name] = attr.value;
        parseLoop(parseTagEnd);
      } else {
        throw TemplateParseError("MissingOrInvalidAttributeValue");
      }
    } else {
      throw TemplateParseError("InvalidAttribute");
    }
  };
  const formatAttribute = (name, value) => {
    if (name.includes(".")) {
      const [objectName, attributeName] = name.split(".");
      return { name: objectName, value: `{${attributeName}: ${value}}` };
    }
    if (["color", ":color", ":effects", "effects"].includes(name)) {
      return processColors(name, value);
    }
    return { name, value };
  };
  const processColors = (name, value) => {
    let newValue = value;
    let normalized = colors_default.normalize(newValue, null);
    if (normalized === null) {
      const stringTokenRegex = /'([^']+)'/g;
      let match;
      let lastIndex = 0;
      let result = "";
      while ((match = stringTokenRegex.exec(value)) !== null) {
        const potentialColor = match[1];
        const matchIndex = match.index;
        const matchLength = match[0].length;
        result += value.slice(lastIndex, matchIndex);
        normalized = colors_default.normalize(potentialColor, null);
        if (normalized === null) {
          result += value.slice(matchIndex, matchIndex + matchLength);
        } else {
          result += `'${normalized}'`;
        }
        lastIndex = matchIndex + matchLength;
      }
      result += value.slice(lastIndex);
      newValue = result;
    } else {
      newValue = normalized;
    }
    return { name, value: newValue };
  };
  const format = (parsedData) => {
    let stack = [];
    let rootElementDefined = false;
    let output = { children: [] };
    let currentParent = output;
    for (let i = 0; i < parsedData.length; i++) {
      let element = parsedData[i];
      if (element[symbols_default.level] === 0 && element[symbols_default.type] !== "closing") {
        if (rootElementDefined) {
          throw TemplateStructureError("MultipleTopLevelTags", element);
        }
        rootElementDefined = true;
      }
      if (element[symbols_default.type] === "opening") {
        stack.push({
          [symbols_default.level]: element[symbols_default.level],
          [symbols_default.type]: element[symbols_default.type],
          [symbols_default.cursorTagStart]: element[symbols_default.cursorTagStart],
          [Symbol.for("componentType")]: element[Symbol.for("componentType")],
          parent: currentParent
          // helps getting the previous parent when closing tag is encountered
        });
      } else if (element[symbols_default.type] === "closing") {
        const isStackEmpty = stack.length === 0;
        let isLevelMismatch = false;
        let isTagMismatch = false;
        if (!isStackEmpty) {
          isLevelMismatch = stack[stack.length - 1][symbols_default.level] !== element[symbols_default.level];
          isTagMismatch = stack[stack.length - 1][Symbol.for("componentType")] !== element[Symbol.for("componentType")];
        }
        if (isStackEmpty || isLevelMismatch || isTagMismatch) {
          throw TemplateStructureError("MismatchedClosingTag", element);
        }
        const lastTag = stack.pop();
        currentParent = lastTag.parent;
      }
      const newItem = { ...element };
      delete newItem[symbols_default.type];
      delete newItem[symbols_default.level];
      delete newItem[symbols_default.cursorTagStart];
      if (element[symbols_default.type] === "opening") {
        if (i + 1 < parsedData.length && parsedData[i + 1][symbols_default.type] !== "closing") {
          newItem.children = [];
        }
        currentParent.children.push(newItem);
        currentParent = newItem;
      } else if (element[symbols_default.type] === "self-closing") {
        currentParent.children.push(newItem);
      }
    }
    if (stack.length > 0) {
      throw TemplateStructureError("UnclosedTags", stack);
    }
    return output;
  };
  const contextPaddingBefore = 10;
  const contextPaddingAfter = 50;
  const TemplateParseError = (message) => {
    const location = getErrorLocation();
    message = `${message} in ${location}`;
    const error = new Error(message);
    error.name = "TemplateParseError";
    const start = Math.max(0, prevCursor - contextPaddingBefore);
    const end = Math.min(template.length, cursor + contextPaddingAfter);
    const contextText = template.slice(start, end);
    const caretPosition = cursor - start;
    error.context = insertContextCaret(caretPosition, contextText);
    return error;
  };
  const TemplateStructureError = (message, context) => {
    const location = getErrorLocation();
    message = `${message} in ${location}`;
    const error = new Error(message);
    error.name = "TemplateStructureError";
    if (Array.isArray(context)) {
      error.context = context.map((tag) => generateContext(tag)).join("\n");
    } else {
      error.context = generateContext(context);
    }
    function generateContext(element) {
      const start = Math.max(0, element[symbols_default.cursorTagStart] - contextPaddingBefore);
      const contextText = template.slice(start, start + contextPaddingAfter);
      return insertContextCaret(contextPaddingBefore, contextText);
    }
    return error;
  };
  const insertContextCaret = (position, contextText) => {
    const caret = " ".repeat(position) + "^";
    return `
${contextText}
${caret}
`;
  };
  const getErrorLocation = () => {
    if (parentComponent) {
      let hierarchy = componentName || "";
      let currentParent = parentComponent;
      while (currentParent) {
        hierarchy = `${currentParent[Symbol.for("componentType")]}/${hierarchy}`;
        currentParent = currentParent.parent;
      }
      return hierarchy;
    }
    return filePath ? filePath : "Blits.Application";
  };
  return parse();
};

// node_modules/@lightningjs/blits/src/lib/codegenerator/generator.js
var counter;
function generator_default(templateObject = { children: [] }) {
  const ctx = {
    renderCode: [
      "const elms = []",
      "let componentType",
      "const rootComponent = component",
      "let propData"
    ],
    effectsCode: [],
    context: { props: [], components: this.components }
  };
  counter = -1;
  generateCode.call(ctx, templateObject);
  ctx.renderCode.push("return elms");
  return {
    render: new Function(
      "parent",
      "component",
      "context",
      "components",
      "effect",
      "getRaw",
      ctx.renderCode.join("\n")
    ),
    effects: ctx.effectsCode.map(
      (code) => new Function("component", "elms", "context", "components", "rootComponent", "effect", code)
    ),
    context: ctx.context
  };
}
var generateElementCode = function(templateObject, parent = false, options = { key: false, component: "component.", forceEffect: false, forloop: false }) {
  const renderCode = options.forceEffect ? this.effectsCode : this.renderCode;
  if (parent) {
    renderCode.push(`parent = ${parent}`);
  }
  if ("key" in templateObject) options.key = interpolate(templateObject.key, options.component);
  const elm = options.key ? `elms[${counter}][${options.key}]` : `elms[${counter}]`;
  if (options.key) {
    renderCode.push(`
      if(elms[${counter}] === undefined) {
        elms[${counter}] = {}
      }
    `);
  }
  renderCode.push(`const elementConfig${counter} = {}`);
  if (options.forloop) {
    renderCode.push(`if(${elm} === undefined) {`);
  }
  renderCode.push(`
    ${elm} = this.element({parent: parent || 'root'}, component)
  `);
  if (options.forloop) {
    renderCode.push("}");
  }
  const children = templateObject["children"];
  delete templateObject["children"];
  if (templateObject[Symbol.for("componentType")] === "Slot") {
    renderCode.push(`elementConfig${counter}[Symbol.for('isSlot')] = true`);
  }
  Object.keys(templateObject).forEach((key) => {
    if (key === "slot") {
      renderCode.push(`
        elementConfig${counter}['parent'] = component[Symbol.for('slots')].filter(slot => slot.ref === '${templateObject.slot}').shift() || parent
      `);
    }
    if (key === "key") return;
    if (isReactiveKey(key)) {
      if (options.holder && key === ":color") return;
      if (options.holder) {
        this.effectsCode.push(`
        if(typeof skip${counter} === 'undefined' ||
          skip${counter}.indexOf('${key.substring(1)}') === -1)
          ${elm}.set('${key.substring(1)}', ${interpolate(templateObject[key], options.component)})
        `);
      } else {
        this.effectsCode.push(`
            ${elm}.set('${key.substring(1)}', ${interpolate(
          templateObject[key],
          options.component
        )})
          `);
      }
      renderCode.push(
        `elementConfig${counter}['${key.substring(1)}'] = ${interpolate(
          templateObject[key],
          options.component
        )}`
      );
    } else {
      renderCode.push(
        `elementConfig${counter}['${key}'] = ${cast(templateObject[key], key, options.component)}`
      );
    }
  });
  if (options.holder === true) {
    renderCode.push(`
    const skip${counter} = []
    if(typeof cmp${counter} !== 'undefined') {
      for(let key in cmp${counter}.config.props) {
        delete elementConfig${counter}[cmp${counter}.config.props[key]]
        skip${counter}.push(cmp${counter}.config.props[key])
      }
    }
    `);
  }
  if (options.forloop) {
    renderCode.push(`if(${elm}.nodeId === undefined) {`);
  }
  renderCode.push(`${elm}.populate(elementConfig${counter})`);
  if (options.forloop) {
    renderCode.push("}");
  }
  if (children) {
    generateCode.call(this, { children }, `${elm}`, options);
  }
};
var generateComponentCode = function(templateObject, parent = false, options = {
  key: false,
  component: "component.",
  forceEffect: false,
  holder: false,
  forloop: false
}) {
  const renderCode = options.forceEffect ? this.effectsCode : this.renderCode;
  renderCode.push(`
    const cmp${counter} =
      (context.components && context.components['${templateObject[Symbol.for("componentType")]}']) || components['${templateObject[Symbol.for("componentType")]}']
  `);
  if ("key" in templateObject) {
    options.key = interpolate(templateObject.key, options.component);
  }
  const children = templateObject.children;
  delete templateObject.children;
  generateElementCode.call(this, templateObject, parent, { ...options, ...{ holder: true } });
  parent = options.key ? `elms[${counter}][${options.key}]` : `elms[${counter}]`;
  counter++;
  const elm = options.key ? `elms[${counter}][${options.key}]` : `elms[${counter}]`;
  if (options.key) {
    renderCode.push(`
      if(elms[${counter}] === undefined) {
        elms[${counter}] = {}
      }
    `);
  }
  if (parent) {
    renderCode.push(`parent = ${parent}`);
  }
  renderCode.push(`const props${counter} = {}`);
  if (options.forloop) {
    renderCode.push(`if(${elm} === undefined) {`);
  }
  Object.keys(templateObject).forEach((key) => {
    if (isReactiveKey(key)) {
      this.effectsCode.push(`
        ${elm}[Symbol.for('props')]['${key.substring(1)}'] = ${interpolate(
        templateObject[key],
        options.component
      )}`);
      renderCode.push(`
        propData = ${interpolate(templateObject[key], options.component)}
        if (Array.isArray(propData) === true) {
          propData = getRaw(propData).slice(0)
        }
        props${counter}['${key.substring(1)}'] = propData`);
    } else {
      renderCode.push(
        `props${counter}['${key}'] = ${cast(templateObject[key], key, options.component)}`
      );
    }
  });
  renderCode.push(`
    componentType = props${counter}['is'] || '${templateObject[Symbol.for("componentType")]}'

    let component${counter}
    if(typeof componentType === 'string') {
      component${counter} = context.components && context.components[componentType] || components[componentType]
      if(!component${counter}) {
        throw new Error('Component "${templateObject[Symbol.for("componentType")]}" not found')
      }
    } else if(typeof componentType === 'function' && componentType[Symbol.for('isComponent')] === true) {
      component${counter} = componentType
    }

    ${elm} = component${counter}.call(null, {props: props${counter}}, ${parent}, component)

    if (${elm}[Symbol.for('slots')][0]) {
      parent = ${elm}[Symbol.for('slots')][0]
      component = ${elm}
    } else {
      parent = ${elm}[Symbol.for('children')][0]
    }
  `);
  if (options.forloop) {
    renderCode.push("}");
  }
  if (children) {
    counter++;
    generateElementCode.call(this, { children }, false, { ...options });
  }
};
var generateForLoopCode = function(templateObject, parent) {
  const forLoop = templateObject[":for"];
  delete templateObject[":for"];
  const key = templateObject["key"];
  const forKey = interpolate(key, "scope.");
  const shallow = !!!(templateObject["$shallow"] && templateObject["$shallow"].toLowerCase() === "false");
  delete templateObject["$shallow"];
  delete templateObject["key"];
  const regex = /(.+)\s+in\s+(.+)/gi;
  const result = regex.exec(forLoop);
  const [item, index = "index"] = result[1].replace("(", "").replace(")", "").split(/\s*,\s*/);
  const scopeRegex = new RegExp(`(scope\\.(?!${item}\\.|${index}|key)(\\w+))`, "gi");
  const ctx = {
    renderCode: [],
    effectsCode: [],
    context: { props: [], components: this.components }
  };
  if (parent) {
    ctx.renderCode.push(`parent = ${parent}`);
  }
  const indexRegex = new RegExp(`\\$${index}(?!['\\w])`);
  const indexResult = indexRegex.exec(key);
  if (Array.isArray(indexResult)) {
    ctx.renderCode.push(
      `console.warn(" Using '${index}' in the key, like key=${key},  is not recommended")`
    );
  }
  const forStartCounter = counter;
  ctx.renderCode.push(`
    const created${forStartCounter} = []
    const forloop${forStartCounter} = (collection = [], elms, created) => {
      const rawCollection = getRaw(collection)
      const keys = new Set()
      let l = rawCollection.length
      while(l--) {
        const ${item} = rawCollection[l]
        const ${index} = l
        keys.add('' +  ${interpolate(key, "") || "l"})
      }
  `);
  const indexToInjectDestroyCode = ctx.renderCode.length;
  ctx.renderCode.push(`
      created.length = 0
      const length = rawCollection.length
      for(let __index = 0; __index < length; __index++) {
        const scope = Object.create(component)
        parent = ${parent}
        scope['${index}'] = __index
        scope['${item}'] = rawCollection[__index]
        scope['key'] = '' + ${forKey || "__index"}
  `);
  if ("ref" in templateObject && templateObject.ref.indexOf("$") === -1) {
    ctx.renderCode.push(`
        scope['__ref'] = '${templateObject.ref}' + __index
    `);
    templateObject.ref = "$__ref";
  }
  ctx.renderCode.push(`
        created.push(scope.key)
  `);
  if (templateObject[Symbol.for("componentType")] === "Element" || templateObject[Symbol.for("componentType")] === "Slot" || templateObject[Symbol.for("componentType")] === "Text") {
    if (templateObject[Symbol.for("componentType")] === "Text") {
      templateObject.__textnode = "true";
    }
    generateElementCode.call(ctx, templateObject, parent, {
      key: "scope.key",
      component: "scope.",
      forceEffect: false,
      forloop: true
    });
  } else {
    generateComponentCode.call(ctx, templateObject, false, {
      key: "scope.key",
      component: "scope.",
      forceEffect: false,
      forloop: true
    });
  }
  const innerScopeEffects = ctx.effectsCode.filter(
    (effect2) => [...effect2.matchAll(scopeRegex)].length === 0
  );
  const outerScopeEffects = ctx.effectsCode.filter(
    (effect2) => [...effect2.matchAll(scopeRegex)].length !== 0
  );
  if (shallow === false) {
    ctx.renderCode.push(`
      scope['${item}'] = null
      scope['${item}'] = collection[__index]
  `);
  }
  innerScopeEffects.forEach((effect2, index2) => {
    const key2 = effect2.indexOf(`scope.${index2}`) > -1 ? `'${interpolate(result[2], "")}'` : null;
    if (effect2.indexOf("Symbol.for('props')") === -1) {
      ctx.renderCode.push(`
        let eff${index2} = () => {
          ${effect2}
        }
        effect(eff${index2}, ${key2})
        component[Symbol.for('effects')].push(eff${index2})
      `);
    } else {
      ctx.renderCode.push(`
        ${effect2}
      `);
    }
  });
  ctx.renderCode.push(`
    }
  }`);
  const destroyCode = [];
  destroyCode.push(`
      let i = created.length

      while (i--) {
        if (keys.has(created[i]) === false) {
          const key = created[i]
  `);
  const forEndCounter = counter;
  for (let i = forStartCounter; i <= forEndCounter; i++) {
    destroyCode.push(`
          elms[${i}][key] && elms[${i}][key].destroy()
          delete elms[${i}][key]
      `);
  }
  destroyCode.push(`
       }
    }
  `);
  ctx.renderCode.splice(indexToInjectDestroyCode, 0, ...destroyCode);
  let effectKey = `${interpolate(result[2], "")}`;
  if (effectKey && effectKey.includes(".")) {
    effectKey = effectKey.match(/[^.]+$/)[0];
  }
  ctx.renderCode.push(`
    effect(() => {
      forloop${forStartCounter}(${cast(result[2], ":for")}, elms, created${forStartCounter})
    }, '${effectKey}' )
  `);
  outerScopeEffects.forEach((effect2) => {
    const matches = [...effect2.matchAll(scopeRegex)];
    let l = matches.length;
    const refs = [];
    while (l--) {
      const match = matches[l];
      const ref = `component.${match[2]}`;
      refs.indexOf(ref) === -1 && refs.push(ref);
      if (match[2] !== item) {
        effect2 = effect2.substring(0, match.index) + ref + effect2.substring(match.index + match[1].length);
      }
    }
    ctx.renderCode.push(`
      effect(() => {
        void ${refs.join(", ")}
        for(let __index = 0; __index < ${interpolate(result[2])}.length; __index++) {
          const scope = {}
          scope['${index}'] = __index
          scope['${item}'] = ${interpolate(result[2])}[__index]
          scope['key'] = ${forKey || "__index"}
    `);
    ctx.renderCode.push(`
          ${effect2}
        }
      })
    `);
  });
  this.renderCode.push(ctx.renderCode.join("\n"));
};
var generateCode = function(templateObject, parent = false, options = {}) {
  templateObject.children && templateObject.children.forEach((childTemplateObject) => {
    counter++;
    if (Object.keys(childTemplateObject).indexOf(":for") > -1) {
      generateForLoopCode.call(this, childTemplateObject, parent);
    } else {
      if (childTemplateObject[Symbol.for("componentType")] === "Element" || childTemplateObject[Symbol.for("componentType")] === "Slot" || childTemplateObject[Symbol.for("componentType")] === "Text" || childTemplateObject[Symbol.for("componentType")] === "Layout") {
        if (childTemplateObject[Symbol.for("componentType")] === "Text") {
          childTemplateObject.__textnode = "true";
        }
        if (childTemplateObject[Symbol.for("componentType")] === "Layout") {
          childTemplateObject.__layout = "true";
        }
        generateElementCode.call(this, childTemplateObject, parent, options);
      } else {
        generateComponentCode.call(this, childTemplateObject, parent, options);
      }
    }
  });
};
var interpolate = (val, component = "component.") => {
  if (val === void 0) return val;
  const replaceString = /('.*?')+/gi;
  const replaceDollar = /\$(\$(?=\$)|\$?)/g;
  const matches = val.matchAll(replaceString);
  const restore = [];
  let i = 0;
  for (const match of matches) {
    restore.push(match[0]);
    val = val.replace(match[0], `[@@REPLACEMENT${i}@@]`);
    i++;
  }
  val = val.replace(replaceDollar, (match, group1) => {
    if (group1 === "") {
      return component;
    } else if (group1 === "$") {
      return component + "$";
    }
  });
  restore.forEach((el, idx) => {
    val = val.replace(`[@@REPLACEMENT${idx}@@]`, el);
  });
  return val;
};
var cast = (val = "", key = false, component = "component.") => {
  const dynamicArgumentRegex = /\$\w+/gi;
  let castedValue;
  if (key === "content") {
    if (val.startsWith("$")) {
      castedValue = `${component}${val.replace("$", "")}`;
    } else {
      const escapedVal = val.replace(/\\\\/g, "__DOUBLE_BACKSLASH__").replace(/(^|[^\\])'/g, "$1\\'").replace(/__DOUBLE_BACKSLASH__/g, "\\\\");
      castedValue = `'${parseInlineContent(escapedVal, component)}'`;
    }
  } else if (key !== "color" && !isNaN(parseFloat(val))) {
    castedValue = parseFloat(val);
    if (val.endsWith("%")) {
      const map = {
        w: "width",
        width: "width",
        x: "width",
        h: "height",
        height: "height",
        y: "height"
      };
      const base = map[key];
      if (base) {
        castedValue = `parent.node.${base} * (${castedValue} / 100)`;
      }
    }
  } else if (val.toLowerCase() === "true") {
    castedValue = true;
  } else if (val.toLowerCase() === "false") {
    castedValue = false;
  } else if (key.startsWith("@") && val) {
    const c = component.slice(0, -1);
    castedValue = `${c}['${val.replace("$", "")}'] && ${c}['${val.replace("$", "")}'].bind(${c})`;
  } else if (val.startsWith("$")) {
    castedValue = `${component}${val.replace("$", "")}`;
  } else if (dynamicArgumentRegex.exec(val)) {
    const rex = /\w+\s*:\s*(?:[^\s,}]+|".*?"|'.*?')/g;
    const results = val.match(rex);
    castedValue = {};
    if (results) {
      for (let i = 0; i < results.length; i++) {
        const members = results[i].split(/\s*:\s*/);
        if (members) {
          populateFields(members[0], members[1], component, castedValue);
        }
      }
    }
    return interpolateObject(castedValue);
  } else {
    castedValue = `"${val}"`;
  }
  return castedValue;
};
var isReactiveKey = (str) => str.startsWith(":");
var parseInlineContent = (val, component) => {
  const dynamicParts = /\{\{\s*(\$\S+)\s*\}\}/g;
  const matches = [...val.matchAll(dynamicParts)];
  if (matches.length) {
    for (let [match, arg] of matches) {
      val = val.replace(match, `${arg.replace("$", `'+${component}`)}+'`);
    }
  }
  return val;
};
var populateFields = (prop, val, component, target) => {
  if (val.startsWith("$")) {
    target[prop] = `${component}${val.replace("$", "")}`;
  } else {
    target[prop] = val;
  }
};
var interpolateObject = (input) => {
  const interpolatedResults = [];
  Object.keys(input).forEach((key) => {
    interpolatedResults.push(`${key}: ${input[key]}`);
  });
  return ` { ${interpolatedResults.join(", ")} }`;
};

// node_modules/@lightningjs/blits/src/lib/componentId.js
var counters = {};
var counter2 = 0;
var createHumanReadableId = (name) => {
  return `BlitsComponent::${name}_${counters[name] = (counters[name] || 0) + 1}`;
};
var createInternalId = () => {
  return ++counter2;
};

// node_modules/@lightningjs/blits/src/lib/hooks.js
var cbs = {};
var emit = (hook, identifier, scope, data = []) => {
  cbs[identifier] && cbs[identifier][hook] && cbs[identifier][hook].apply(scope, data);
};
var privateEmit = (hook, identifier, scope) => {
  const symHook = symbols_default[hook];
  cbs[identifier] && cbs[identifier][symHook] && cbs[identifier][symHook].apply(scope);
};
var registerHooks = (hooks = {}, identifier) => {
  cbs[identifier] = {};
  const hookKeys = [...Object.keys(hooks), ...Object.getOwnPropertySymbols(hooks)];
  hookKeys.forEach((hook) => {
    if (typeof hooks[hook] === "function") cbs[identifier][hook] = hooks[hook];
  });
};

// node_modules/@lightningjs/renderer/dist/src/utils.js
function createWebGLContext(canvas, forceWebGL2 = false, contextSpy) {
  const config = {
    alpha: true,
    antialias: false,
    depth: false,
    stencil: true,
    desynchronized: false,
    // Disabled because it prevents Visual Regression Tests from working
    // failIfMajorPerformanceCaveat: true,
    powerPreference: "high-performance",
    premultipliedAlpha: true,
    preserveDrawingBuffer: false
  };
  const gl = (
    // TODO: Remove this assertion once this issue is fixed in TypeScript
    // https://github.com/microsoft/TypeScript/issues/53614
    canvas.getContext(forceWebGL2 ? "webgl2" : "webgl", config) || canvas.getContext("experimental-webgl", config)
  );
  if (!gl) {
    throw new Error("Unable to create WebGL context");
  }
  if (contextSpy) {
    return new Proxy(gl, {
      get(target, prop) {
        const value = target[prop];
        if (typeof value === "function") {
          contextSpy.increment(String(prop));
          return value.bind(target);
        }
        return value;
      }
    });
  }
  return gl;
}
function assertTruthy(condition, message) {
  if (isProductionEnvironment() === true)
    return;
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function mergeColorProgress(rgba1, rgba2, p) {
  const r1 = Math.trunc(rgba1 >>> 24);
  const g1 = Math.trunc(rgba1 >>> 16 & 255);
  const b1 = Math.trunc(rgba1 >>> 8 & 255);
  const a1 = Math.trunc(rgba1 & 255);
  const r2 = Math.trunc(rgba2 >>> 24);
  const g2 = Math.trunc(rgba2 >>> 16 & 255);
  const b2 = Math.trunc(rgba2 >>> 8 & 255);
  const a2 = Math.trunc(rgba2 & 255);
  const r = Math.round(r2 * p + r1 * (1 - p));
  const g = Math.round(g2 * p + g1 * (1 - p));
  const b = Math.round(b2 * p + b1 * (1 - p));
  const a = Math.round(a2 * p + a1 * (1 - p));
  return (r << 24 | g << 16 | b << 8 | a) >>> 0;
}
function mergeColorAlpha(rgba2, alpha) {
  const r = rgba2 >>> 24;
  const g = rgba2 >>> 16 & 255;
  const b = rgba2 >>> 8 & 255;
  const a = Math.trunc((rgba2 & 255) * alpha);
  return (r << 24 | g << 16 | b << 8 | a) >>> 0;
}
var premultiplyRGB = true;
function setPremultiplyMode(mode) {
  premultiplyRGB = mode === "webgl";
}
function mergeColorAlphaPremultiplied(rgba2, alpha, flipEndianess = false) {
  const newAlpha = (rgba2 & 255) / 255 * alpha;
  const rgbAlpha = premultiplyRGB ? newAlpha : 1;
  const r = Math.trunc((rgba2 >>> 24) * rgbAlpha);
  const g = Math.trunc((rgba2 >>> 16 & 255) * rgbAlpha);
  const b = Math.trunc((rgba2 >>> 8 & 255) * rgbAlpha);
  const a = Math.trunc(newAlpha * 255);
  if (flipEndianess) {
    return (a << 24 | b << 16 | g << 8 | r) >>> 0;
  }
  return (r << 24 | g << 16 | b << 8 | a) >>> 0;
}
function hasOwn(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function isProductionEnvironment() {
  return import.meta.env && import.meta.env.PROD;
}
var nextId = 1;
function getNewId() {
  return nextId++;
}

// node_modules/@lightningjs/renderer/dist/src/common/EventEmitter.js
var EventEmitter = class {
  constructor() {
    __publicField(this, "eventListeners", {});
  }
  on(event, listener) {
    let listeners = this.eventListeners[event];
    if (!listeners) {
      listeners = [];
    }
    listeners.push(listener);
    this.eventListeners[event] = listeners;
  }
  off(event, listener) {
    const listeners = this.eventListeners[event];
    if (!listeners) {
      return;
    }
    if (!listener) {
      delete this.eventListeners[event];
      return;
    }
    const index = listeners.indexOf(listener);
    if (index >= 0) {
      listeners.splice(index, 1);
    }
  }
  once(event, listener) {
    const onceListener = (target, data) => {
      this.off(event, onceListener);
      listener(target, data);
    };
    this.on(event, onceListener);
  }
  emit(event, data) {
    const listeners = this.eventListeners[event];
    if (!listeners) {
      return;
    }
    [...listeners].forEach((listener) => {
      listener(this, data);
    });
  }
  removeAllListeners() {
    this.eventListeners = {};
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/lib/utils.js
var PROTOCOL_REGEX = /^(data|ftps?|https?):/;
var getNormalizedRgbaComponents = (rgba2) => {
  const r = rgba2 >>> 24;
  const g = rgba2 >>> 16 & 255;
  const b = rgba2 >>> 8 & 255;
  const a = rgba2 & 255;
  return [r / 255, g / 255, b / 255, a / 255];
};
var getRgbaComponents = (rgba2) => {
  const r = rgba2 >>> 24;
  const g = rgba2 >>> 16 & 255;
  const b = rgba2 >>> 8 & 255;
  const a = rgba2 & 255;
  return [r, g, b, a];
};
function getNormalizedAlphaComponent(rgba2) {
  return (rgba2 & 255) / 255;
}
function getRgbaString(color) {
  const r = Math.floor(color[0] * 255);
  const g = Math.floor(color[1] * 255);
  const b = Math.floor(color[2] * 255);
  const a = Math.floor(color[3] * 255);
  return `rgba(${r},${g},${b},${a.toFixed(4)})`;
}
function createBound(x1, y1, x2, y2, out) {
  if (out) {
    out.x1 = x1;
    out.y1 = y1;
    out.x2 = x2;
    out.y2 = y2;
    return out;
  }
  return {
    x1,
    y1,
    x2,
    y2
  };
}
function boundsOverlap(a, b) {
  return a.x1 < b.x2 && a.x2 > b.x1 && a.y1 < b.y2 && a.y2 > b.y1;
}
function convertBoundToRect(bound, out) {
  if (out) {
    out.x = bound.x1;
    out.y = bound.y1;
    out.width = bound.x2 - bound.x1;
    out.height = bound.y2 - bound.y1;
    return out;
  }
  return {
    x: bound.x1,
    y: bound.y1,
    width: bound.x2 - bound.x1,
    height: bound.y2 - bound.y1
  };
}
function intersectRect(a, b, out) {
  const x = Math.max(a.x, b.x);
  const y = Math.max(a.y, b.y);
  const width = Math.min(a.x + a.width, b.x + b.width) - x;
  const height = Math.min(a.y + a.height, b.y + b.height) - y;
  if (width > 0 && height > 0) {
    if (out) {
      out.x = x;
      out.y = y;
      out.width = width;
      out.height = height;
      return out;
    }
    return {
      x,
      y,
      width,
      height
    };
  }
  if (out) {
    out.x = 0;
    out.y = 0;
    out.width = 0;
    out.height = 0;
    return out;
  }
  return {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
}
function copyRect(a, out) {
  if (out) {
    out.x = a.x;
    out.y = a.y;
    out.width = a.width;
    out.height = a.height;
    return out;
  }
  return {
    x: a.x,
    y: a.y,
    width: a.width,
    height: a.height
  };
}
function compareRect(a, b) {
  if (a === b) {
    return true;
  }
  if (a === null || b === null) {
    return false;
  }
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function boundInsideBound(bound1, bound2) {
  return bound1.x1 <= bound2.x2 && bound1.y1 <= bound2.y2 && bound1.x2 >= bound2.x1 && bound1.y2 >= bound2.y1;
}
function boundLargeThanBound(bound1, bound2) {
  return bound1.x1 < bound2.x1 && bound1.x2 > bound2.x2 && bound1.y1 < bound2.y1 && bound1.y2 > bound2.y2;
}
function isBoundPositive(bound) {
  return bound.x1 < bound.x2 && bound.y1 < bound.y2;
}
function createPreloadBounds(strictBound, boundsMargin) {
  return createBound(strictBound.x1 - boundsMargin[3], strictBound.y1 - boundsMargin[0], strictBound.x2 + boundsMargin[1], strictBound.y2 + boundsMargin[2]);
}
function convertUrlToAbsolute(url) {
  if (self.location.protocol === "file:" && !PROTOCOL_REGEX.test(url)) {
    const path = self.location.pathname.split("/");
    path.pop();
    const basePath = path.join("/");
    const baseUrl = self.location.protocol + "//" + basePath;
    if (url.charAt(0) === ".") {
      url = url.slice(1);
    }
    if (url.charAt(0) === "/") {
      url = url.slice(1);
    }
    return baseUrl + "/" + url;
  }
  const absoluteUrl = new URL(url, self.location.href);
  return absoluteUrl.href;
}

// node_modules/@lightningjs/renderer/dist/src/core/lib/Matrix3d.js
var Matrix3d = class _Matrix3d {
  /**
   * Creates a new 3x3 matrix.
   *
   * @param entries Row-major 3x3 matrix
   */
  constructor() {
    __publicField(this, "ta");
    __publicField(this, "tb");
    __publicField(this, "tx");
    __publicField(this, "tc");
    __publicField(this, "td");
    __publicField(this, "ty");
    __publicField(this, "_floatArr", null);
    /**
     * Potential Mutation Flag
     *
     * @remarks
     * This flag is set to true whenever the matrix is potentially modified.
     * We don't waste CPU trying to identify if each operation actually modifies
     * the matrix. Instead, we set this flag to true whenever we think the matrix
     * is modified. This signals that the `floatArr` should to be updated.
     */
    __publicField(this, "mutation");
    this.ta = 0;
    this.tb = 0;
    this.tx = 0;
    this.tc = 0;
    this.td = 0;
    this.ty = 0;
    this.mutation = true;
  }
  /**
   * Returns a temporary matrix that can be used for calculations.
   *
   * @remarks
   * This is useful for avoiding allocations in tight loops.
   *
   * The matrix is not guaranteed to be the same between calls.
   *
   * @returns
   */
  static get temp() {
    return tempMatrix;
  }
  static multiply(a, b, out) {
    const e0 = a.ta * b.ta + a.tb * b.tc;
    const e1 = a.ta * b.tb + a.tb * b.td;
    const e2 = a.ta * b.tx + a.tb * b.ty + a.tx;
    const e3 = a.tc * b.ta + a.td * b.tc;
    const e4 = a.tc * b.tb + a.td * b.td;
    const e5 = a.tc * b.tx + a.td * b.ty + a.ty;
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = e0;
    out.tb = e1;
    out.tx = e2;
    out.tc = e3;
    out.td = e4;
    out.ty = e5;
    out.mutation = true;
    return out;
  }
  static identity(out) {
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = 1;
    out.tb = 0;
    out.tx = 0;
    out.tc = 0;
    out.td = 1;
    out.ty = 0;
    out.mutation = true;
    return out;
  }
  static translate(x, y, out) {
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = 1;
    out.tb = 0;
    out.tx = x;
    out.tc = 0;
    out.td = 1;
    out.ty = y;
    out.mutation = true;
    return out;
  }
  static scale(sx, sy, out) {
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = sx;
    out.tb = 0;
    out.tx = 0;
    out.tc = 0;
    out.td = sy;
    out.ty = 0;
    out.mutation = true;
    return out;
  }
  static rotate(angle, out) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    if (!out) {
      out = new _Matrix3d();
    }
    out.ta = cos;
    out.tb = -sin;
    out.tx = 0;
    out.tc = sin;
    out.td = cos;
    out.ty = 0;
    out.mutation = true;
    return out;
  }
  static copy(src, dst) {
    if (!dst) {
      dst = new _Matrix3d();
    }
    dst.ta = src.ta;
    dst.tc = src.tc;
    dst.tb = src.tb;
    dst.td = src.td;
    dst.tx = src.tx;
    dst.ty = src.ty;
    dst.mutation = true;
    return dst;
  }
  translate(x, y) {
    this.tx = this.ta * x + this.tb * y + this.tx;
    this.ty = this.tc * x + this.td * y + this.ty;
    this.mutation = true;
    return this;
  }
  scale(sx, sy) {
    this.ta = this.ta * sx;
    this.tb = this.tb * sy;
    this.tc = this.tc * sx;
    this.td = this.td * sy;
    this.mutation = true;
    return this;
  }
  rotate(angle) {
    if (angle === 0 || !(angle % Math.PI * 2)) {
      return this;
    }
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const e0 = this.ta * cos + this.tb * sin;
    const e1 = this.tb * cos - this.ta * sin;
    const e3 = this.tc * cos + this.td * sin;
    const e4 = this.td * cos - this.tc * sin;
    this.ta = e0;
    this.tb = e1;
    this.tc = e3;
    this.td = e4;
    this.mutation = true;
    return this;
  }
  multiply(other) {
    return _Matrix3d.multiply(this, other, this);
  }
  /**
   * Returns the matrix as a Float32Array in column-major order.
   *
   * @remarks
   * This method is optimized to avoid unnecessary allocations. The same array
   * is returned every time this method is called, and is updated in place.
   *
   * WARNING: Use the array only for passing directly to a WebGL shader uniform
   * during a frame render. Do not modify or hold onto the array for longer than
   * a frame.
   */
  getFloatArr() {
    if (!this._floatArr) {
      this._floatArr = new Float32Array(9);
    }
    if (this.mutation) {
      this._floatArr[0] = this.ta;
      this._floatArr[1] = this.tc;
      this._floatArr[2] = 0;
      this._floatArr[3] = this.tb;
      this._floatArr[4] = this.td;
      this._floatArr[5] = 0;
      this._floatArr[6] = this.tx;
      this._floatArr[7] = this.ty;
      this._floatArr[8] = 1;
      this.mutation = false;
    }
    return this._floatArr;
  }
};
var tempMatrix = new Matrix3d();

// node_modules/@lightningjs/renderer/dist/src/core/lib/RenderCoords.js
var rx1 = 0;
var rx2 = 2;
var rx3 = 4;
var rx4 = 6;
var ry1 = 1;
var ry2 = 3;
var ry3 = 5;
var ry4 = 7;
var RenderCoords = class _RenderCoords {
  constructor(entries) {
    __publicField(this, "data");
    this.data = new Float32Array(8);
    if (entries) {
      this.data[rx1] = entries[rx1];
      this.data[rx2] = entries[rx2];
      this.data[rx3] = entries[rx3];
      this.data[rx4] = entries[rx4];
      this.data[ry1] = entries[ry1];
      this.data[ry2] = entries[ry2];
      this.data[ry3] = entries[ry3];
      this.data[ry4] = entries[ry4];
    }
  }
  static translate(x1, y1, x2, y2, x3, y3, x4, y4, out) {
    if (!out) {
      out = new _RenderCoords();
    }
    out.data[rx1] = x1;
    out.data[rx2] = x2;
    out.data[rx3] = x3;
    out.data[rx4] = x4;
    out.data[ry1] = y1;
    out.data[ry2] = y2;
    out.data[ry3] = y3;
    out.data[ry4] = y4;
    return out;
  }
  get x1() {
    return this.data[rx1];
  }
  get x2() {
    return this.data[rx2];
  }
  get x3() {
    return this.data[rx3];
  }
  get x4() {
    return this.data[rx4];
  }
  get y1() {
    return this.data[ry1];
  }
  get y2() {
    return this.data[ry2];
  }
  get y3() {
    return this.data[ry3];
  }
  get y4() {
    return this.data[ry4];
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/utils.js
var degree = Math.PI / 180;
var isPowerOfTwo = (value) => {
  return value && !(value & value - 1);
};
var getTimingBezier = (a, b, c, d) => {
  const xc = 3 * a;
  const xb = 3 * (c - a) - xc;
  const xa = 1 - xc - xb;
  const yc = 3 * b;
  const yb = 3 * (d - b) - yc;
  const ya = 1 - yc - yb;
  return function(time2) {
    if (time2 >= 1) {
      return 1;
    }
    if (time2 <= 0) {
      return 0;
    }
    let t = 0.5, cbx, cbxd, dx;
    for (let it = 0; it < 20; it++) {
      cbx = t * (t * (t * xa + xb) + xc);
      dx = time2 - cbx;
      if (dx > -1e-8 && dx < 1e-8) {
        return t * (t * (t * ya + yb) + yc);
      }
      cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
      if (cbxd > 1e-10 && cbxd < 1e-10) {
        break;
      }
      t += dx / cbxd;
    }
    let minT = 0;
    let maxT = 1;
    for (let it = 0; it < 20; it++) {
      t = 0.5 * (minT + maxT);
      cbx = t * (t * (t * xa + xb) + xc);
      dx = time2 - cbx;
      if (dx > -1e-8 && dx < 1e-8) {
        return t * (t * (t * ya + yb) + yc);
      }
      if (dx < 0) {
        maxT = t;
      } else {
        minT = t;
      }
    }
  };
};
var timingMapping = {};
var timingLookup = {
  ease: [0.25, 0.1, 0.25, 1],
  "ease-in": [0.42, 0, 1, 1],
  "ease-out": [0, 0, 0.58, 1],
  "ease-in-out": [0.42, 0, 0.58, 1],
  "ease-in-sine": [0.12, 0, 0.39, 0],
  "ease-out-sine": [0.12, 0, 0.39, 0],
  "ease-in-out-sine": [0.37, 0, 0.63, 1],
  "ease-in-cubic": [0.32, 0, 0.67, 0],
  "ease-out-cubic": [0.33, 1, 0.68, 1],
  "ease-in-out-cubic": [0.65, 0, 0.35, 1],
  "ease-in-circ": [0.55, 0, 1, 0.45],
  "ease-out-circ": [0, 0.55, 0.45, 1],
  "ease-in-out-circ": [0.85, 0, 0.15, 1],
  "ease-in-back": [0.36, 0, 0.66, -0.56],
  "ease-out-back": [0.34, 1.56, 0.64, 1],
  "ease-in-out-back": [0.68, -0.6, 0.32, 1.6]
};
var defaultTiming = (t) => t;
var parseCubicBezier = (str) => {
  const regex = /-?\d*\.?\d+/g;
  const match = str.match(regex);
  if (match) {
    const [num1, num2, num3, num4] = match;
    const a = parseFloat(num1 || "0.42");
    const b = parseFloat(num2 || "0");
    const c = parseFloat(num3 || "1");
    const d = parseFloat(num4 || "1");
    const timing = getTimingBezier(a, b, c, d);
    timingMapping[str] = timing;
    return timing;
  }
  console.warn("Unknown cubic-bezier timing: " + str);
  return defaultTiming;
};
var getTimingFunction = (str) => {
  if (str === "linear") {
    return defaultTiming;
  }
  if (timingMapping[str] !== void 0) {
    return timingMapping[str] || defaultTiming;
  }
  if (str === "step-start") {
    return () => {
      return 1;
    };
  }
  if (str === "step-end") {
    return (time2) => {
      return time2 === 1 ? 1 : 0;
    };
  }
  const lookup = timingLookup[str];
  if (lookup !== void 0) {
    const [a, b, c, d] = lookup;
    const timing = getTimingBezier(a, b, c, d);
    timingMapping[str] = timing;
    return timing;
  }
  if (str.startsWith("cubic-bezier")) {
    return parseCubicBezier(str);
  }
  console.warn("Unknown timing function: " + str);
  return defaultTiming;
};
function bytesToMb(bytes) {
  return (bytes / 1024 / 1024).toFixed(2);
}

// node_modules/@lightningjs/renderer/dist/src/core/animations/CoreAnimation.js
var CoreAnimation = class extends EventEmitter {
  constructor(node, props, settings2) {
    super();
    __publicField(this, "node");
    __publicField(this, "props");
    __publicField(this, "settings");
    __publicField(this, "progress", 0);
    __publicField(this, "delayFor", 0);
    __publicField(this, "delay", 0);
    __publicField(this, "timingFunction");
    __publicField(this, "propValuesMap", {});
    __publicField(this, "dynPropValuesMap");
    this.node = node;
    this.props = props;
    for (const key in props) {
      if (key !== "shaderProps") {
        if (this.propValuesMap["props"] === void 0) {
          this.propValuesMap["props"] = {};
        }
        this.propValuesMap["props"][key] = {
          start: node[key] || 0,
          target: props[key]
        };
      } else if (node.shader.type !== "DynamicShader") {
        this.propValuesMap["shaderProps"] = {};
        for (const key2 in props.shaderProps) {
          this.propValuesMap["shaderProps"][key2] = {
            start: node.shader.props[key2],
            target: props.shaderProps[key2]
          };
        }
      } else {
        const shaderPropKeys = Object.keys(props.shaderProps);
        const spLength = shaderPropKeys.length;
        this.dynPropValuesMap = {};
        for (let j = 0; j < spLength; j++) {
          const effectName = shaderPropKeys[j];
          const effect2 = props.shaderProps[effectName];
          this.dynPropValuesMap[effectName] = {};
          const effectProps = Object.entries(effect2);
          const eLength = effectProps.length;
          for (let k = 0; k < eLength; k++) {
            const [key2, value] = effectProps[k];
            this.dynPropValuesMap[effectName][key2] = {
              start: node.shader.props[effectName][key2],
              target: value
            };
          }
        }
      }
    }
    const easing = settings2.easing || "linear";
    const delay = settings2.delay ?? 0;
    this.settings = {
      duration: settings2.duration ?? 0,
      delay,
      easing,
      loop: settings2.loop ?? false,
      repeat: settings2.repeat ?? 0,
      repeatDelay: settings2.repeatDelay ?? 0,
      stopMethod: settings2.stopMethod ?? false
    };
    this.timingFunction = getTimingFunction(easing);
    this.delayFor = delay;
    this.delay = delay;
  }
  reset() {
    this.progress = 0;
    this.delayFor = this.settings.delay || 0;
    this.update(0);
  }
  restoreValues(target, valueMap) {
    const entries = Object.entries(valueMap);
    const eLength = entries.length;
    for (let i = 0; i < eLength; i++) {
      const [key, value] = entries[i];
      target[key] = value.start;
    }
  }
  restore() {
    this.reset();
    if (this.propValuesMap["props"] !== void 0) {
      this.restoreValues(this.node, this.propValuesMap["props"]);
    }
    if (this.propValuesMap["shaderProps"] !== void 0) {
      this.restoreValues(this.node.shader.props, this.propValuesMap["shaderProps"]);
    }
    if (this.dynPropValuesMap !== void 0) {
      const dynEntries = Object.keys(this.dynPropValuesMap);
      const dynEntriesL = dynEntries.length;
      if (dynEntriesL > 0) {
        for (let i = 0; i < dynEntriesL; i++) {
          const key = dynEntries[i];
          this.restoreValues(this.node.shader.props[key], this.dynPropValuesMap[key]);
        }
      }
    }
  }
  reverseValues(valueMap) {
    const entries = Object.entries(valueMap);
    const eLength = entries.length;
    for (let i = 0; i < eLength; i++) {
      const [key, value] = entries[i];
      valueMap[key] = {
        start: value.target,
        target: value.start
      };
    }
  }
  reverse() {
    this.progress = 0;
    if (this.propValuesMap["props"] !== void 0) {
      this.reverseValues(this.propValuesMap["props"]);
    }
    if (this.propValuesMap["shaderProps"] !== void 0) {
      this.reverseValues(this.propValuesMap["shaderProps"]);
    }
    if (this.dynPropValuesMap !== void 0) {
      const dynEntries = Object.keys(this.dynPropValuesMap);
      const dynEntriesL = dynEntries.length;
      if (dynEntriesL > 0) {
        for (let i = 0; i < dynEntriesL; i++) {
          const key = dynEntries[i];
          this.reverseValues(this.dynPropValuesMap[key]);
        }
      }
    }
    if (!this.settings.loop) {
      this.settings.stopMethod = false;
    }
  }
  applyEasing(p, s, e) {
    return (this.timingFunction(p) || p) * (e - s) + s;
  }
  updateValue(propName, propValue, startValue, easing) {
    if (this.progress === 1) {
      return propValue;
    }
    if (this.progress === 0) {
      return startValue;
    }
    const endValue = propValue;
    if (propName.indexOf("color") !== -1) {
      if (startValue === endValue) {
        return startValue;
      }
      if (easing) {
        const easingProgressValue = this.timingFunction(this.progress) || this.progress;
        return mergeColorProgress(startValue, endValue, easingProgressValue);
      }
      return mergeColorProgress(startValue, endValue, this.progress);
    }
    if (easing) {
      return this.applyEasing(this.progress, startValue, endValue);
    }
    return startValue + (endValue - startValue) * this.progress;
  }
  updateValues(target, valueMap, easing) {
    const entries = Object.entries(valueMap);
    const eLength = entries.length;
    for (let i = 0; i < eLength; i++) {
      const [key, value] = entries[i];
      target[key] = this.updateValue(key, value.target, value.start, easing);
    }
  }
  update(dt) {
    const { duration, loop, easing, stopMethod } = this.settings;
    const { delayFor } = this;
    if (duration === 0 && delayFor === 0) {
      this.emit("finished", {});
      return;
    }
    if (this.delayFor > 0) {
      this.delayFor -= dt;
      if (this.delayFor >= 0) {
        return;
      } else {
        dt = -this.delayFor;
        this.delayFor = 0;
      }
    }
    if (duration === 0) {
      this.emit("finished", {});
      return;
    }
    if (this.progress === 0) {
      this.emit("animating", {});
    }
    this.progress += dt / duration;
    if (this.progress > 1) {
      this.progress = loop ? 0 : 1;
      this.delayFor = this.delay;
      if (stopMethod) {
        this.emit("finished", {});
        return;
      }
    }
    if (this.propValuesMap["props"] !== void 0) {
      this.updateValues(this.node, this.propValuesMap["props"], easing);
    }
    if (this.propValuesMap["shaderProps"] !== void 0) {
      this.updateValues(this.node.shader.props, this.propValuesMap["shaderProps"], easing);
    }
    if (this.dynPropValuesMap !== void 0) {
      const dynEntries = Object.keys(this.dynPropValuesMap);
      const dynEntriesL = dynEntries.length;
      if (dynEntriesL > 0) {
        for (let i = 0; i < dynEntriesL; i++) {
          const key = dynEntries[i];
          this.updateValues(this.node.shader.props[key], this.dynPropValuesMap[key], easing);
        }
      }
    }
    if (this.progress < 1) {
      this.emit("tick", { progress: this.progress });
    }
    if (this.progress === 1) {
      this.emit("finished", {});
    }
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/animations/CoreAnimationController.js
var CoreAnimationController = class extends EventEmitter {
  constructor(manager, animation) {
    super();
    __publicField(this, "manager");
    __publicField(this, "animation");
    __publicField(this, "stoppedPromise");
    /**
     * If this is null, then the animation is in a finished / stopped state.
     */
    __publicField(this, "stoppedResolve", null);
    __publicField(this, "state");
    this.manager = manager;
    this.animation = animation;
    this.state = "stopped";
    this.stoppedPromise = Promise.resolve();
    this.onAnimating = this.onAnimating.bind(this);
    this.onFinished = this.onFinished.bind(this);
    this.onTick = this.onTick.bind(this);
  }
  start() {
    if (this.state !== "running" && this.state !== "scheduled") {
      this.makeStoppedPromise();
      this.registerAnimation();
      this.state = "scheduled";
    }
    return this;
  }
  stop() {
    this.unregisterAnimation();
    if (this.stoppedResolve !== null) {
      this.stoppedResolve();
      this.stoppedResolve = null;
      this.emit("stopped", this);
    }
    this.animation.reset();
    this.state = "stopped";
    return this;
  }
  pause() {
    this.unregisterAnimation();
    this.state = "paused";
    return this;
  }
  restore() {
    this.stoppedResolve = null;
    this.animation.restore();
    return this;
  }
  waitUntilStopped() {
    return this.stoppedPromise;
  }
  registerAnimation() {
    this.animation.once("finished", this.onFinished);
    this.animation.on("animating", this.onAnimating);
    this.animation.on("tick", this.onTick);
    this.manager.registerAnimation(this.animation);
  }
  unregisterAnimation() {
    this.manager.unregisterAnimation(this.animation);
    this.animation.off("finished", this.onFinished);
    this.animation.off("animating", this.onAnimating);
    this.animation.off("tick", this.onTick);
  }
  makeStoppedPromise() {
    if (this.stoppedResolve === null) {
      this.stoppedPromise = new Promise((resolve) => {
        this.stoppedResolve = resolve;
      });
    }
  }
  onFinished() {
    assertTruthy(this.stoppedResolve);
    const { loop, stopMethod } = this.animation.settings;
    if (stopMethod === "reverse") {
      this.animation.once("finished", this.onFinished);
      this.animation.reverse();
      return;
    }
    if (loop) {
      return;
    }
    this.unregisterAnimation();
    this.stoppedResolve();
    this.stoppedResolve = null;
    this.emit("stopped", this);
    this.state = "stopped";
  }
  onAnimating() {
    this.state = "running";
    this.emit("animating", this);
  }
  onTick(_animation, data) {
    this.emit("tick", data);
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/CoreNode.js
var CoreNodeRenderState;
(function(CoreNodeRenderState2) {
  CoreNodeRenderState2[CoreNodeRenderState2["Init"] = 0] = "Init";
  CoreNodeRenderState2[CoreNodeRenderState2["OutOfBounds"] = 2] = "OutOfBounds";
  CoreNodeRenderState2[CoreNodeRenderState2["InBounds"] = 4] = "InBounds";
  CoreNodeRenderState2[CoreNodeRenderState2["InViewport"] = 8] = "InViewport";
})(CoreNodeRenderState || (CoreNodeRenderState = {}));
var CoreNodeRenderStateMap = /* @__PURE__ */ new Map();
CoreNodeRenderStateMap.set(CoreNodeRenderState.Init, "init");
CoreNodeRenderStateMap.set(CoreNodeRenderState.OutOfBounds, "outOfBounds");
CoreNodeRenderStateMap.set(CoreNodeRenderState.InBounds, "inBounds");
CoreNodeRenderStateMap.set(CoreNodeRenderState.InViewport, "inViewport");
var UpdateType;
(function(UpdateType2) {
  UpdateType2[UpdateType2["Children"] = 1] = "Children";
  UpdateType2[UpdateType2["ScaleRotate"] = 2] = "ScaleRotate";
  UpdateType2[UpdateType2["Local"] = 4] = "Local";
  UpdateType2[UpdateType2["Global"] = 8] = "Global";
  UpdateType2[UpdateType2["Clipping"] = 16] = "Clipping";
  UpdateType2[UpdateType2["CalculatedZIndex"] = 32] = "CalculatedZIndex";
  UpdateType2[UpdateType2["ZIndexSortedChildren"] = 64] = "ZIndexSortedChildren";
  UpdateType2[UpdateType2["PremultipliedColors"] = 128] = "PremultipliedColors";
  UpdateType2[UpdateType2["WorldAlpha"] = 256] = "WorldAlpha";
  UpdateType2[UpdateType2["RenderState"] = 512] = "RenderState";
  UpdateType2[UpdateType2["IsRenderable"] = 1024] = "IsRenderable";
  UpdateType2[UpdateType2["RenderTexture"] = 2048] = "RenderTexture";
  UpdateType2[UpdateType2["ParentRenderTexture"] = 4096] = "ParentRenderTexture";
  UpdateType2[UpdateType2["RenderBounds"] = 8192] = "RenderBounds";
  UpdateType2[UpdateType2["None"] = 0] = "None";
  UpdateType2[UpdateType2["All"] = 14335] = "All";
})(UpdateType || (UpdateType = {}));
var CoreNode = class extends EventEmitter {
  constructor(stage2, props) {
    super();
    __publicField(this, "stage");
    __publicField(this, "children", []);
    __publicField(this, "_id", getNewId());
    __publicField(this, "props");
    __publicField(this, "updateType", UpdateType.All);
    __publicField(this, "childUpdateType", UpdateType.None);
    __publicField(this, "globalTransform");
    __publicField(this, "scaleRotateTransform");
    __publicField(this, "localTransform");
    __publicField(this, "renderCoords");
    __publicField(this, "renderBound");
    __publicField(this, "strictBound");
    __publicField(this, "preloadBound");
    __publicField(this, "clippingRect", {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      valid: false
    });
    __publicField(this, "isRenderable", false);
    __publicField(this, "renderState", CoreNodeRenderState.Init);
    __publicField(this, "worldAlpha", 1);
    __publicField(this, "premultipliedColorTl", 0);
    __publicField(this, "premultipliedColorTr", 0);
    __publicField(this, "premultipliedColorBl", 0);
    __publicField(this, "premultipliedColorBr", 0);
    __publicField(this, "calcZIndex", 0);
    __publicField(this, "hasRTTupdates", false);
    __publicField(this, "parentHasRenderTexture", false);
    __publicField(this, "onTextureLoaded", (_, dimensions) => {
      var _a2, _b;
      this.autosizeNode(dimensions);
      this.stage.requestRender();
      if (this.parentHasRenderTexture) {
        this.notifyParentRTTOfUpdate();
      }
      this.emit("loaded", {
        type: "texture",
        dimensions
      });
      if (((_b = (_a2 = this.props.textureOptions) == null ? void 0 : _a2.resizeMode) == null ? void 0 : _b.type) === "contain") {
        this.setUpdateType(UpdateType.Local);
      }
    });
    __publicField(this, "onTextureFailed", (_, error) => {
      if (this.parentHasRenderTexture) {
        this.notifyParentRTTOfUpdate();
      }
      this.emit("failed", {
        type: "texture",
        error
      });
    });
    __publicField(this, "onTextureFreed", () => {
      if (this.parentHasRenderTexture) {
        this.notifyParentRTTOfUpdate();
      }
      this.emit("freed", {
        type: "texture"
      });
    });
    this.stage = stage2;
    this.props = {
      ...props,
      parent: null,
      texture: null,
      src: null,
      rtt: false
    };
    this.parent = props.parent;
    this.texture = props.texture;
    this.src = props.src;
    this.rtt = props.rtt;
    this.setUpdateType(UpdateType.ScaleRotate | UpdateType.Local | UpdateType.RenderBounds | UpdateType.RenderState);
  }
  //#region Textures
  loadTexture() {
    const { texture } = this.props;
    assertTruthy(texture);
    queueMicrotask(() => {
      texture.preventCleanup = this.props.preventCleanup;
      if (this.textureOptions.preload) {
        texture.ctxTexture.load();
      }
      texture.on("loaded", this.onTextureLoaded);
      texture.on("failed", this.onTextureFailed);
      texture.on("freed", this.onTextureFreed);
      if (this.parentHasRenderTexture) {
        this.notifyParentRTTOfUpdate();
        return;
      }
      if (texture.state === "loaded") {
        assertTruthy(texture.dimensions);
        this.onTextureLoaded(texture, texture.dimensions);
      } else if (texture.state === "failed") {
        assertTruthy(texture.error);
        this.onTextureFailed(texture, texture.error);
      } else if (texture.state === "freed") {
        this.onTextureFreed(texture);
      }
    });
  }
  unloadTexture() {
    if (this.texture !== null) {
      this.texture.off("loaded", this.onTextureLoaded);
      this.texture.off("failed", this.onTextureFailed);
      this.texture.off("freed", this.onTextureFreed);
      this.texture.setRenderableOwner(this, false);
    }
  }
  autosizeNode(dimensions) {
    if (this.autosize) {
      this.width = dimensions.width;
      this.height = dimensions.height;
    }
  }
  //#endregion Textures
  /**
   * Change types types is used to determine the scope of the changes being applied
   *
   * @remarks
   * See {@link UpdateType} for more information on each type
   *
   * @param type
   */
  setUpdateType(type) {
    this.updateType |= type;
    const parent = this.props.parent;
    if (!parent)
      return;
    if ((parent.updateType & UpdateType.Children) === 0) {
      parent.setUpdateType(UpdateType.Children);
    }
  }
  sortChildren() {
    this.children.sort((a, b) => a.calcZIndex - b.calcZIndex);
  }
  updateScaleRotateTransform() {
    const { rotation, scaleX, scaleY } = this.props;
    if (rotation === 0 && scaleX === 1 && scaleY === 1) {
      this.scaleRotateTransform = void 0;
      return;
    }
    this.scaleRotateTransform = Matrix3d.rotate(rotation, this.scaleRotateTransform).scale(scaleX, scaleY);
  }
  updateLocalTransform() {
    var _a2, _b;
    const { x, y, width, height } = this.props;
    const mountTranslateX = this.props.mountX * width;
    const mountTranslateY = this.props.mountY * height;
    if (this.scaleRotateTransform) {
      const pivotTranslateX = this.props.pivotX * width;
      const pivotTranslateY = this.props.pivotY * height;
      this.localTransform = Matrix3d.translate(x - mountTranslateX + pivotTranslateX, y - mountTranslateY + pivotTranslateY, this.localTransform).multiply(this.scaleRotateTransform).translate(-pivotTranslateX, -pivotTranslateY);
    } else {
      this.localTransform = Matrix3d.translate(x - mountTranslateX, y - mountTranslateY, this.localTransform);
    }
    const texture = this.props.texture;
    if (texture && texture.dimensions && ((_b = (_a2 = this.props.textureOptions) == null ? void 0 : _a2.resizeMode) == null ? void 0 : _b.type) === "contain") {
      let resizeModeScaleX = 1;
      let resizeModeScaleY = 1;
      let extraX = 0;
      let extraY = 0;
      const { width: tw, height: th } = texture.dimensions;
      const txAspectRatio = tw / th;
      const nodeAspectRatio = width / height;
      if (txAspectRatio > nodeAspectRatio) {
        const scaleX = width / tw;
        const scaledTxHeight = th * scaleX;
        extraY = (height - scaledTxHeight) / 2;
        resizeModeScaleY = scaledTxHeight / height;
      } else {
        const scaleY = height / th;
        const scaledTxWidth = tw * scaleY;
        extraX = (width - scaledTxWidth) / 2;
        resizeModeScaleX = scaledTxWidth / width;
      }
      this.localTransform.translate(extraX, extraY).scale(resizeModeScaleX, resizeModeScaleY);
    }
    this.setUpdateType(UpdateType.Global);
  }
  /**
   * @todo: test for correct calculation flag
   * @param delta
   */
  update(delta, parentClippingRect) {
    var _a2, _b;
    if (this.updateType & UpdateType.ScaleRotate) {
      this.updateScaleRotateTransform();
      this.setUpdateType(UpdateType.Local);
    }
    if (this.updateType & UpdateType.Local) {
      this.updateLocalTransform();
      this.setUpdateType(UpdateType.Global);
    }
    const parent = this.props.parent;
    let renderState = null;
    if (this.updateType & UpdateType.RenderTexture && this.rtt) {
      this.hasRTTupdates = true;
      (_a2 = this.stage.renderer) == null ? void 0 : _a2.renderToTexture(this);
    }
    if (this.updateType & UpdateType.Global) {
      assertTruthy(this.localTransform);
      this.globalTransform = Matrix3d.copy((parent == null ? void 0 : parent.globalTransform) || this.localTransform, this.globalTransform);
      if (this.parentHasRenderTexture && ((_b = this.props.parent) == null ? void 0 : _b.rtt)) {
        this.globalTransform = Matrix3d.identity();
      }
      if (parent) {
        this.globalTransform.multiply(this.localTransform);
      }
      this.calculateRenderCoords();
      this.updateBoundingRect();
      this.setUpdateType(UpdateType.RenderState | UpdateType.Children);
      this.childUpdateType |= UpdateType.Global;
      if (this.clipping === true) {
        this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds);
        this.childUpdateType |= UpdateType.RenderBounds;
      }
    }
    if (this.updateType & UpdateType.RenderBounds) {
      this.createRenderBounds();
      this.setUpdateType(UpdateType.RenderState);
      this.setUpdateType(UpdateType.Children);
    }
    if (this.updateType & UpdateType.RenderState) {
      renderState = this.checkRenderBounds();
      this.setUpdateType(UpdateType.IsRenderable);
      if (renderState !== CoreNodeRenderState.OutOfBounds) {
        this.updateRenderState(renderState);
      }
    }
    if (this.updateType & UpdateType.WorldAlpha) {
      if (parent) {
        this.worldAlpha = parent.worldAlpha * this.props.alpha;
      } else {
        this.worldAlpha = this.props.alpha;
      }
      this.setUpdateType(UpdateType.Children | UpdateType.PremultipliedColors | UpdateType.IsRenderable);
      this.childUpdateType |= UpdateType.WorldAlpha;
    }
    if (this.updateType & UpdateType.IsRenderable) {
      this.updateIsRenderable();
    }
    if (this.updateType & UpdateType.Clipping) {
      this.calculateClippingRect(parentClippingRect);
      this.setUpdateType(UpdateType.Children);
      this.childUpdateType |= UpdateType.Clipping;
      this.childUpdateType |= UpdateType.RenderBounds;
    }
    if (this.updateType & UpdateType.PremultipliedColors) {
      this.premultipliedColorTl = mergeColorAlphaPremultiplied(this.props.colorTl, this.worldAlpha, true);
      if (this.props.colorTl === this.props.colorTr && this.props.colorBl === this.props.colorBr && this.props.colorTl === this.props.colorBl) {
        this.premultipliedColorTr = this.premultipliedColorBl = this.premultipliedColorBr = this.premultipliedColorTl;
      } else {
        this.premultipliedColorTr = mergeColorAlphaPremultiplied(this.props.colorTr, this.worldAlpha, true);
        this.premultipliedColorBl = mergeColorAlphaPremultiplied(this.props.colorBl, this.worldAlpha, true);
        this.premultipliedColorBr = mergeColorAlphaPremultiplied(this.props.colorBr, this.worldAlpha, true);
      }
    }
    if (parent !== null && this.updateType & UpdateType.CalculatedZIndex) {
      this.calculateZIndex();
      parent.setUpdateType(UpdateType.ZIndexSortedChildren);
    }
    if (this.props.strictBounds === true && this.renderState === CoreNodeRenderState.OutOfBounds) {
      return;
    }
    if (this.updateType & UpdateType.Children && this.children.length > 0) {
      for (let i = 0, length = this.children.length; i < length; i++) {
        const child = this.children[i];
        child.setUpdateType(this.childUpdateType);
        if (child.updateType === 0) {
          continue;
        }
        child.update(delta, this.clippingRect);
      }
    }
    if (this.parentHasRenderTexture && this.updateType > 0) {
      this.notifyParentRTTOfUpdate();
    }
    if (this.updateType & UpdateType.ZIndexSortedChildren) {
      this.sortChildren();
    }
    if (renderState === CoreNodeRenderState.OutOfBounds) {
      this.updateRenderState(renderState);
      this.updateIsRenderable();
    }
    this.updateType = 0;
    this.childUpdateType = 0;
  }
  notifyParentRTTOfUpdate() {
    if (this.parent === null) {
      return;
    }
    let rttNode = this.parent;
    while (rttNode && !rttNode.rtt) {
      rttNode = rttNode.parent;
    }
    if (!rttNode) {
      return;
    }
    rttNode.hasRTTupdates = true;
    rttNode.setUpdateType(UpdateType.RenderTexture);
    if (rttNode.parentHasRenderTexture === true) {
      rttNode.notifyParentRTTOfUpdate();
    }
  }
  //check if CoreNode is renderable based on props
  hasRenderableProperties() {
    if (this.props.texture) {
      return true;
    }
    if (!this.props.width || !this.props.height) {
      return false;
    }
    if (this.props.shader !== this.stage.defShaderCtr) {
      return true;
    }
    if (this.props.clipping) {
      return true;
    }
    if (this.props.color !== 0) {
      return true;
    }
    if (this.props.colorTop !== 0) {
      return true;
    }
    if (this.props.colorBottom !== 0) {
      return true;
    }
    if (this.props.colorLeft !== 0) {
      return true;
    }
    if (this.props.colorRight !== 0) {
      return true;
    }
    if (this.props.colorTl !== 0) {
      return true;
    }
    if (this.props.colorTr !== 0) {
      return true;
    }
    if (this.props.colorBl !== 0) {
      return true;
    }
    if (this.props.colorBr !== 0) {
      return true;
    }
    return false;
  }
  checkRenderBounds() {
    assertTruthy(this.renderBound);
    assertTruthy(this.strictBound);
    assertTruthy(this.preloadBound);
    if (boundInsideBound(this.renderBound, this.strictBound)) {
      return CoreNodeRenderState.InViewport;
    }
    if (boundInsideBound(this.renderBound, this.preloadBound)) {
      return CoreNodeRenderState.InBounds;
    }
    if (boundLargeThanBound(this.renderBound, this.strictBound)) {
      return CoreNodeRenderState.InViewport;
    }
    if (this.parent !== null && (this.props.width === 0 || this.props.height === 0)) {
      return this.parent.renderState;
    }
    return CoreNodeRenderState.OutOfBounds;
  }
  updateBoundingRect() {
    const { renderCoords, globalTransform: transform } = this;
    assertTruthy(transform);
    assertTruthy(renderCoords);
    const { tb, tc } = transform;
    const { x1, y1, x3, y3 } = renderCoords;
    if (tb === 0 || tc === 0) {
      this.renderBound = createBound(x1, y1, x3, y3, this.renderBound);
    } else {
      const { x2, x4, y2, y4 } = renderCoords;
      this.renderBound = createBound(Math.min(x1, x2, x3, x4), Math.min(y1, y2, y3, y4), Math.max(x1, x2, x3, x4), Math.max(y1, y2, y3, y4), this.renderBound);
    }
  }
  createRenderBounds() {
    assertTruthy(this.stage);
    if (this.parent !== null && this.parent.strictBound !== void 0) {
      const parentBound = this.parent.strictBound;
      this.strictBound = createBound(parentBound.x1, parentBound.y1, parentBound.x2, parentBound.y2);
      this.preloadBound = createPreloadBounds(this.strictBound, this.stage.boundsMargin);
    } else {
      this.strictBound = this.stage.strictBound;
      this.preloadBound = this.stage.preloadBound;
    }
    if (this.props.clipping === false) {
      return;
    }
    if (this.renderBound === void 0) {
      return;
    }
    if (boundInsideBound(this.renderBound, this.strictBound) === false) {
      return;
    }
    const { x, y, width, height } = this.props;
    const { tx, ty } = this.globalTransform || {};
    const _x = tx ?? x;
    const _y = ty ?? y;
    this.strictBound = createBound(_x, _y, _x + width, _y + height, this.strictBound);
    this.preloadBound = createPreloadBounds(this.strictBound, this.stage.boundsMargin);
  }
  updateRenderState(renderState) {
    if (renderState === this.renderState) {
      return;
    }
    const previous = this.renderState;
    this.renderState = renderState;
    const event = CoreNodeRenderStateMap.get(renderState);
    assertTruthy(event);
    this.emit(event, {
      previous,
      current: renderState
    });
  }
  /**
   * This function updates the `isRenderable` property based on certain conditions.
   *
   * @returns
   */
  updateIsRenderable() {
    let newIsRenderable;
    if (this.worldAlpha === 0 || !this.hasRenderableProperties()) {
      newIsRenderable = false;
    } else {
      newIsRenderable = this.renderState > CoreNodeRenderState.OutOfBounds;
    }
    if (this.isRenderable !== newIsRenderable) {
      this.isRenderable = newIsRenderable;
      this.onChangeIsRenderable(newIsRenderable);
    }
  }
  onChangeIsRenderable(isRenderable) {
    var _a2;
    (_a2 = this.texture) == null ? void 0 : _a2.setRenderableOwner(this, isRenderable);
  }
  calculateRenderCoords() {
    const { width, height, globalTransform: transform } = this;
    assertTruthy(transform);
    const { tx, ty, ta, tb, tc, td } = transform;
    if (tb === 0 && tc === 0) {
      const minX = tx;
      const maxX = tx + width * ta;
      const minY = ty;
      const maxY = ty + height * td;
      this.renderCoords = RenderCoords.translate(
        //top-left
        minX,
        minY,
        //top-right
        maxX,
        minY,
        //bottom-right
        maxX,
        maxY,
        //bottom-left
        minX,
        maxY,
        this.renderCoords
      );
    } else {
      this.renderCoords = RenderCoords.translate(
        //top-left
        tx,
        ty,
        //top-right
        tx + width * ta,
        ty + width * tc,
        //bottom-right
        tx + width * ta + height * tb,
        ty + width * tc + height * td,
        //bottom-left
        tx + height * tb,
        ty + height * td,
        this.renderCoords
      );
    }
  }
  /**
   * This function calculates the clipping rectangle for a node.
   *
   * The function then checks if the node is rotated. If the node requires clipping and is not rotated, a new clipping rectangle is created based on the node's global transform and dimensions.
   * If a parent clipping rectangle exists, it is intersected with the node's clipping rectangle (if it exists), or replaces the node's clipping rectangle.
   *
   * Finally, the node's parentClippingRect and clippingRect properties are updated.
   */
  calculateClippingRect(parentClippingRect) {
    assertTruthy(this.globalTransform);
    const { clippingRect, props, globalTransform: gt } = this;
    const { clipping } = props;
    const isRotated = gt.tb !== 0 || gt.tc !== 0;
    if (clipping === true && isRotated === false) {
      clippingRect.x = gt.tx;
      clippingRect.y = gt.ty;
      clippingRect.width = this.width * gt.ta;
      clippingRect.height = this.height * gt.td;
      clippingRect.valid = true;
    } else {
      clippingRect.valid = false;
    }
    if (parentClippingRect.valid === true && clippingRect.valid === true) {
      intersectRect(parentClippingRect, clippingRect, clippingRect);
    } else if (parentClippingRect.valid === true) {
      copyRect(parentClippingRect, clippingRect);
      clippingRect.valid = true;
    }
  }
  calculateZIndex() {
    var _a2, _b;
    const props = this.props;
    const z = props.zIndex || 0;
    const p = ((_a2 = props.parent) == null ? void 0 : _a2.zIndex) || 0;
    let zIndex = z;
    if ((_b = props.parent) == null ? void 0 : _b.zIndexLocked) {
      zIndex = z < p ? z : p;
    }
    this.calcZIndex = zIndex;
  }
  /**
   * Destroy the node and cleanup all resources
   */
  destroy() {
    var _a2;
    this.unloadTexture();
    this.clippingRect.valid = false;
    this.isRenderable = false;
    this.renderCoords = void 0;
    this.renderBound = void 0;
    this.strictBound = void 0;
    this.preloadBound = void 0;
    this.globalTransform = void 0;
    this.scaleRotateTransform = void 0;
    this.localTransform = void 0;
    this.props.texture = null;
    this.props.shader = this.stage.defShaderCtr;
    while (this.children.length > 0) {
      (_a2 = this.children[0]) == null ? void 0 : _a2.destroy();
    }
    this.parent = null;
    if (this.rtt) {
      this.stage.renderer.removeRTTNode(this);
    }
    this.removeAllListeners();
  }
  renderQuads(renderer3) {
    if (this.parentHasRenderTexture) {
      if (!renderer3.renderToTextureActive) {
        return;
      }
      if (this.parentRenderTexture !== renderer3.activeRttNode) {
        return;
      }
    }
    assertTruthy(this.globalTransform);
    assertTruthy(this.renderCoords);
    renderer3.addQuad({
      width: this.props.width,
      height: this.props.height,
      colorTl: this.premultipliedColorTl,
      colorTr: this.premultipliedColorTr,
      colorBl: this.premultipliedColorBl,
      colorBr: this.premultipliedColorBr,
      texture: this.texture,
      textureOptions: this.textureOptions,
      zIndex: this.zIndex,
      shader: this.shader.shader,
      shaderProps: this.shader.getResolvedProps(),
      alpha: this.worldAlpha,
      clippingRect: this.clippingRect,
      tx: this.globalTransform.tx,
      ty: this.globalTransform.ty,
      ta: this.globalTransform.ta,
      tb: this.globalTransform.tb,
      tc: this.globalTransform.tc,
      td: this.globalTransform.td,
      renderCoords: this.renderCoords,
      rtt: this.rtt,
      parentHasRenderTexture: this.parentHasRenderTexture,
      framebufferDimensions: this.framebufferDimensions
    });
  }
  //#region Properties
  get id() {
    return this._id;
  }
  get data() {
    return this.props.data;
  }
  set data(d) {
    this.props.data = d;
  }
  get x() {
    return this.props.x;
  }
  set x(value) {
    if (this.props.x !== value) {
      this.props.x = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get absX() {
    var _a2, _b, _c;
    return this.props.x + -this.props.width * this.props.mountX + (((_a2 = this.props.parent) == null ? void 0 : _a2.absX) || ((_c = (_b = this.props.parent) == null ? void 0 : _b.globalTransform) == null ? void 0 : _c.tx) || 0);
  }
  get absY() {
    var _a2;
    return this.props.y + -this.props.height * this.props.mountY + (((_a2 = this.props.parent) == null ? void 0 : _a2.absY) ?? 0);
  }
  get y() {
    return this.props.y;
  }
  set y(value) {
    if (this.props.y !== value) {
      this.props.y = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get width() {
    return this.props.width;
  }
  set width(value) {
    if (this.props.width !== value) {
      this.props.width = value;
      this.setUpdateType(UpdateType.Local);
      if (this.props.rtt) {
        this.texture = this.stage.txManager.loadTexture("RenderTexture", {
          width: this.width,
          height: this.height
        });
        this.textureOptions.preload = true;
        this.setUpdateType(UpdateType.RenderTexture);
      }
    }
  }
  get height() {
    return this.props.height;
  }
  set height(value) {
    if (this.props.height !== value) {
      this.props.height = value;
      this.setUpdateType(UpdateType.Local);
      if (this.props.rtt) {
        this.texture = this.stage.txManager.loadTexture("RenderTexture", {
          width: this.width,
          height: this.height
        });
        this.textureOptions.preload = true;
        this.setUpdateType(UpdateType.RenderTexture);
      }
    }
  }
  get scale() {
    return this.scaleX;
  }
  set scale(value) {
    this.scaleX = value;
    this.scaleY = value;
  }
  get scaleX() {
    return this.props.scaleX;
  }
  set scaleX(value) {
    if (this.props.scaleX !== value) {
      this.props.scaleX = value;
      this.setUpdateType(UpdateType.ScaleRotate);
    }
  }
  get scaleY() {
    return this.props.scaleY;
  }
  set scaleY(value) {
    if (this.props.scaleY !== value) {
      this.props.scaleY = value;
      this.setUpdateType(UpdateType.ScaleRotate);
    }
  }
  get mount() {
    return this.props.mount;
  }
  set mount(value) {
    if (this.props.mountX !== value || this.props.mountY !== value) {
      this.props.mountX = value;
      this.props.mountY = value;
      this.props.mount = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get mountX() {
    return this.props.mountX;
  }
  set mountX(value) {
    if (this.props.mountX !== value) {
      this.props.mountX = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get mountY() {
    return this.props.mountY;
  }
  set mountY(value) {
    if (this.props.mountY !== value) {
      this.props.mountY = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get pivot() {
    return this.props.pivot;
  }
  set pivot(value) {
    if (this.props.pivotX !== value || this.props.pivotY !== value) {
      this.props.pivotX = value;
      this.props.pivotY = value;
      this.props.pivot = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get pivotX() {
    return this.props.pivotX;
  }
  set pivotX(value) {
    if (this.props.pivotX !== value) {
      this.props.pivotX = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get pivotY() {
    return this.props.pivotY;
  }
  set pivotY(value) {
    if (this.props.pivotY !== value) {
      this.props.pivotY = value;
      this.setUpdateType(UpdateType.Local);
    }
  }
  get rotation() {
    return this.props.rotation;
  }
  set rotation(value) {
    if (this.props.rotation !== value) {
      this.props.rotation = value;
      this.setUpdateType(UpdateType.ScaleRotate);
    }
  }
  get alpha() {
    return this.props.alpha;
  }
  set alpha(value) {
    this.props.alpha = value;
    this.setUpdateType(UpdateType.PremultipliedColors | UpdateType.WorldAlpha | UpdateType.Children | UpdateType.IsRenderable);
    this.childUpdateType |= UpdateType.WorldAlpha;
  }
  get autosize() {
    return this.props.autosize;
  }
  set autosize(value) {
    this.props.autosize = value;
  }
  get clipping() {
    return this.props.clipping;
  }
  set clipping(value) {
    this.props.clipping = value;
    this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds | UpdateType.Children);
    this.childUpdateType |= UpdateType.Global | UpdateType.Clipping;
  }
  get color() {
    return this.props.color;
  }
  set color(value) {
    this.colorTop = value;
    this.colorBottom = value;
    this.colorLeft = value;
    this.colorRight = value;
    this.props.color = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorTop() {
    return this.props.colorTop;
  }
  set colorTop(value) {
    if (this.props.colorTl !== value || this.props.colorTr !== value) {
      this.colorTl = value;
      this.colorTr = value;
    }
    this.props.colorTop = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorBottom() {
    return this.props.colorBottom;
  }
  set colorBottom(value) {
    if (this.props.colorBl !== value || this.props.colorBr !== value) {
      this.colorBl = value;
      this.colorBr = value;
    }
    this.props.colorBottom = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorLeft() {
    return this.props.colorLeft;
  }
  set colorLeft(value) {
    if (this.props.colorTl !== value || this.props.colorBl !== value) {
      this.colorTl = value;
      this.colorBl = value;
    }
    this.props.colorLeft = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorRight() {
    return this.props.colorRight;
  }
  set colorRight(value) {
    if (this.props.colorTr !== value || this.props.colorBr !== value) {
      this.colorTr = value;
      this.colorBr = value;
    }
    this.props.colorRight = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorTl() {
    return this.props.colorTl;
  }
  set colorTl(value) {
    this.props.colorTl = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorTr() {
    return this.props.colorTr;
  }
  set colorTr(value) {
    this.props.colorTr = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorBl() {
    return this.props.colorBl;
  }
  set colorBl(value) {
    this.props.colorBl = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  get colorBr() {
    return this.props.colorBr;
  }
  set colorBr(value) {
    this.props.colorBr = value;
    this.setUpdateType(UpdateType.PremultipliedColors);
  }
  // we're only interested in parent zIndex to test
  // if we should use node zIndex is higher then parent zIndex
  get zIndexLocked() {
    return this.props.zIndexLocked || 0;
  }
  set zIndexLocked(value) {
    this.props.zIndexLocked = value;
    this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
    for (let i = 0, length = this.children.length; i < length; i++) {
      this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
    }
  }
  get zIndex() {
    return this.props.zIndex;
  }
  set zIndex(value) {
    this.props.zIndex = value;
    this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
    for (let i = 0, length = this.children.length; i < length; i++) {
      this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
    }
  }
  get parent() {
    return this.props.parent;
  }
  set parent(newParent) {
    const oldParent = this.props.parent;
    if (oldParent === newParent) {
      return;
    }
    this.props.parent = newParent;
    if (oldParent) {
      const index = oldParent.children.indexOf(this);
      assertTruthy(index !== -1, "CoreNode.parent: Node not found in old parent's children!");
      oldParent.children.splice(index, 1);
      oldParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
    }
    if (newParent) {
      newParent.children.push(this);
      this.setUpdateType(UpdateType.All);
      newParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
      if (newParent.rtt || newParent.parentHasRenderTexture) {
        this.applyRTTInheritance(newParent);
      }
    }
    this.updateScaleRotateTransform();
    this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
  }
  get preventCleanup() {
    return this.props.preventCleanup;
  }
  set preventCleanup(value) {
    this.props.preventCleanup = value;
  }
  get rtt() {
    return this.props.rtt;
  }
  set rtt(value) {
    if (this.props.rtt === value) {
      return;
    }
    this.props.rtt = value;
    if (value) {
      this.initRenderTexture();
      this.markChildrenWithRTT();
    } else {
      this.cleanupRenderTexture();
    }
    this.setUpdateType(UpdateType.RenderTexture);
    if (this.parentHasRenderTexture) {
      this.notifyParentRTTOfUpdate();
    }
  }
  initRenderTexture() {
    var _a2;
    this.texture = this.stage.txManager.loadTexture("RenderTexture", {
      width: this.width,
      height: this.height
    });
    this.textureOptions.preload = true;
    (_a2 = this.stage.renderer) == null ? void 0 : _a2.renderToTexture(this);
  }
  cleanupRenderTexture() {
    var _a2;
    this.unloadTexture();
    this.clearRTTInheritance();
    (_a2 = this.stage.renderer) == null ? void 0 : _a2.removeRTTNode(this);
    this.hasRTTupdates = false;
    this.texture = null;
  }
  markChildrenWithRTT(node = null) {
    const parent = node || this;
    for (const child of parent.children) {
      child.setUpdateType(UpdateType.All);
      child.parentHasRenderTexture = true;
      child.markChildrenWithRTT();
    }
  }
  // Apply RTT inheritance when a node has an RTT-enabled parent
  applyRTTInheritance(parent) {
    if (parent.rtt) {
      parent.setUpdateType(UpdateType.RenderTexture);
    }
    this.markChildrenWithRTT(parent);
  }
  // Clear RTT inheritance when detaching from an RTT chain
  clearRTTInheritance() {
    if (this.rtt) {
      return;
    }
    for (const child of this.children) {
      child.parentHasRenderTexture = false;
      child.setUpdateType(UpdateType.All);
      child.clearRTTInheritance();
    }
  }
  get shader() {
    return this.props.shader;
  }
  set shader(value) {
    if (this.props.shader === value) {
      return;
    }
    this.props.shader = value;
    this.setUpdateType(UpdateType.IsRenderable);
  }
  get src() {
    return this.props.src;
  }
  set src(imageUrl) {
    if (this.props.src === imageUrl) {
      return;
    }
    this.props.src = imageUrl;
    if (!imageUrl) {
      this.texture = null;
      return;
    }
    this.texture = this.stage.txManager.loadTexture("ImageTexture", {
      src: imageUrl,
      width: this.props.width,
      height: this.props.height,
      type: this.props.imageType,
      sx: this.props.srcX,
      sy: this.props.srcY,
      sw: this.props.srcWidth,
      sh: this.props.srcHeight
    });
  }
  set imageType(type) {
    if (this.props.imageType === type) {
      return;
    }
    this.props.imageType = type;
  }
  get imageType() {
    return this.props.imageType || null;
  }
  get srcHeight() {
    return this.props.srcHeight;
  }
  set srcHeight(value) {
    this.props.srcHeight = value;
  }
  get srcWidth() {
    return this.props.srcWidth;
  }
  set srcWidth(value) {
    this.props.srcWidth = value;
  }
  get srcX() {
    return this.props.srcX;
  }
  set srcX(value) {
    this.props.srcX = value;
  }
  get srcY() {
    return this.props.srcY;
  }
  set srcY(value) {
    this.props.srcY = value;
  }
  /**
   * Returns the framebuffer dimensions of the node.
   * If the node has a render texture, the dimensions are the same as the node's dimensions.
   * If the node does not have a render texture, the dimensions are inherited from the parent.
   * If the node parent has a render texture and the node is a render texture, the nodes dimensions are used.
   */
  get framebufferDimensions() {
    if (this.parentHasRenderTexture && !this.rtt && this.parent) {
      return this.parent.framebufferDimensions;
    }
    return { width: this.width, height: this.height };
  }
  /**
   * Returns the parent render texture node if it exists.
   */
  get parentRenderTexture() {
    let parent = this.parent;
    while (parent) {
      if (parent.rtt) {
        return parent;
      }
      parent = parent.parent;
    }
    return null;
  }
  get texture() {
    return this.props.texture;
  }
  set texture(value) {
    if (this.props.texture === value) {
      return;
    }
    const oldTexture = this.props.texture;
    if (oldTexture) {
      oldTexture.setRenderableOwner(this, false);
      this.unloadTexture();
    }
    this.props.texture = value;
    if (value) {
      value.setRenderableOwner(this, this.isRenderable);
      this.loadTexture();
    }
    this.setUpdateType(UpdateType.IsRenderable);
  }
  set textureOptions(value) {
    this.props.textureOptions = value;
  }
  get textureOptions() {
    return this.props.textureOptions;
  }
  get strictBounds() {
    return this.props.strictBounds;
  }
  set strictBounds(v) {
    if (v === this.props.strictBounds) {
      return;
    }
    this.props.strictBounds = v;
    this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
    this.childUpdateType |= UpdateType.RenderBounds | UpdateType.Children;
  }
  animate(props, settings2) {
    const animation = new CoreAnimation(this, props, settings2);
    const controller = new CoreAnimationController(this.stage.animationManager, animation);
    return controller;
  }
  flush() {
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/platform.js
var startLoop = (stage2) => {
  let isIdle = false;
  const runLoop = () => {
    stage2.updateFrameTime();
    stage2.updateAnimations();
    if (!stage2.hasSceneUpdates()) {
      stage2.calculateFps();
      setTimeout(runLoop, 16.666666666666668);
      if (!isIdle) {
        if (stage2.txMemManager.checkCleanup()) {
          stage2.txMemManager.cleanup();
        }
        stage2.eventBus.emit("idle");
        isIdle = true;
      }
      stage2.flushFrameEvents();
      return;
    }
    isIdle = false;
    stage2.drawFrame();
    stage2.flushFrameEvents();
    requestAnimationFrame(runLoop);
  };
  requestAnimationFrame(runLoop);
};
var getTimeStamp = () => {
  return performance ? performance.now() : Date.now();
};

// node_modules/@lightningjs/renderer/dist/src/core/animations/AnimationManager.js
var AnimationManager = class {
  constructor() {
    __publicField(this, "activeAnimations", /* @__PURE__ */ new Set());
  }
  registerAnimation(animation) {
    this.activeAnimations.add(animation);
  }
  unregisterAnimation(animation) {
    this.activeAnimations.delete(animation);
  }
  update(dt) {
    this.activeAnimations.forEach((animation) => {
      animation.update(dt);
    });
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/textures/Texture.js
var TextureType;
(function(TextureType2) {
  TextureType2[TextureType2["generic"] = 0] = "generic";
  TextureType2[TextureType2["color"] = 1] = "color";
  TextureType2[TextureType2["image"] = 2] = "image";
  TextureType2[TextureType2["noise"] = 3] = "noise";
  TextureType2[TextureType2["renderToTexture"] = 4] = "renderToTexture";
  TextureType2[TextureType2["subTexture"] = 5] = "subTexture";
})(TextureType || (TextureType = {}));
var Texture = class extends EventEmitter {
  constructor(txManager) {
    super();
    __publicField(this, "txManager");
    /**
     * The dimensions of the texture
     *
     * @remarks
     * Until the texture data is loaded for the first time the value will be
     * `null`.
     */
    __publicField(this, "dimensions", null);
    __publicField(this, "error", null);
    __publicField(this, "state", "freed");
    __publicField(this, "renderableOwners", /* @__PURE__ */ new Set());
    __publicField(this, "renderable", false);
    __publicField(this, "lastRenderableChangeTime", 0);
    __publicField(this, "type", TextureType.generic);
    __publicField(this, "preventCleanup", false);
    this.txManager = txManager;
  }
  /**
   * Add/remove an owner to/from the Texture based on its renderability.
   *
   * @remarks
   * Any object can own a texture, be it a CoreNode or even the state object
   * from a Text Renderer.
   *
   * When the reference to the texture that an owner object holds is replaced
   * or cleared it must call this with `renderable=false` to release the owner
   * association.
   *
   * @param owner
   * @param renderable
   */
  setRenderableOwner(owner, renderable) {
    var _a2, _b;
    const oldSize = this.renderableOwners.size;
    if (renderable) {
      this.renderableOwners.add(owner);
      const newSize = this.renderableOwners.size;
      if (newSize > oldSize && newSize === 1) {
        this.renderable = true;
        this.lastRenderableChangeTime = this.txManager.frameTime;
        (_a2 = this.onChangeIsRenderable) == null ? void 0 : _a2.call(this, true);
      }
    } else {
      this.renderableOwners.delete(owner);
      const newSize = this.renderableOwners.size;
      if (newSize < oldSize && newSize === 0) {
        this.renderable = false;
        this.lastRenderableChangeTime = this.txManager.frameTime;
        (_b = this.onChangeIsRenderable) == null ? void 0 : _b.call(this, false);
      }
    }
  }
  /**
   * Get the CoreContextTexture for this Texture
   *
   * @remarks
   * Each Texture has a corresponding CoreContextTexture that is used to
   * manage the texture's native data depending on the renderer's mode
   * (WebGL, Canvas, etc).
   *
   * The Texture and CoreContextTexture are always linked together in a 1:1
   * relationship.
   */
  get ctxTexture() {
    const ctxTexture = this.txManager.renderer.createCtxTexture(this);
    Object.defineProperty(this, "ctxTexture", { value: ctxTexture });
    return ctxTexture;
  }
  /**
   * Set the state of the texture
   *
   * @remark
   * Intended for internal-use only but declared public so that it can be set
   * by it's associated {@link CoreContextTexture}
   *
   * @param state
   * @param args
   */
  setState(state, ...args) {
    if (this.state !== state) {
      this.state = state;
      if (state === "loaded") {
        const loadedArgs = args;
        this.dimensions = loadedArgs[0];
      } else if (state === "failed") {
        const failedArgs = args;
        this.error = failedArgs[0];
      }
      this.emit(state, ...args);
    }
  }
  /**
   * Make a cache key for this texture.
   *
   * @remarks
   * Each concrete `Texture` subclass must implement this method to provide an
   * appropriate cache key for the texture type including the texture's
   * properties that uniquely identify a copy of the texture. If the texture
   * type does not support caching, then this method should return `false`.
   *
   * @param props
   * @returns
   * A cache key for this texture or `false` if the texture type does not
   * support caching.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static makeCacheKey(props) {
    return false;
  }
  /**
   * Resolve the default values for the texture's properties.
   *
   * @remarks
   * Each concrete `Texture` subclass must implement this method to provide
   * default values for the texture's optional properties.
   *
   * @param props
   * @returns
   * The default values for the texture's properties.
   */
  static resolveDefaults(props) {
    return {};
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/lib/ImageWorker.js
function createImageWorker() {
  function hasAlphaChannel(mimeType) {
    return mimeType.indexOf("image/png") !== -1;
  }
  function getImage(src, premultiplyAlpha, x, y, width, height) {
    return new Promise(function(resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", src, true);
      xhr.responseType = "blob";
      xhr.onload = function() {
        if (xhr.status !== 200) {
          return reject(new Error("Failed to load image: " + xhr.statusText));
        }
        var blob = xhr.response;
        var withAlphaChannel = premultiplyAlpha !== void 0 ? premultiplyAlpha : hasAlphaChannel(blob.type);
        if (width !== null && height !== null) {
          createImageBitmap(blob, x || 0, y || 0, width, height, {
            premultiplyAlpha: withAlphaChannel ? "premultiply" : "none",
            colorSpaceConversion: "none",
            imageOrientation: "none"
          }).then(function(data) {
            resolve({ data, premultiplyAlpha });
          }).catch(function(error) {
            reject(error);
          });
          return;
        }
        createImageBitmap(blob, {
          premultiplyAlpha: withAlphaChannel ? "premultiply" : "none",
          colorSpaceConversion: "none",
          imageOrientation: "none"
        }).then(function(data) {
          resolve({ data, premultiplyAlpha });
        }).catch(function(error) {
          reject(error);
        });
      };
      xhr.onerror = function() {
        reject(new Error("Network error occurred while trying to fetch the image."));
      };
      xhr.send();
    });
  }
  self.onmessage = (event) => {
    var src = event.data.src;
    var id = event.data.id;
    var premultiplyAlpha = event.data.premultiplyAlpha;
    var x = event.data.sx;
    var y = event.data.sy;
    var width = event.data.sw;
    var height = event.data.sh;
    getImage(src, premultiplyAlpha, x, y, width, height).then(function(data) {
      self.postMessage({ id, src, data });
    }).catch(function(error) {
      self.postMessage({ id, src, error: error.message });
    });
  };
}
var ImageWorkerManager = class {
  constructor(numImageWorkers) {
    __publicField(this, "imageWorkersEnabled", true);
    __publicField(this, "messageManager", {});
    __publicField(this, "workers", []);
    __publicField(this, "workerIndex", 0);
    __publicField(this, "nextId", 0);
    this.workers = this.createWorkers(numImageWorkers);
    this.workers.forEach((worker) => {
      worker.onmessage = this.handleMessage.bind(this);
    });
  }
  handleMessage(event) {
    const { id, data, error } = event.data;
    const msg = this.messageManager[id];
    if (msg) {
      const [resolve, reject] = msg;
      delete this.messageManager[id];
      if (error) {
        reject(new Error(error));
      } else {
        resolve(data);
      }
    }
  }
  createWorkers(numWorkers = 1) {
    const workerCode = `(${createImageWorker.toString()})()`;
    const blob = new Blob([workerCode.replace('"use strict";', "")], {
      type: "application/javascript"
    });
    const blobURL = (self.URL ? URL : webkitURL).createObjectURL(blob);
    const workers = [];
    for (let i = 0; i < numWorkers; i++) {
      workers.push(new Worker(blobURL));
    }
    return workers;
  }
  getNextWorker() {
    const worker = this.workers[this.workerIndex];
    this.workerIndex = (this.workerIndex + 1) % this.workers.length;
    return worker;
  }
  getImage(src, premultiplyAlpha, sx, sy, sw, sh) {
    return new Promise((resolve, reject) => {
      try {
        if (this.workers) {
          const id = this.nextId++;
          this.messageManager[id] = [resolve, reject];
          const nextWorker = this.getNextWorker();
          if (nextWorker) {
            nextWorker.postMessage({
              id,
              src,
              premultiplyAlpha,
              sx,
              sy,
              sw,
              sh
            });
          }
        }
      } catch (error) {
        reject(error);
      }
    });
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/textures/ColorTexture.js
var _ColorTexture = class _ColorTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "type", TextureType.color);
    __publicField(this, "props");
    this.props = _ColorTexture.resolveDefaults(props || {});
  }
  get color() {
    return this.props.color;
  }
  set color(color) {
    this.props.color = color;
  }
  async getTextureData() {
    const pixelData = new Uint8Array(4);
    if (this.color === 4294967295) {
      pixelData[0] = 255;
      pixelData[1] = 255;
      pixelData[2] = 255;
      pixelData[3] = 255;
    } else {
      pixelData[0] = this.color >> 16 & 255;
      pixelData[1] = this.color >> 8 & 255;
      pixelData[2] = this.color & 255;
      pixelData[3] = this.color >>> 24 & 255;
    }
    return {
      data: pixelData,
      premultiplyAlpha: true
    };
  }
  static makeCacheKey(props) {
    const resolvedProps = _ColorTexture.resolveDefaults(props);
    return `ColorTexture,${resolvedProps.color}`;
  }
  static resolveDefaults(props) {
    return {
      color: props.color || 4294967295
    };
  }
};
__publicField(_ColorTexture, "z$__type__Props");
var ColorTexture = _ColorTexture;

// node_modules/@lightningjs/renderer/dist/src/core/lib/textureCompression.js
function isCompressedTextureContainer(url) {
  return /\.(ktx|pvr)$/.test(url);
}
var loadCompressedTexture = async (url) => {
  const response = await fetch(url);
  const arrayBuffer = await response.arrayBuffer();
  if (url.indexOf(".ktx") !== -1) {
    return loadKTXData(arrayBuffer);
  }
  return loadPVRData(arrayBuffer);
};
var loadKTXData = async (buffer) => {
  const view = new DataView(buffer);
  const littleEndian = view.getUint32(12) === 16909060 ? true : false;
  const mipmaps = [];
  const data = {
    glInternalFormat: view.getUint32(28, littleEndian),
    pixelWidth: view.getUint32(36, littleEndian),
    pixelHeight: view.getUint32(40, littleEndian),
    numberOfMipmapLevels: view.getUint32(56, littleEndian),
    bytesOfKeyValueData: view.getUint32(60, littleEndian)
  };
  let offset = 64;
  offset += data.bytesOfKeyValueData;
  for (let i = 0; i < data.numberOfMipmapLevels; i++) {
    const imageSize = view.getUint32(offset);
    offset += 4;
    mipmaps.push(view.buffer.slice(offset, imageSize));
    offset += imageSize;
  }
  return {
    data: {
      glInternalFormat: data.glInternalFormat,
      mipmaps,
      width: data.pixelWidth || 0,
      height: data.pixelHeight || 0,
      type: "ktx"
    },
    premultiplyAlpha: false
  };
};
var loadPVRData = async (buffer) => {
  const pvrHeaderLength = 13;
  const pvrFormatEtc1 = 36196;
  const pvrWidth = 7;
  const pvrHeight = 6;
  const pvrMipmapCount = 11;
  const pvrMetadata = 12;
  const arrayBuffer = buffer;
  const header = new Int32Array(arrayBuffer, 0, pvrHeaderLength);
  const dataOffset = header[pvrMetadata] + 52;
  const pvrtcData = new Uint8Array(arrayBuffer, dataOffset);
  const mipmaps = [];
  const data = {
    pixelWidth: header[pvrWidth],
    pixelHeight: header[pvrHeight],
    numberOfMipmapLevels: header[pvrMipmapCount] || 0
  };
  let offset = 0;
  let width = data.pixelWidth || 0;
  let height = data.pixelHeight || 0;
  for (let i = 0; i < data.numberOfMipmapLevels; i++) {
    const level = (width + 3 >> 2) * (height + 3 >> 2) * 8;
    const view = new Uint8Array(arrayBuffer, pvrtcData.byteOffset + offset, level);
    mipmaps.push(view);
    offset += level;
    width = width >> 1;
    height = height >> 1;
  }
  return {
    data: {
      glInternalFormat: pvrFormatEtc1,
      mipmaps,
      width: data.pixelWidth || 0,
      height: data.pixelHeight || 0,
      type: "pvr"
    },
    premultiplyAlpha: false
  };
};

// node_modules/@lightningjs/renderer/dist/src/core/lib/textureSvg.js
function isSvgImage(url) {
  return /\.(svg)$/.test(url);
}
var loadSvg = (url, width, height, sx, sy, sw, sh) => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    assertTruthy(ctx);
    ctx.imageSmoothingEnabled = true;
    const img = new Image();
    img.onload = () => {
      const x = sx ?? 0;
      const y = sy ?? 0;
      const w = width || img.width;
      const h = height || img.height;
      canvas.width = w;
      canvas.height = h;
      ctx.drawImage(img, 0, 0, w, h);
      resolve({
        data: ctx.getImageData(x, y, sw ?? w, sh ?? h),
        premultiplyAlpha: false
      });
    };
    img.onerror = (err) => {
      reject(err);
    };
    img.src = url;
  });
};

// node_modules/@lightningjs/renderer/dist/src/core/textures/ImageTexture.js
var _ImageTexture = class _ImageTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "props");
    __publicField(this, "type", TextureType.image);
    this.props = _ImageTexture.resolveDefaults(props);
  }
  hasAlphaChannel(mimeType) {
    return mimeType.indexOf("image/png") !== -1;
  }
  async loadImage(src) {
    const { premultiplyAlpha, sx, sy, sw, sh, width, height } = this.props;
    if (this.txManager.imageWorkerManager !== null) {
      return await this.txManager.imageWorkerManager.getImage(src, premultiplyAlpha, sx, sy, sw, sh);
    } else if (this.txManager.hasCreateImageBitmap === true) {
      const response = await fetch(src);
      const blob = await response.blob();
      const hasAlphaChannel = premultiplyAlpha ?? this.hasAlphaChannel(blob.type);
      if (sw !== null && sh !== null) {
        return {
          data: await createImageBitmap(blob, sx ?? 0, sy ?? 0, sw, sh, {
            premultiplyAlpha: hasAlphaChannel ? "premultiply" : "none",
            colorSpaceConversion: "none",
            imageOrientation: "none"
          }),
          premultiplyAlpha: hasAlphaChannel
        };
      }
      return {
        data: await createImageBitmap(blob, {
          premultiplyAlpha: hasAlphaChannel ? "premultiply" : "none",
          colorSpaceConversion: "none",
          imageOrientation: "none"
        }),
        premultiplyAlpha: hasAlphaChannel
      };
    } else {
      const img = new Image();
      if (!src.startsWith("data:")) {
        img.crossOrigin = "Anonymous";
      }
      img.src = src;
      await new Promise((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = () => reject(new Error(`Failed to load image`));
      }).catch((e) => {
        console.error(e);
      });
      return {
        data: img,
        premultiplyAlpha: premultiplyAlpha ?? true
      };
    }
  }
  async getTextureData() {
    const { src, premultiplyAlpha, type } = this.props;
    if (src === null) {
      return {
        data: null
      };
    }
    if (typeof src !== "string") {
      if (src instanceof ImageData) {
        return {
          data: src,
          premultiplyAlpha
        };
      }
      return {
        data: src(),
        premultiplyAlpha
      };
    }
    const absoluteSrc = convertUrlToAbsolute(src);
    if (type === "regular") {
      return this.loadImage(absoluteSrc);
    }
    if (type === "svg") {
      return loadSvg(absoluteSrc, this.props.width, this.props.height, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
    }
    if (isSvgImage(src) === true) {
      return loadSvg(absoluteSrc, this.props.width, this.props.height, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
    }
    if (type === "compressed") {
      return loadCompressedTexture(absoluteSrc);
    }
    if (isCompressedTextureContainer(src) === true) {
      return loadCompressedTexture(absoluteSrc);
    }
    return this.loadImage(absoluteSrc);
  }
  /**
   * Generates a cache key for the ImageTexture based on the provided props.
   * @param props - The props used to generate the cache key.
   * @returns The cache key as a string, or `false` if the key cannot be generated.
   */
  static makeCacheKey(props) {
    const resolvedProps = _ImageTexture.resolveDefaults(props);
    const key = resolvedProps.key || resolvedProps.src;
    if (typeof key !== "string") {
      return false;
    }
    let dimensionProps = "";
    if (resolvedProps.sh !== null && resolvedProps.sw !== null) {
      dimensionProps += ",";
      dimensionProps += resolvedProps.sx ?? "";
      dimensionProps += resolvedProps.sy ?? "";
      dimensionProps += resolvedProps.sw || "";
      dimensionProps += resolvedProps.sh || "";
    }
    return `ImageTexture,${key},${resolvedProps.premultiplyAlpha ?? "true"}${dimensionProps}`;
  }
  static resolveDefaults(props) {
    return {
      src: props.src ?? "",
      premultiplyAlpha: props.premultiplyAlpha ?? true,
      key: props.key ?? null,
      type: props.type ?? null,
      width: props.width ?? null,
      height: props.height ?? null,
      sx: props.sx ?? null,
      sy: props.sy ?? null,
      sw: props.sw ?? null,
      sh: props.sh ?? null
    };
  }
};
__publicField(_ImageTexture, "z$__type__Props");
var ImageTexture = _ImageTexture;

// node_modules/@lightningjs/renderer/dist/src/core/textures/NoiseTexture.js
var _NoiseTexture = class _NoiseTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "props");
    __publicField(this, "type", TextureType.noise);
    this.props = _NoiseTexture.resolveDefaults(props);
  }
  async getTextureData() {
    const { width, height } = this.props;
    const size = width * height * 4;
    const pixelData8 = new Uint8ClampedArray(size);
    for (let i = 0; i < size; i += 4) {
      const v = Math.floor(Math.random() * 256);
      pixelData8[i] = v;
      pixelData8[i + 1] = v;
      pixelData8[i + 2] = v;
      pixelData8[i + 3] = 255;
    }
    return {
      data: new ImageData(pixelData8, width, height)
    };
  }
  static makeCacheKey(props) {
    if (props.cacheId === void 0) {
      return false;
    }
    const resolvedProps = _NoiseTexture.resolveDefaults(props);
    return `NoiseTexture,${resolvedProps.width},${resolvedProps.height},${resolvedProps.cacheId}`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 128,
      height: props.height ?? 128,
      cacheId: props.cacheId ?? 0
    };
  }
};
__publicField(_NoiseTexture, "z$__type__Props");
var NoiseTexture = _NoiseTexture;

// node_modules/@lightningjs/renderer/dist/src/core/textures/SubTexture.js
var _SubTexture = class _SubTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "props");
    __publicField(this, "parentTexture");
    __publicField(this, "type", TextureType.subTexture);
    __publicField(this, "onParentTxLoaded", () => {
      this.setState("loaded", {
        width: this.props.width,
        height: this.props.height
      });
    });
    __publicField(this, "onParentTxFailed", (target, error) => {
      this.setState("failed", error);
    });
    this.props = _SubTexture.resolveDefaults(props || {});
    this.parentTexture = this.props.texture;
    queueMicrotask(() => {
      const parentTx = this.parentTexture;
      if (parentTx.state === "loaded") {
        this.onParentTxLoaded(parentTx, parentTx.dimensions);
      } else if (parentTx.state === "failed") {
        this.onParentTxFailed(parentTx, parentTx.error);
      }
      parentTx.on("loaded", this.onParentTxLoaded);
      parentTx.on("failed", this.onParentTxFailed);
    });
  }
  onChangeIsRenderable(isRenderable) {
    this.parentTexture.setRenderableOwner(this, isRenderable);
  }
  async getTextureData() {
    return {
      data: this.props
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static makeCacheKey(props) {
    return false;
  }
  static resolveDefaults(props) {
    return {
      texture: props.texture,
      x: props.x || 0,
      y: props.y || 0,
      width: props.width || 0,
      height: props.height || 0
    };
  }
};
__publicField(_SubTexture, "z$__type__Props");
var SubTexture = _SubTexture;

// node_modules/@lightningjs/renderer/dist/src/core/textures/RenderTexture.js
var _RenderTexture = class _RenderTexture extends Texture {
  constructor(txManager, props) {
    super(txManager);
    __publicField(this, "props");
    __publicField(this, "type", TextureType.renderToTexture);
    this.props = _RenderTexture.resolveDefaults(props || {});
  }
  get width() {
    return this.props.width;
  }
  set width(value) {
    this.props.width = value;
  }
  get height() {
    return this.props.height;
  }
  set height(value) {
    this.props.height = value;
  }
  async getTextureData() {
    return {
      data: null,
      premultiplyAlpha: null
    };
  }
  static resolveDefaults(props) {
    return {
      width: props.width || 256,
      height: props.height || 256
    };
  }
};
__publicField(_RenderTexture, "z$__type__Props");
var RenderTexture = _RenderTexture;

// node_modules/@lightningjs/renderer/dist/src/core/CoreTextureManager.js
var CoreTextureManager = class {
  constructor(numImageWorkers) {
    /**
     * Map of textures by cache key
     */
    __publicField(this, "keyCache", /* @__PURE__ */ new Map());
    /**
     * Map of cache keys by texture
     */
    __publicField(this, "inverseKeyCache", /* @__PURE__ */ new WeakMap());
    /**
     * Map of texture constructors by their type name
     */
    __publicField(this, "txConstructors", {});
    __publicField(this, "imageWorkerManager", null);
    __publicField(this, "hasCreateImageBitmap", !!self.createImageBitmap);
    __publicField(this, "hasWorker", !!self.Worker);
    /**
     * Renderer that this texture manager is associated with
     *
     * @remarks
     * This MUST be set before the texture manager is used. Otherwise errors
     * will occur when using the texture manager.
     */
    __publicField(this, "renderer");
    /**
     * The current frame time in milliseconds
     *
     * @remarks
     * This is used to populate the `lastRenderableChangeTime` property of
     * {@link Texture} instances when their renderable state changes.
     *
     * Set by stage via `updateFrameTime` method.
     */
    __publicField(this, "frameTime", 0);
    if (this.hasCreateImageBitmap && this.hasWorker && numImageWorkers > 0) {
      this.imageWorkerManager = new ImageWorkerManager(numImageWorkers);
    }
    if (!this.hasCreateImageBitmap) {
      console.warn("[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.");
    }
    this.registerTextureType("ImageTexture", ImageTexture);
    this.registerTextureType("ColorTexture", ColorTexture);
    this.registerTextureType("NoiseTexture", NoiseTexture);
    this.registerTextureType("SubTexture", SubTexture);
    this.registerTextureType("RenderTexture", RenderTexture);
  }
  registerTextureType(textureType, textureClass) {
    this.txConstructors[textureType] = textureClass;
  }
  loadTexture(textureType, props) {
    let texture;
    const TextureClass = this.txConstructors[textureType];
    if (!TextureClass) {
      throw new Error(`Texture type "${textureType}" is not registered`);
    }
    if (!texture) {
      const cacheKey = TextureClass.makeCacheKey(props);
      if (cacheKey && this.keyCache.has(cacheKey)) {
        texture = this.keyCache.get(cacheKey);
      } else {
        texture = new TextureClass(this, props);
        if (cacheKey) {
          this.initTextureToCache(texture, cacheKey);
        }
      }
    }
    return texture;
  }
  initTextureToCache(texture, cacheKey) {
    const { keyCache, inverseKeyCache } = this;
    keyCache.set(cacheKey, texture);
    inverseKeyCache.set(texture, cacheKey);
  }
  /**
   * Remove a texture from the cache
   *
   * @remarks
   * Called by Texture Cleanup when a texture is freed.
   *
   * @param texture
   */
  removeTextureFromCache(texture) {
    const { inverseKeyCache, keyCache } = this;
    const cacheKey = inverseKeyCache.get(texture);
    if (cacheKey) {
      keyCache.delete(cacheKey);
    }
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/TrFontManager.js
var weightConversions = {
  normal: 400,
  bold: 700,
  bolder: 900,
  lighter: 100
};
var fontWeightToNumber = (weight) => {
  if (typeof weight === "number") {
    return weight;
  }
  return weightConversions[weight] || 400;
};
function resolveFontToUse(familyMapsByPriority, family, weightIn, style, stretch) {
  let weight = fontWeightToNumber(weightIn);
  for (const fontFamiles of familyMapsByPriority) {
    const fontFaces = fontFamiles[family];
    if (!fontFaces) {
      continue;
    }
    if (fontFaces.size === 1) {
      console.warn(`TrFontManager: Only one font face found for family: '${family}' - will be used for all weights and styles`);
      return fontFaces.values().next().value;
    }
    const weightMap = /* @__PURE__ */ new Map();
    for (const fontFace of fontFaces) {
      const fontFamilyWeight = fontWeightToNumber(fontFace.descriptors.weight);
      if (fontFamilyWeight === weight && fontFace.descriptors.style === style && fontFace.descriptors.stretch === stretch) {
        return fontFace;
      }
      weightMap.set(fontFamilyWeight, fontFace);
    }
    const msg = `TrFontManager: No exact match: '${family} Weight: ${weight} Style: ${style} Stretch: ${stretch}'`;
    console.error(msg);
    if (weight === 400 && weightMap.has(500)) {
      return weightMap.get(500);
    }
    if (weight === 500 && weightMap.has(400)) {
      return weightMap.get(400);
    }
    if (weight < 400) {
      while (weight > 0) {
        if (weightMap.has(weight)) {
          return weightMap.get(weight);
        }
        weight -= 100;
      }
      weight = 600;
    }
    while (weight < 1e3) {
      if (weightMap.has(weight)) {
        return weightMap.get(weight);
      }
      weight += 100;
    }
    weight = 500;
    while (weight > 0) {
      if (weightMap.has(weight)) {
        return weightMap.get(weight);
      }
      weight -= 100;
    }
  }
  return;
}
var TrFontManager = class {
  constructor(textRenderers) {
    __publicField(this, "textRenderers");
    __publicField(this, "fontCache", /* @__PURE__ */ new Map());
    this.textRenderers = textRenderers;
  }
  addFontFace(font) {
    for (const trId in this.textRenderers) {
      const tr = this.textRenderers[trId];
      if (tr && tr.isFontFaceSupported(font)) {
        tr.addFontFace(font);
      }
    }
  }
  /**
   * Utility method to resolve a single font face from a list of prioritized family maps based on
   * a set of font properties.
   *
   * @remarks
   * These are to be used by a text renderer to resolve a font face if needed.
   *
   * @param familyMapsByPriority
   * @param props
   * @returns
   */
  resolveFontFace(familyMapsByPriority, props, rendererType) {
    const { fontFamily, fontWeight, fontStyle, fontStretch } = props;
    const fontCacheString = `${rendererType}_${fontFamily}_${fontStyle}_${fontWeight}_${fontStretch}`;
    if (this.fontCache.has(fontCacheString) === true) {
      return this.fontCache.get(fontCacheString);
    }
    const resolvedFont = resolveFontToUse(familyMapsByPriority, fontFamily, fontWeight, fontStyle, fontStretch);
    if (resolvedFont !== void 0) {
      this.fontCache.set(fontCacheString, resolvedFont);
    }
    return resolvedFont;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/CoreShader.js
var CoreShader = class {
  // abstract draw(): void;
  static makeCacheKey(props) {
    return false;
  }
  static resolveDefaults(props) {
    return {};
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/internal/ShaderUtils.js
function createShader(glw, type, source) {
  const shader = glw.createShader(type);
  if (!shader) {
    throw new Error(`Unable to create shader type: ${type}. Source: ${source}`);
  }
  glw.shaderSource(shader, source);
  glw.compileShader(shader);
  const success = !!glw.getShaderParameter(shader, glw.COMPILE_STATUS);
  if (success) {
    return shader;
  }
  console.log(glw.getShaderInfoLog(shader));
  glw.deleteShader(shader);
}
function createProgram(glw, vertexShader, fragmentShader) {
  const program = glw.createProgram();
  if (!program) {
    throw new Error("Unable to create program");
  }
  glw.attachShader(program, vertexShader);
  glw.attachShader(program, fragmentShader);
  glw.linkProgram(program);
  const success = !!glw.getProgramParameter(program, glw.LINK_STATUS);
  if (success) {
    return program;
  }
  console.log(glw.getProgramInfoLog(program));
  glw.deleteProgram(program);
  return void 0;
}

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreShader.js
var WebGlCoreShader = class extends CoreShader {
  constructor(options) {
    super();
    __publicField(this, "boundBufferCollection", null);
    __publicField(this, "buffersBound", false);
    __publicField(this, "program");
    /**
     * Vertex Array Object
     *
     * @remarks
     * Used by WebGL2 Only
     */
    __publicField(this, "vao");
    __publicField(this, "renderer");
    __publicField(this, "glw");
    __publicField(this, "attributeBuffers");
    __publicField(this, "attributeLocations");
    __publicField(this, "attributeNames");
    __publicField(this, "uniformLocations");
    __publicField(this, "uniformTypes");
    __publicField(this, "supportsIndexedTextures");
    const renderer3 = this.renderer = options.renderer;
    const glw = this.glw = this.renderer.glw;
    this.supportsIndexedTextures = options.supportsIndexedTextures || false;
    const webGl2 = glw.isWebGl2();
    const requiredExtensions = webGl2 && options.webgl2Extensions || !webGl2 && options.webgl1Extensions || [];
    const glVersion = webGl2 ? "2.0" : "1.0";
    requiredExtensions.forEach((extensionName) => {
      if (!glw.getExtension(extensionName)) {
        throw new Error(`Shader "${this.constructor.name}" requires extension "${extensionName}" for WebGL ${glVersion} but wasn't found`);
      }
    });
    const shaderSources = options.shaderSources || this.constructor.shaderSources;
    if (!shaderSources) {
      throw new Error(`Shader "${this.constructor.name}" is missing shaderSources.`);
    } else if (webGl2 && (shaderSources == null ? void 0 : shaderSources.webGl2)) {
      shaderSources.fragment = shaderSources.webGl2.fragment;
      shaderSources.vertex = shaderSources.webGl2.vertex;
      delete shaderSources.webGl2;
    }
    const textureUnits = renderer3.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
    const vertexSource = shaderSources.vertex instanceof Function ? shaderSources.vertex(textureUnits) : shaderSources.vertex;
    const fragmentSource = shaderSources.fragment instanceof Function ? shaderSources.fragment(textureUnits) : shaderSources.fragment;
    const vertexShader = createShader(glw, glw.VERTEX_SHADER, vertexSource);
    const fragmentShader = createShader(glw, glw.FRAGMENT_SHADER, fragmentSource);
    if (!vertexShader || !fragmentShader) {
      throw new Error(`Unable to create shader type: ${glw.FRAGMENT_SHADER}. Source: ${fragmentSource}`);
    }
    const program = createProgram(glw, vertexShader, fragmentShader);
    if (!program) {
      throw new Error("Unable to create program");
    }
    this.program = program;
    this.attributeLocations = {};
    this.attributeBuffers = {};
    this.attributeNames = [];
    [...options.attributes].forEach((attributeName) => {
      const location = glw.getAttribLocation(this.program, attributeName);
      if (location < 0) {
        throw new Error(`${this.constructor.name}: Vertex shader must have an attribute "${attributeName}"!`);
      }
      const buffer = glw.createBuffer();
      if (!buffer) {
        throw new Error(`${this.constructor.name}: Could not create buffer for attribute "${attributeName}"`);
      }
      this.attributeLocations[attributeName] = location;
      this.attributeBuffers[attributeName] = buffer;
      this.attributeNames.push(attributeName);
    });
    this.uniformLocations = {};
    this.uniformTypes = {};
    options.uniforms.forEach((uniform) => {
      const location = glw.getUniformLocation(this.program, uniform.name);
      this.uniformTypes[uniform.name] = uniform.uniform;
      if (!location) {
        console.warn(`Shader "${this.constructor.name}" could not get uniform location for "${uniform.name}"`);
        return;
      }
      this.uniformLocations[uniform.name] = location;
    });
  }
  bindBufferAttribute(location, buffer, attribute) {
    const { glw } = this;
    glw.enableVertexAttribArray(location);
    glw.vertexAttribPointer(buffer, location, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.offset);
  }
  disableAttribute(location) {
    this.glw.disableVertexAttribArray(location);
  }
  disableAttributes() {
    for (const loc in this.attributeLocations) {
      this.disableAttribute(this.attributeLocations[loc]);
    }
    this.boundBufferCollection = null;
  }
  /**
   * Given two sets of Shader props destined for this Shader, determine if they can be batched together
   * to reduce the number of draw calls.
   *
   * @remarks
   * This is used by the {@link WebGlCoreRenderer} to determine if it can batch multiple consecutive draw
   * calls into a single draw call.
   *
   * By default, this returns false (meaning no batching is allowed), but can be
   * overridden by child classes to provide more efficient batching.
   *
   * @param propsA
   * @param propsB
   * @returns
   */
  canBatchShaderProps(propsA, propsB) {
    return false;
  }
  bindRenderOp(renderOp, props) {
    this.bindBufferCollection(renderOp.buffers);
    if (renderOp.textures.length > 0) {
      this.bindTextures(renderOp.textures);
    }
    const { glw, parentHasRenderTexture, renderToTexture } = renderOp;
    if (renderToTexture && parentHasRenderTexture) {
      return;
    }
    if (parentHasRenderTexture) {
      const { width, height } = renderOp.framebufferDimensions || {};
      glw.uniform1f(this.getUniformLocation("u_pixelRatio"), 1);
      glw.uniform2f(this.getUniformLocation("u_resolution"), width ?? 0, height ?? 0);
    } else {
      glw.uniform1f(this.getUniformLocation("u_pixelRatio"), renderOp.options.pixelRatio);
      glw.uniform2f(this.getUniformLocation("u_resolution"), glw.canvas.width, glw.canvas.height);
    }
    if (props) {
      if (hasOwn(props, "$dimensions")) {
        let dimensions = props.$dimensions;
        if (!dimensions) {
          dimensions = renderOp.dimensions;
        }
        glw.uniform2f(this.getUniformLocation("u_dimensions"), dimensions.width, dimensions.height);
      }
      if (hasOwn(props, "$alpha")) {
        let alpha = props.$alpha;
        if (!alpha) {
          alpha = renderOp.alpha;
        }
        glw.uniform1f(this.getUniformLocation("u_alpha"), alpha);
      }
      this.bindProps(props);
    }
  }
  getUniformLocation(name) {
    return this.uniformLocations[name] || null;
  }
  bindBufferCollection(buffer) {
    if (this.boundBufferCollection === buffer) {
      return;
    }
    for (const attributeName in this.attributeLocations) {
      const resolvedBuffer = buffer.getBuffer(attributeName);
      const resolvedInfo = buffer.getAttributeInfo(attributeName);
      assertTruthy(resolvedBuffer, `Buffer for "${attributeName}" not found`);
      assertTruthy(resolvedInfo);
      this.bindBufferAttribute(this.attributeLocations[attributeName], resolvedBuffer, resolvedInfo);
    }
    this.boundBufferCollection = buffer;
  }
  bindProps(props) {
  }
  bindTextures(textures) {
  }
  attach() {
    this.glw.useProgram(this.program);
    if (this.glw.isWebGl2() && this.vao) {
      this.glw.bindVertexArray(this.vao);
    }
  }
  detach() {
    this.disableAttributes();
  }
};
__publicField(WebGlCoreShader, "shaderSources");

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/DefaultShader.js
var DefaultShader = class extends WebGlCoreShader {
  constructor(renderer3) {
    super({
      renderer: renderer3,
      attributes: ["a_position", "a_textureCoordinate", "a_color"],
      uniforms: [
        { name: "u_resolution", uniform: "uniform2fv" },
        { name: "u_pixelRatio", uniform: "uniform1f" },
        { name: "u_texture", uniform: "uniform2fv" }
      ]
    });
  }
  bindTextures(textures) {
    const { glw } = this;
    glw.activeTexture(0);
    glw.bindTexture(textures[0].ctxTexture);
  }
};
__publicField(DefaultShader, "shaderSources", {
  vertex: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      attribute vec2 a_position;
      attribute vec2 a_textureCoordinate;
      attribute vec4 a_color;

      uniform vec2 u_resolution;
      uniform float u_pixelRatio;


      varying vec4 v_color;
      varying vec2 v_textureCoordinate;

      void main() {
        vec2 normalized = a_position * u_pixelRatio;
        vec2 screenSpace = vec2(2.0 / u_resolution.x, -2.0 / u_resolution.y);

        v_color = a_color;
        v_textureCoordinate = a_textureCoordinate;

        gl_Position = vec4(normalized.x * screenSpace.x - 1.0, normalized.y * -abs(screenSpace.y) + 1.0, 0.0, 1.0);
        gl_Position.y = -sign(screenSpace.y) * gl_Position.y;
      }
    `,
  fragment: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      uniform vec2 u_resolution;
      uniform sampler2D u_texture;

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;

      void main() {
          vec4 color = texture2D(u_texture, v_textureCoordinate);
          gl_FragColor = vec4(v_color) * texture2D(u_texture, v_textureCoordinate);
      }
    `
});

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/DefaultShaderBatched.js
var DefaultShaderBatched = class extends WebGlCoreShader {
  constructor(renderer3) {
    super({
      renderer: renderer3,
      attributes: [
        "a_position",
        "a_textureCoordinate",
        "a_color",
        "a_textureIndex"
      ],
      uniforms: [
        { name: "u_resolution", uniform: "uniform2fv" },
        { name: "u_pixelRatio", uniform: "uniform1f" },
        { name: "u_textures[0]", uniform: "uniform1iv" }
      ]
    });
    __publicField(this, "supportsIndexedTextures", true);
  }
  bindTextures(texture) {
    const { renderer: renderer3, glw } = this;
    if (texture.length > renderer3.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS) {
      throw new Error(`DefaultShaderBatched: Cannot bind more than ${renderer3.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS} textures`);
    }
    texture.forEach((t, i) => {
      glw.activeTexture(i);
      glw.bindTexture(t.ctxTexture);
    });
    const samplers = Array.from(Array(texture.length).keys());
    this.glw.uniform1iv(this.getUniformLocation("u_textures[0]"), samplers);
  }
};
__publicField(DefaultShaderBatched, "shaderSources", {
  vertex: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      attribute vec2 a_textureCoordinate;
      attribute vec2 a_position;
      attribute vec4 a_color;
      attribute float a_textureIndex;
      attribute float a_depth;

      uniform vec2 u_resolution;
      uniform float u_pixelRatio;

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;
      varying float v_textureIndex;

      void main(){
        vec2 normalized = a_position * u_pixelRatio / u_resolution;
        vec2 zero_two = normalized * 2.0;
        vec2 clip_space = zero_two - 1.0;

        // pass to fragment
        v_color = a_color;
        v_textureCoordinate = a_textureCoordinate;
        v_textureIndex = a_textureIndex;

        // flip y
        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);
      }
    `,
  fragment: (textureUnits) => `
      #define txUnits ${textureUnits}
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      uniform vec2 u_resolution;
      uniform sampler2D u_image;
      uniform sampler2D u_textures[txUnits];

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;
      varying float v_textureIndex;

      vec4 sampleFromTexture(sampler2D textures[${textureUnits}], int idx, vec2 uv) {
        ${Array.from(Array(textureUnits).keys()).map((idx) => `
          ${idx !== 0 ? "else " : ""}if (idx == ${idx}) {
            return texture2D(textures[${idx}], uv);
          }
        `).join("")}
        return texture2D(textures[0], uv);
      }

      void main(){
        gl_FragColor = vec4(v_color) * sampleFromTexture(u_textures, int(v_textureIndex), v_textureCoordinate);
      }
    `
});

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/ShaderEffect.js
var ShaderEffect = class {
  constructor(options) {
    __publicField(this, "priority", 1);
    __publicField(this, "name", "");
    __publicField(this, "ref");
    __publicField(this, "target");
    __publicField(this, "passParameters", "");
    __publicField(this, "declaredUniforms", "");
    __publicField(this, "uniformInfo", {});
    const { ref, target, props = {} } = options;
    this.ref = ref;
    this.target = target;
    const uniformInfo = {};
    const passParameters = [];
    let declaredUniforms = "";
    const uniforms = this.constructor.uniforms || {};
    for (const u in uniforms) {
      const unif = uniforms[u];
      const uniType = unif.type;
      const uniformName = `${ref}_${u}`;
      let define = "";
      if (unif.size) {
        define = `[${unif.size(props)}]`;
      }
      passParameters.push(uniformName);
      declaredUniforms += `uniform ${uniType} ${uniformName}${define};`;
      uniformInfo[u] = { name: uniformName, uniform: uniforms[u].method };
    }
    this.passParameters = passParameters.join(",");
    this.declaredUniforms = declaredUniforms;
    this.uniformInfo = uniformInfo;
  }
  static getEffectKey(props) {
    return "";
  }
  static getMethodParameters(uniforms, props) {
    const res = [];
    for (const u in uniforms) {
      const uni = uniforms[u];
      let define = "";
      if (uni.size) {
        define = `[${uni.size(props)}]`;
      }
      res.push(`${uni.type} ${u}${define}`);
    }
    return res.join(",");
  }
  static resolveDefaults(props) {
    return {};
  }
  static makeEffectKey(props) {
    return false;
  }
};
__publicField(ShaderEffect, "uniforms", {});
__publicField(ShaderEffect, "methods");
__publicField(ShaderEffect, "onShaderMask");
__publicField(ShaderEffect, "onColorize");
__publicField(ShaderEffect, "onEffectMask");

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/DynamicShader.js
var effectCache = /* @__PURE__ */ new Map();
var getResolvedEffect = (effects, effectContructors) => {
  const key = JSON.stringify(effects);
  if (effectCache.has(key)) {
    return effectCache.get(key);
  }
  effects = effects ?? [];
  const resolvedEffects = [];
  const effectsLength = effects.length;
  let i = 0;
  for (; i < effectsLength; i++) {
    const { name, type, props } = effects[i];
    const resolvedEffect = {
      name,
      type,
      props: {}
    };
    const effectConstructor = effectContructors[type];
    const defaultPropValues = effectConstructor.resolveDefaults(props);
    const uniforms = effectConstructor.uniforms;
    const uniformKeys = Object.keys(uniforms);
    const uniformsLength = uniformKeys.length;
    let j = 0;
    for (; j < uniformsLength; j++) {
      const key2 = uniformKeys[j];
      const uniform = uniforms[key2];
      const result = {
        value: defaultPropValues[key2],
        programValue: void 0,
        method: uniform.method,
        updateOnBind: uniform.updateOnBind || false,
        hasValidator: uniform.validator !== void 0,
        hasProgramValueUpdater: uniform.updateProgramValue !== void 0
      };
      const validatedValue = result.hasValidator && uniform.validator(defaultPropValues[key2], defaultPropValues) || defaultPropValues[key2];
      if (defaultPropValues[key2] !== validatedValue) {
        result.validatedValue = validatedValue;
      }
      if (result.hasProgramValueUpdater) {
        uniform.updateProgramValue(result);
      }
      if (result.programValue === void 0) {
        result.programValue = result.value;
      }
      resolvedEffect.props[key2] = result;
    }
    resolvedEffects.push(resolvedEffect);
  }
  effectCache.set(key, resolvedEffects);
  return resolvedEffects;
};
var _DynamicShader = class _DynamicShader extends WebGlCoreShader {
  constructor(renderer3, props, effectContructors) {
    const shader = _DynamicShader.createShader(props, effectContructors);
    super({
      renderer: renderer3,
      attributes: ["a_position", "a_textureCoordinate", "a_color"],
      uniforms: [
        { name: "u_resolution", uniform: "uniform2fv" },
        { name: "u_pixelRatio", uniform: "uniform1f" },
        { name: "u_texture", uniform: "uniform2fv" },
        { name: "u_dimensions", uniform: "uniform2fv" },
        { name: "u_alpha", uniform: "uniform1f" },
        ...shader.uniforms
      ],
      shaderSources: {
        vertex: shader.vertex,
        fragment: shader.fragment
      }
    });
    __publicField(this, "effects", []);
    this.effects = shader.effects;
  }
  bindTextures(textures) {
    const { glw } = this;
    glw.activeTexture(0);
    glw.bindTexture(textures[0].ctxTexture);
  }
  bindUniformMethods(props) {
    const glw = this.glw;
    const effects = props.effects;
    const effectsL = effects.length;
    for (let i = 0; i < effectsL; i++) {
      const uniformInfo = this.effects[i].uniformInfo;
      const effect2 = effects[i];
      const propKeys = Object.keys(effect2.props);
      const propsLength = propKeys.length;
      for (let j = 0; j < propsLength; j++) {
        const key = propKeys[j];
        const method = effect2.props[key].method;
        const location = this.getUniformLocation(uniformInfo[key].name);
        if (method === "uniform2fv" || method === "uniform2iv" || //uniform === 'uniform3fv	' || <--- check why this isnt recognized
        method === "uniform3iv" || method === "uniform4fv" || method === "uniform4iv" || method === "uniformMatrix2fv" || method === "uniformMatrix3fv" || method === "uniformMatrix4fv" || method === "uniform1f" || method === "uniform1fv" || method === "uniform1i" || method === "uniform1iv") {
          effect2.props[key].setUniformValue = function() {
            glw[method](location, this.programValue);
          };
          continue;
        }
        if (method === "uniform2f" || method === "uniform2i") {
          effect2.props[key].setUniformValue = function() {
            glw[method](location, this.programValue[0], this.programValue[1]);
          };
          continue;
        }
        if (method === "uniform3f" || method === "uniform3i") {
          effect2.props[key].setUniformValue = function() {
            glw[method](location, this.programValue[0], this.programValue[1], this.programValue[2]);
          };
          continue;
        }
        if (method === "uniform4f" || method === "uniform4i") {
          effect2.props[key].setUniformValue = function() {
            glw[method](location, this.programValue[0], this.programValue[1], this.programValue[2], this.programValue[3]);
          };
          continue;
        }
      }
    }
  }
  bindProps(props) {
    var _a2;
    const effects = props.effects;
    const effectsL = effects.length;
    let i = 0;
    for (; i < effectsL; i++) {
      const effect2 = effects[i];
      const propKeys = Object.keys(effect2.props);
      const propsLength = propKeys.length;
      let j = 0;
      for (; j < propsLength; j++) {
        const key = propKeys[j];
        const prop = effect2.props[key];
        if (prop.updateOnBind === true) {
          const uniform = (_a2 = this.renderer.shManager.getRegisteredEffects()[effect2.type]) == null ? void 0 : _a2.uniforms[key];
          uniform == null ? void 0 : uniform.updateProgramValue(effect2.props[key], props);
        }
        prop.setUniformValue();
      }
    }
  }
  canBatchShaderProps(propsA, propsB) {
    if (propsA.$alpha !== propsB.$alpha || propsA.$dimensions.width !== propsB.$dimensions.width || propsA.$dimensions.height !== propsB.$dimensions.height || propsA.effects.length !== propsB.effects.length) {
      return false;
    }
    const propsEffectsLen = propsA.effects.length;
    let i = 0;
    for (; i < propsEffectsLen; i++) {
      const effectA = propsA.effects[i];
      const effectB = propsB.effects[i];
      if (effectA.type !== effectB.type) {
        return false;
      }
      for (const key in effectA.props) {
        if (effectB.props && !effectB.props[key] || effectA.props[key].value !== effectB.props[key].value) {
          return false;
        }
      }
    }
    return true;
  }
  static createShader(props, effectContructors) {
    const effectNameCount = {};
    const methods = {};
    let declareUniforms = "";
    const uniforms = [];
    const uFx = [];
    const effects = props.effects.map((effect2) => {
      const baseClass = effectContructors[effect2.type];
      const key = baseClass.getEffectKey(effect2.props || {});
      effectNameCount[key] = effectNameCount[key] ? ++effectNameCount[key] : 1;
      const nr = effectNameCount[key];
      if (nr === 1) {
        uFx.push({ key, type: effect2.type, props: effect2.props });
      }
      const fxClass = new baseClass({
        ref: `${key}${nr === 1 ? "" : nr}`,
        target: key,
        props: effect2.props
      });
      declareUniforms += fxClass.declaredUniforms;
      uniforms.push(...Object.values(fxClass.uniformInfo));
      return fxClass;
    });
    let effectMethods = "";
    uFx == null ? void 0 : uFx.forEach((fx) => {
      const fxClass = effectContructors[fx.type];
      const fxProps = fxClass.resolveDefaults(fx.props ?? {});
      const remap = [];
      for (const m in fxClass.methods) {
        let cm = m;
        const fxMethod = fxClass.methods[m];
        if (methods[m] && methods[m] !== fxMethod) {
          cm = _DynamicShader.resolveMethodDuplicate(m, fxMethod, methods);
        }
        methods[cm] = fxMethod.replace("function", cm);
        remap.push({ m, cm });
      }
      let onShaderMask = fxClass.onShaderMask instanceof Function ? fxClass.onShaderMask(fxProps) : fxClass.onShaderMask;
      let onColorize = fxClass.onColorize instanceof Function ? fxClass.onColorize(fxProps) : fxClass.onColorize;
      let onEffectMask = fxClass.onEffectMask instanceof Function ? fxClass.onEffectMask(fxProps) : fxClass.onEffectMask;
      remap.forEach((r) => {
        const { m, cm } = r;
        const reg = new RegExp(`\\$${m}`, "g");
        if (onShaderMask) {
          onShaderMask = onShaderMask.replace(reg, cm);
        }
        if (onColorize) {
          onColorize = onColorize.replace(reg, cm);
        }
        if (onEffectMask) {
          onEffectMask = onEffectMask.replace(reg, cm);
        }
      });
      const methodParameters = fxClass.getMethodParameters(fxClass.uniforms, fxProps);
      const pm = methodParameters.length > 0 ? `, ${methodParameters}` : "";
      if (onShaderMask) {
        effectMethods += `
        float fx_${fx.key}_onShaderMask(float shaderMask ${pm}) {
          ${onShaderMask}
        }
        `;
      }
      if (onColorize) {
        effectMethods += `
          vec4 fx_${fx.key}_onColorize(float shaderMask, vec4 maskColor, vec4 shaderColor${pm}) {
            ${onColorize}
          }
        `;
      }
      if (onEffectMask) {
        effectMethods += `
          vec4 fx_${fx.key}_onEffectMask(float shaderMask, vec4 maskColor, vec4 shaderColor${pm}) {
            ${onEffectMask}
          }
        `;
      }
    });
    let sharedMethods = "";
    for (const m in methods) {
      sharedMethods += methods[m];
    }
    let currentMask = `mix(shaderColor, maskColor, clamp(-(lng_DefaultMask), 0.0, 1.0))`;
    let drawEffects = `

    `;
    for (let i = 0; i < effects.length; i++) {
      const current = effects[i];
      const pm = current.passParameters.length > 0 ? `, ${current.passParameters}` : "";
      const currentClass = effectContructors[current.name];
      if (currentClass.onShaderMask) {
        drawEffects += `
        shaderMask = fx_${current.target}_onShaderMask(shaderMask ${pm});
        `;
      }
      if (currentClass.onColorize) {
        drawEffects += `
        maskColor = fx_${current.target}_onColorize(shaderMask, maskColor, shaderColor${pm});
        `;
      }
      if (currentClass.onEffectMask) {
        currentMask = `fx_${current.target}_onEffectMask(shaderMask, maskColor, shaderColor${pm})`;
      }
      const next = effects[i + 1];
      if (next === void 0 || effectContructors[next.name].onEffectMask) {
        drawEffects += `
          shaderColor = ${currentMask};
        `;
      }
    }
    return {
      effects,
      uniforms,
      fragment: _DynamicShader.fragment(declareUniforms, sharedMethods, effectMethods, drawEffects),
      vertex: _DynamicShader.vertex()
    };
  }
  static resolveMethodDuplicate(key, effectMethod, methodCollection, increment = 0) {
    const m = key + (increment > 0 ? increment : "");
    if (methodCollection[m] && methodCollection[m] !== effectMethod) {
      return this.resolveMethodDuplicate(key, effectMethod, methodCollection, ++increment);
    }
    return m;
  }
  static resolveDefaults(props, effectContructors) {
    assertTruthy(effectContructors);
    return {
      effects: getResolvedEffect(props.effects ?? [], effectContructors),
      $dimensions: {
        width: 0,
        height: 0
      },
      $alpha: 0
    };
  }
  static makeCacheKey(props, effectContructors) {
    var _a2;
    let fx = "";
    (_a2 = props.effects) == null ? void 0 : _a2.forEach((effect2) => {
      const baseClass = effectContructors[effect2.type];
      const key = baseClass.getEffectKey(effect2.props || {});
      fx += `,${key}`;
    });
    return `DynamicShader${fx}`;
  }
};
__publicField(_DynamicShader, "z$__type__Props");
__publicField(_DynamicShader, "vertex", () => `
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision mediump float;
    # endif

    attribute vec2 a_textureCoordinate;
    attribute vec2 a_position;
    attribute vec4 a_color;
    attribute float a_textureIndex;

    uniform vec2 u_resolution;
    uniform float u_pixelRatio;

    varying vec4 v_color;
    varying vec2 v_textureCoordinate;
    varying float v_textureIndex;

    void main(){
      vec2 normalized = a_position * u_pixelRatio / u_resolution;
      vec2 zero_two = normalized * 2.0;
      vec2 clip_space = zero_two - 1.0;

      // pass to fragment
      v_color = a_color;
      v_textureCoordinate = a_textureCoordinate;
      v_textureIndex = a_textureIndex;

      // flip y
      gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);
    }
  `);
__publicField(_DynamicShader, "fragment", (uniforms, methods, effectMethods, drawEffects) => `
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision mediump float;
    # endif

    #define PI 3.14159265359

    uniform vec2 u_resolution;
    uniform vec2 u_dimensions;
    uniform float u_alpha;
    uniform float u_radius;
    uniform sampler2D u_texture;
    uniform float u_pixelRatio;

    ${uniforms}

    varying vec4 v_color;
    varying vec2 v_textureCoordinate;

    ${methods}

    ${effectMethods}

    void main() {
      vec2 p = v_textureCoordinate.xy * u_dimensions - u_dimensions * 0.5;
      vec2 d = abs(p) - (u_dimensions) * 0.5;
      float lng_DefaultMask = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));

      vec4 shaderColor = vec4(0.0);
      float shaderMask = lng_DefaultMask;

      vec4 maskColor = texture2D(u_texture, v_textureCoordinate) * v_color;

      shaderColor = mix(shaderColor, maskColor, clamp(-(lng_DefaultMask + 0.5), 0.0, 1.0));

      ${drawEffects}

      gl_FragColor = shaderColor * u_alpha;
    }
  `);
var DynamicShader = _DynamicShader;

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/RoundedRectangle.js
var RoundedRectangle = class extends WebGlCoreShader {
  constructor(renderer3) {
    super({
      renderer: renderer3,
      attributes: ["a_position", "a_textureCoordinate", "a_color"],
      uniforms: [
        { name: "u_resolution", uniform: "uniform2fv" },
        { name: "u_pixelRatio", uniform: "uniform1f" },
        { name: "u_texture", uniform: "uniform2f" },
        { name: "u_dimensions", uniform: "uniform2fv" },
        { name: "u_radius", uniform: "uniform1f" }
      ]
    });
  }
  static resolveDefaults(props) {
    return {
      radius: props.radius || 10,
      $dimensions: {
        width: 0,
        height: 0
      }
    };
  }
  bindTextures(textures) {
    const { glw } = this;
    glw.activeTexture(0);
    glw.bindTexture(textures[0].ctxTexture);
  }
  bindProps(props) {
    const radiusFactor = Math.min(props.$dimensions.width, props.$dimensions.height) / (2 * props.radius);
    this.glw.uniform1f(this.getUniformLocation("u_radius"), props.radius * Math.min(radiusFactor, 1));
  }
  canBatchShaderProps(propsA, propsB) {
    return propsA.radius === propsB.radius && propsA.$dimensions.width === propsB.$dimensions.width && propsA.$dimensions.height === propsB.$dimensions.height;
  }
};
__publicField(RoundedRectangle, "z$__type__Props");
__publicField(RoundedRectangle, "shaderSources", {
  vertex: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      attribute vec2 a_position;
      attribute vec2 a_textureCoordinate;
      attribute vec4 a_color;
      attribute float a_textureIndex;
      attribute float a_depth;

      uniform vec2 u_resolution;
      uniform float u_pixelRatio;

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;

      void main() {
        vec2 normalized = a_position * u_pixelRatio / u_resolution;
        vec2 zero_two = normalized * 2.0;
        vec2 clip_space = zero_two - 1.0;

        // pass to fragment
        v_color = a_color;
        v_textureCoordinate = a_textureCoordinate;

        // flip y
        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);
      }
    `,
  fragment: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif

      uniform vec2 u_resolution;
      uniform vec2 u_dimensions;
      uniform float u_radius;
      uniform sampler2D u_texture;

      varying vec4 v_color;
      varying vec2 v_textureCoordinate;

      float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
      }

      float fillMask(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }

      void main() {
        vec4 color = texture2D(u_texture, v_textureCoordinate) * v_color;
        vec2 halfDimensions = u_dimensions * 0.5;

        float d = boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions + 0.5, u_radius);
        gl_FragColor = mix(vec4(0.0), color, fillMask(d));
      }
    `
});

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/SdfShader.js
var IDENTITY_MATRIX_3x3 = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
var _SdfShader = class _SdfShader extends WebGlCoreShader {
  constructor(renderer3) {
    super({
      renderer: renderer3,
      attributes: ["a_position", "a_textureCoordinate"],
      uniforms: [
        { name: "u_resolution", uniform: "uniform2fv" },
        { name: "u_transform", uniform: "uniformMatrix3fv" },
        { name: "u_scrollY", uniform: "uniform1f" },
        { name: "u_pixelRatio", uniform: "uniform1f" },
        { name: "u_texture", uniform: "uniform2f" },
        { name: "u_color", uniform: "uniform4fv" },
        { name: "u_size", uniform: "uniform1f" },
        { name: "u_distanceRange", uniform: "uniform1f" },
        { name: "u_debug", uniform: "uniform1i" }
      ]
    });
  }
  bindTextures(textures) {
    const { glw } = this;
    glw.activeTexture(0);
    glw.bindTexture(textures[0].ctxTexture);
  }
  bindProps(props) {
    const resolvedProps = _SdfShader.resolveDefaults(props);
    for (const key in resolvedProps) {
      if (key === "transform") {
        this.glw.uniformMatrix3fv(this.getUniformLocation("u_transform"), resolvedProps[key]);
      } else if (key === "scrollY") {
        this.glw.uniform1f(this.getUniformLocation("u_scrollY"), resolvedProps[key]);
      } else if (key === "color") {
        const components = getNormalizedRgbaComponents(resolvedProps.color);
        this.glw.uniform4fv(this.getUniformLocation("u_color"), components);
      } else if (key === "size") {
        this.glw.uniform1f(this.getUniformLocation("u_size"), resolvedProps[key]);
      } else if (key === "distanceRange") {
        this.glw.uniform1f(this.getUniformLocation("u_distanceRange"), resolvedProps[key]);
      } else if (key === "debug") {
        this.glw.uniform1i(this.getUniformLocation("u_debug"), resolvedProps[key] ? 1 : 0);
      }
    }
  }
  static resolveDefaults(props = {}) {
    return {
      transform: props.transform ?? IDENTITY_MATRIX_3x3,
      scrollY: props.scrollY ?? 0,
      color: props.color ?? 4294967295,
      size: props.size ?? 16,
      distanceRange: props.distanceRange ?? 1,
      debug: props.debug ?? false
    };
  }
};
__publicField(_SdfShader, "shaderSources", {
  vertex: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif
      // an attribute is an input (in) to a vertex shader.
      // It will receive data from a buffer
      attribute vec2 a_position;
      attribute vec2 a_textureCoordinate;

      uniform vec2 u_resolution;
      uniform mat3 u_transform;
      uniform float u_scrollY;
      uniform float u_pixelRatio;
      uniform float u_size;

      varying vec2 v_texcoord;

      void main() {
        vec2 scrolledPosition = a_position * u_size - vec2(0, u_scrollY);
        vec2 transformedPosition = (u_transform * vec3(scrolledPosition, 1)).xy;

        // Calculate screen space with pixel ratio
        vec2 screenSpace = (transformedPosition * u_pixelRatio / u_resolution * 2.0 - 1.0) * vec2(1, -1);

        gl_Position = vec4(screenSpace, 0.0, 1.0);
        v_texcoord = a_textureCoordinate;

      }
    `,
  fragment: `
      # ifdef GL_FRAGMENT_PRECISION_HIGH
      precision highp float;
      # else
      precision mediump float;
      # endif
      uniform vec4 u_color;
      uniform sampler2D u_texture;
      uniform float u_distanceRange;
      uniform float u_pixelRatio;
      uniform int u_debug;

      varying vec2 v_texcoord;

      float median(float r, float g, float b) {
          return max(min(r, g), min(max(r, g), b));
      }

      void main() {
          vec3 sample = texture2D(u_texture, v_texcoord).rgb;
          if (u_debug == 1) {
            gl_FragColor = vec4(sample.r, sample.g, sample.b, 1.0);
            return;
          }
          float scaledDistRange = u_distanceRange * u_pixelRatio;
          float sigDist = scaledDistRange * (median(sample.r, sample.g, sample.b) - 0.5);
          float opacity = clamp(sigDist + 0.5, 0.0, 1.0) * u_color.a;

          // Build the final color.
          // IMPORTANT: We must premultiply the color by the alpha value before returning it.
          gl_FragColor = vec4(u_color.r * opacity, u_color.g * opacity, u_color.b * opacity, opacity);
      }
    `
});
var SdfShader = _SdfShader;

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/EffectUtils.js
var updateShaderEffectColor = (values) => {
  if (values.programValue === void 0) {
    values.programValue = new Float32Array(4);
  }
  const rgba2 = values.value;
  const floatArray = values.programValue;
  floatArray[0] = (rgba2 >>> 24) / 255;
  floatArray[1] = (rgba2 >>> 16 & 255) / 255;
  floatArray[2] = (rgba2 >>> 8 & 255) / 255;
  floatArray[3] = (rgba2 & 255) / 255;
};
var updateFloat32ArrayLength2 = (values) => {
  const validatedValue = values.validatedValue || values.value;
  if (values.programValue instanceof Float32Array) {
    const floatArray = values.programValue;
    floatArray[0] = validatedValue[0];
    floatArray[1] = validatedValue[1];
  } else {
    values.programValue = new Float32Array(validatedValue);
  }
};
var updateFloat32ArrayLength4 = (values) => {
  const validatedValue = values.validatedValue || values.value;
  if (values.programValue instanceof Float32Array) {
    const floatArray = values.programValue;
    floatArray[0] = validatedValue[0];
    floatArray[1] = validatedValue[1];
    floatArray[2] = validatedValue[1];
    floatArray[3] = validatedValue[1];
  } else {
    values.programValue = new Float32Array(validatedValue);
  }
};
var updateFloat32ArrayLengthN = (values) => {
  const validatedValue = values.validatedValue || values.value;
  if (values.programValue instanceof Float32Array) {
    const len = validatedValue.length;
    const programValue = values.programValue;
    for (let i = 0; i < len; i++) {
      programValue[i] = validatedValue[i];
    }
  } else {
    values.programValue = new Float32Array(validatedValue);
  }
};
var validateArrayLength4 = (value) => {
  const isArray = Array.isArray(value);
  if (!isArray) {
    return [value, value, value, value];
  } else if (isArray && value.length === 4) {
    return value;
  } else if (isArray && value.length === 2) {
    return [value[0], value[1], value[0], value[1]];
  } else if (isArray && value.length === 3) {
    return [value[0], value[1], value[2], value[0]];
  }
  return [value[0], value[0], value[0], value[0]];
};
var updateWebSafeRadius = (values, shaderProps) => {
  if (values.programValue === void 0) {
    values.programValue = new Float32Array(4);
  }
  const programValue = values.programValue;
  const validatedValue = values.validatedValue || values.value;
  if (shaderProps === void 0 && values.$dimensions === void 0) {
    programValue[0] = validatedValue[0];
    programValue[1] = validatedValue[1];
    programValue[2] = validatedValue[2];
    programValue[3] = validatedValue[3];
    return;
  }
  let storedDimensions = values.$dimensions;
  if (shaderProps !== void 0) {
    const { $dimensions } = shaderProps;
    if (storedDimensions !== void 0 && (storedDimensions.width === $dimensions.width || storedDimensions.height === $dimensions.height)) {
      return;
    }
    if (storedDimensions === void 0) {
      storedDimensions = {
        width: $dimensions == null ? void 0 : $dimensions.width,
        height: $dimensions == null ? void 0 : $dimensions.height
      };
      values.$dimensions = storedDimensions;
    }
  }
  const { width, height } = storedDimensions;
  const [r0, r1, r2, r3] = validatedValue;
  const factor = Math.min(Math.min(Math.min(width / Math.max(width, r0 + r1), width / Math.max(width, r2 + r3)), Math.min(height / Math.max(height, r0 + r2), height / Math.max(height, r1 + r3))), 1);
  programValue[0] = r0 * factor;
  programValue[1] = r1 * factor;
  programValue[2] = r2 * factor;
  programValue[3] = r3 * factor;
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/RadiusEffect.js
var RadiusEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "radius");
  }
  static getEffectKey() {
    return `radius`;
  }
  static resolveDefaults(props) {
    return {
      radius: props.radius ?? 10
    };
  }
};
__publicField(RadiusEffect, "z$__type__Props");
__publicField(RadiusEffect, "uniforms", {
  radius: {
    value: 0,
    method: "uniform4fv",
    type: "vec4",
    updateOnBind: true,
    validator: validateArrayLength4,
    updateProgramValue: updateWebSafeRadius
  }
});
__publicField(RadiusEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  boxDist: `
      float function(vec2 p, vec2 size, float radius) {
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
      }
    `
});
__publicField(RadiusEffect, "onShaderMask", `
  vec2 halfDimensions = u_dimensions * 0.5;
  float r = radius[0] * step(v_textureCoordinate.x, 0.5) * step(v_textureCoordinate.y, 0.5);
  r = r + radius[1] * step(0.5, v_textureCoordinate.x) * step(v_textureCoordinate.y, 0.5);
  r = r + radius[2] * step(0.5, v_textureCoordinate.x) * step(0.5, v_textureCoordinate.y);
  r = r + radius[3] * step(v_textureCoordinate.x, 0.5) * step(0.5, v_textureCoordinate.y);
  return $boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions, r);
  `);
__publicField(RadiusEffect, "onEffectMask", `
  return mix(vec4(0.0), maskColor, $fillMask(shaderMask));
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderEffect.js
var BorderEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "border");
  }
  static getEffectKey() {
    return `border`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderEffect, "z$__type__Props");
__publicField(BorderEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderEffect, "onEffectMask", `
  float intR = shaderMask + 1.0;
  float mask = clamp(intR + width, 0.0, 1.0) - clamp(intR, 0.0, 1.0);
  return mix(shaderColor, mix(shaderColor, maskColor, maskColor.a), mask);
  `);
__publicField(BorderEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/LinearGradientEffect.js
var _LinearGradientEffect = class _LinearGradientEffect extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "linearGradient");
  }
  static getEffectKey(props) {
    if (props.colors.value) {
      return `linearGradient${props.colors.value.length}`;
    }
    return `linearGradient${props.colors.length}`;
  }
  static resolveDefaults(props) {
    const colors = props.colors ?? [4278190080, 4294967295];
    let stops = props.stops || [];
    if (stops.length === 0 || stops.length !== colors.length) {
      const colorsL = colors.length;
      let i = 0;
      const tmp = stops;
      for (; i < colorsL; i++) {
        if (stops[i]) {
          tmp[i] = stops[i];
          if (stops[i - 1] === void 0 && tmp[i - 2] !== void 0) {
            tmp[i - 1] = tmp[i - 2] + (stops[i] - tmp[i - 2]) / 2;
          }
        } else {
          tmp[i] = i * (1 / (colors.length - 1));
        }
      }
      stops = tmp;
    }
    return {
      colors,
      stops,
      angle: props.angle ?? 0
    };
  }
};
__publicField(_LinearGradientEffect, "z$__type__Props");
__publicField(_LinearGradientEffect, "uniforms", {
  angle: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  colors: {
    value: 4294967295,
    validator: (rgbas) => {
      return rgbas.reduce((acc, val) => acc.concat(getNormalizedRgbaComponents(val)), []);
    },
    updateProgramValue: updateFloat32ArrayLengthN,
    size: (props) => props.colors.length,
    method: "uniform4fv",
    type: "vec4"
  },
  stops: {
    value: [],
    size: (props) => props.colors.length,
    method: "uniform1fv",
    type: "float"
  }
});
__publicField(_LinearGradientEffect, "methods", {
  fromLinear: `
      vec4 function(vec4 linearRGB) {
        vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);
        vec4 lower = linearRGB * vec4(12.92);
        return mix(higher, lower, 1.0);
      }
    `,
  toLinear: `
      vec4 function(vec4 sRGB) {
        vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
        vec4 lower = sRGB/vec4(12.92);
        return mix(higher, lower, 1.0);
      }
    `,
  calcPoint: `
      vec2 function(float d, float angle) {
        return d * vec2(cos(angle), sin(angle)) + (u_dimensions * 0.5);
      }
    `
});
__publicField(_LinearGradientEffect, "ColorLoop", (amount) => {
  let loop = "";
  for (let i = 2; i < amount; i++) {
    loop += `colorOut = mix(colorOut, colors[${i}], clamp((dist - stops[${i - 1}]) / (stops[${i}] - stops[${i - 1}]), 0.0, 1.0));`;
  }
  return loop;
});
__publicField(_LinearGradientEffect, "onColorize", (props) => {
  const colors = props.colors.length || 1;
  return `
      float a = angle - (PI / 180.0 * 90.0);
      float lineDist = abs(u_dimensions.x * cos(a)) + abs(u_dimensions.y * sin(a));
      vec2 f = $calcPoint(lineDist * 0.5, a);
      vec2 t = $calcPoint(lineDist * 0.5, a + PI);
      vec2 gradVec = t - f;
      float dist = dot(v_textureCoordinate.xy * u_dimensions - f, gradVec) / dot(gradVec, gradVec);

      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);
      vec4 colorOut = $fromLinear(mix($toLinear(colors[0]), $toLinear(colors[1]), stopCalc));
      ${_LinearGradientEffect.ColorLoop(colors)}
      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));
    `;
});
var LinearGradientEffect = _LinearGradientEffect;

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/GrayscaleEffect.js
var GrayscaleEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "grayscale");
  }
  static getEffectKey() {
    return `grayscale`;
  }
  static resolveDefaults(props) {
    return {
      amount: props.amount ?? 1
    };
  }
};
__publicField(GrayscaleEffect, "uniforms", {
  amount: {
    value: 1,
    method: "uniform1f",
    type: "float"
  }
});
__publicField(GrayscaleEffect, "onColorize", `
    float grayness = 0.2 * maskColor.r + 0.6 * maskColor.g + 0.2 * maskColor.b;
    return vec4(amount * vec3(grayness) + (1.0 - amount) * maskColor.rgb, maskColor.a);
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderRightEffect.js
var BorderRightEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "borderRight");
  }
  static getEffectKey() {
    return `borderRight`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderRightEffect, "z$__type__Props");
__publicField(BorderRightEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderRightEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  rectDist: `
      float function(vec2 p, vec2 size) {
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
    `
});
__publicField(BorderRightEffect, "onEffectMask", `
  vec2 pos = vec2(u_dimensions.x - width * 0.5, 0.0);
  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));
  return mix(shaderColor, maskColor, $fillMask(mask));
  `);
__publicField(BorderRightEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderTopEffect.js
var BorderTopEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "borderTop");
  }
  static getEffectKey() {
    return `borderTop`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderTopEffect, "z$__type__Props");
__publicField(BorderTopEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderTopEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  rectDist: `
      float function(vec2 p, vec2 size) {
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
    `
});
__publicField(BorderTopEffect, "onEffectMask", `
  vec2 pos = vec2(0.0, width * 0.5);
  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));
  return mix(shaderColor, maskColor, $fillMask(mask));
  `);
__publicField(BorderTopEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderBottomEffect.js
var BorderBottomEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "borderBottom");
  }
  static getEffectKey() {
    return `borderBottom`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderBottomEffect, "z$__type__Props");
__publicField(BorderBottomEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderBottomEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  rectDist: `
      float function(vec2 p, vec2 size) {
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
    `
});
__publicField(BorderBottomEffect, "onEffectMask", `
  vec2 pos = vec2(0.0, u_dimensions.y - width * 0.5);
  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));
  return mix(shaderColor, maskColor, $fillMask(mask));
  `);
__publicField(BorderBottomEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/BorderLeftEffect.js
var BorderLeftEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "borderLeft");
  }
  static getEffectKey() {
    return `borderLeft`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(BorderLeftEffect, "z$__type__Props");
__publicField(BorderLeftEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(BorderLeftEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  rectDist: `
      float function(vec2 p, vec2 size) {
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
      }
    `
});
__publicField(BorderLeftEffect, "onEffectMask", `
  vec2 pos = vec2(width * 0.5, 0.0);
  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));
  return mix(shaderColor, maskColor, $fillMask(mask));
  `);
__publicField(BorderLeftEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/GlitchEffect.js
var GlitchEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "glitch");
  }
  static getEffectKey(props) {
    return `glitch`;
  }
  static resolveDefaults(props) {
    return {
      amplitude: props.amplitude ?? 0.2,
      narrowness: props.narrowness ?? 4,
      blockiness: props.blockiness ?? 2,
      minimizer: props.minimizer ?? 8,
      time: props.time ?? Date.now()
    };
  }
};
__publicField(GlitchEffect, "z$__type__Props");
__publicField(GlitchEffect, "uniforms", {
  amplitude: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  narrowness: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  blockiness: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  minimizer: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  time: {
    value: 0,
    method: "uniform1f",
    updateOnBind: true,
    updateProgramValue: (values) => {
      const value = values.value = (Date.now() - values.value) % 1e3;
      values.programValue = value;
    },
    type: "float"
  }
});
__publicField(GlitchEffect, "methods", {
  rand: `
      float function(vec2 p, float time) {
        float t = floor(time * 20.) / 10.;
        return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);
      }
    `,
  noise: `
      float function(vec2 uv, float blockiness, float time) {
        vec2 lv = fract(uv);
        vec2 id = floor(uv);

        float n1 = rand(id, time);
        float n2 = rand(id+vec2(1,0), time);
        float n3 = rand(id+vec2(0,1), time);
        float n4 = rand(id+vec2(1,1), time);
        vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);
        return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);
      }
    `,
  fbm: `
      float function(vec2 uv, int count, float blockiness, float complexity, float time) {
        float val = 0.0;
        float amp = 0.5;
        const int MAX_ITERATIONS = 10;

        for(int i = 0; i < MAX_ITERATIONS; i++) {
          if(i >= count) {break;}
          val += amp * noise(uv, blockiness, time);
          amp *= 0.5;
          uv *= complexity;
        }
        return val;
      }
    `
});
__publicField(GlitchEffect, "onColorize", `
    vec2 uv = v_textureCoordinate.xy;
    float aspect = u_dimensions.x / u_dimensions.y;
    vec2 a = vec2(uv.x * aspect , uv.y);
    vec2 uv2 = vec2(a.x / u_dimensions.x, exp(a.y));

    float shift = amplitude * pow($fbm(uv2, 4, blockiness, narrowness, time), minimizer);
    float colR = texture2D(u_texture, vec2(uv.x + shift, uv.y)).r * (1. - shift);
    float colG = texture2D(u_texture, vec2(uv.x - shift, uv.y)).g * (1. - shift);
    float colB = texture2D(u_texture, vec2(uv.x - shift, uv.y)).b * (1. - shift);

    vec3 f = vec3(colR, colG, colB);
    return vec4(f, texture2D(u_texture, vec2(uv.x - shift, uv.y)).a);
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/FadeOutEffect.js
var FadeOutEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "fadeOut");
  }
  static getEffectKey() {
    return `fadeOut`;
  }
  static resolveDefaults(props) {
    return {
      fade: props.fade ?? 10
    };
  }
};
__publicField(FadeOutEffect, "z$__type__Props");
__publicField(FadeOutEffect, "uniforms", {
  fade: {
    value: 0,
    method: "uniform4fv",
    type: "vec4",
    validator: validateArrayLength4,
    updateProgramValue: updateFloat32ArrayLength4
  }
});
__publicField(FadeOutEffect, "onColorize", `
  vec2 point = v_textureCoordinate.xy * u_dimensions.xy;
  vec2 pos1;
  vec2 pos2;
  vec2 d;
  float c;
  vec4 result = maskColor;


  if(fade[0] > 0.0) {
    pos1 = vec2(point.x, point.y);
    pos2 = vec2(point.x, point.y + fade[0]);
    d = pos2 - pos1;
    c = dot(pos1, d) / dot(d, d);
    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));
  }

  if(fade[1] > 0.0) {
    pos1 = vec2(point.x - u_dimensions.x - fade[1], v_textureCoordinate.y);
    pos2 = vec2(point.x - u_dimensions.x, v_textureCoordinate.y);
    d = pos1 - pos2;
    c = dot(pos2, d) / dot(d, d);
    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));
  }

  if(fade[2] > 0.0) {
    pos1 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y - fade[2]);
    pos2 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y);
    d = pos1 - pos2;
    c = dot(pos2, d) / dot(d, d);
    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));
  }

  if(fade[3] > 0.0) {
    pos1 = vec2(point.x, point.y);
    pos2 = vec2(point.x + fade[3], point.y);
    d = pos2 - pos1;
    c = dot(pos1, d) / dot(d, d);
    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));
  }

  return result;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/RadialGradientEffect.js
var _RadialGradientEffect = class _RadialGradientEffect extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "radialGradient");
  }
  static getEffectKey(props) {
    if (props.colors.value) {
      return `linearGradient${props.colors.value.length}`;
    }
    return `linearGradient${props.colors.length}`;
  }
  static resolveDefaults(props) {
    const colors = props.colors ?? [4278190080, 4294967295];
    let stops = props.stops || [];
    if (stops.length === 0 || stops.length !== colors.length) {
      const colorsL = colors.length;
      let i = 0;
      const tmp = stops;
      for (; i < colorsL; i++) {
        if (stops[i]) {
          tmp[i] = stops[i];
          if (stops[i - 1] === void 0 && tmp[i - 2] !== void 0) {
            tmp[i - 1] = tmp[i - 2] + (stops[i] - tmp[i - 2]) / 2;
          }
        } else {
          tmp[i] = i * (1 / (colors.length - 1));
        }
      }
      stops = tmp;
    }
    return {
      colors,
      stops,
      width: props.width ?? 0,
      height: props.height ?? props.width ?? 0,
      pivot: props.pivot ?? [0.5, 0.5]
    };
  }
};
__publicField(_RadialGradientEffect, "z$__type__Props");
__publicField(_RadialGradientEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  height: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  pivot: {
    value: [0.5, 0.5],
    updateProgramValue: updateFloat32ArrayLength2,
    method: "uniform2fv",
    type: "vec2"
  },
  colors: {
    value: 4294967295,
    validator: (rgbas) => {
      return rgbas.reduce((acc, val) => acc.concat(getNormalizedRgbaComponents(val)), []);
    },
    updateProgramValue: updateFloat32ArrayLengthN,
    size: (props) => props.colors.length,
    method: "uniform4fv",
    type: "vec4"
  },
  stops: {
    value: [],
    size: (props) => props.colors.length,
    method: "uniform1fv",
    type: "float"
  }
});
__publicField(_RadialGradientEffect, "ColorLoop", (amount) => {
  let loop = "";
  for (let i = 2; i < amount; i++) {
    loop += `colorOut = mix(colorOut, colors[${i}], clamp((dist - stops[${i - 1}]) / (stops[${i}] - stops[${i - 1}]), 0.0, 1.0));`;
  }
  return loop;
});
__publicField(_RadialGradientEffect, "onColorize", (props) => {
  const colors = props.colors.length || 1;
  return `
      vec2 point = v_textureCoordinate.xy * u_dimensions;
      vec2 projection = vec2(pivot.x * u_dimensions.x, pivot.y * u_dimensions.y);

      float dist = length((point - projection) / vec2(width, height));

      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);
      vec4 colorOut = mix(colors[0], colors[1], stopCalc);
      ${_RadialGradientEffect.ColorLoop(colors)}
      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));
    `;
});
var RadialGradientEffect = _RadialGradientEffect;

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/RadialProgressEffect.js
var RadialProgressEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "radialProgress");
  }
  static getEffectKey() {
    return `radialProgress`;
  }
  static resolveDefaults(props) {
    return {
      width: props.width ?? 10,
      progress: props.progress ?? 0.5,
      offset: props.offset ?? 0,
      range: props.range ?? Math.PI * 2,
      rounded: props.rounded ?? false,
      radius: props.radius ?? 1,
      color: props.color ?? 4294967295
    };
  }
};
__publicField(RadialProgressEffect, "z$__type__Props");
__publicField(RadialProgressEffect, "uniforms", {
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  progress: {
    value: 0.5,
    method: "uniform1f",
    type: "float"
  },
  offset: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  range: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  rounded: {
    value: 0,
    method: "uniform1f",
    type: "float",
    validator: (value) => {
      return value ? 1 : 0;
    }
  },
  radius: {
    value: 1,
    method: "uniform1f",
    type: "float"
  },
  color: {
    value: 4294967295,
    updateProgramValue: updateShaderEffectColor,
    method: "uniform4fv",
    type: "vec4"
  }
});
__publicField(RadialProgressEffect, "methods", {
  rotateUV: `
    vec2 function(vec2 uv, float d) {
      float s = sin(d);
      float c = cos(d);
      mat2 rotMatrix = mat2(c, -s, s, c);
      return uv * rotMatrix;
    }
    `,
  drawDot: `
    float function(vec2 uv, vec2 p, float r) {
      uv += p;
      float circle = length(uv) - r;
      return clamp(-circle, 0.0, 1.0);
    }
    `
});
__publicField(RadialProgressEffect, "onEffectMask", `
    float outerRadius = radius * u_dimensions.y * 0.5;

    float endAngle = range * progress - 0.0005;

    vec2 uv = v_textureCoordinate.xy * u_dimensions.xy - u_dimensions * 0.5;

    uv = $rotateUV(uv, -(offset));
    float linewidth = width * u_pixelRatio;
    float circle = length(uv) - (outerRadius - linewidth) ;
    circle = abs(circle) - linewidth;
    circle = clamp(-circle, 0.0, 1.0);

    float angle = (atan(uv.x, -uv.y) / 3.14159265359 * 0.5);
    float p = endAngle / (PI * 2.);

    circle *= step(fract(angle), fract(p));

    circle = rounded < 1. ? circle : max(circle, $drawDot(uv, vec2(0, outerRadius - linewidth), linewidth));
    circle = rounded < 1. ? circle : max(circle, $drawDot($rotateUV(uv, -(endAngle)), vec2(0, outerRadius - linewidth), linewidth));

    return mix(shaderColor, maskColor, circle);
  `);
__publicField(RadialProgressEffect, "onColorize", `
    return color;
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/shaders/effects/HolePunchEffect.js
var HolePunchEffect = class extends ShaderEffect {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "holePunch");
  }
  static getEffectKey() {
    return `holePunch`;
  }
  static resolveDefaults(props) {
    return {
      x: props.x || 0,
      y: props.y || 0,
      width: props.width || 50,
      height: props.height || 50,
      radius: props.radius ?? 0
    };
  }
};
__publicField(HolePunchEffect, "z$__type__Props");
__publicField(HolePunchEffect, "uniforms", {
  x: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  y: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  width: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  height: {
    value: 0,
    method: "uniform1f",
    type: "float"
  },
  radius: {
    value: 0,
    method: "uniform4fv",
    type: "vec4",
    updateOnBind: true,
    validator: validateArrayLength4,
    updateProgramValue: updateWebSafeRadius
  }
});
__publicField(HolePunchEffect, "methods", {
  fillMask: `
      float function(float dist) {
        return clamp(-dist, 0.0, 1.0);
      }
    `,
  boxDist: `
      float function(vec2 p, vec2 size, float radius) {
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
      }
    `
});
__publicField(HolePunchEffect, "onShaderMask", `
  vec2 halfDimensions = u_dimensions * 0.5;
  vec2 size = vec2(width, height) * 0.5;
  vec2 basePos = v_textureCoordinate.xy * u_dimensions.xy - vec2(x, y);
  vec2 pos = basePos - size;
  float r = radius[0] * step(pos.x, 0.5) * step(pos.y, 0.5);
  r = r + radius[1] * step(0.5, pos.x) * step(pos.y, 0.5);
  r = r + radius[2] * step(0.5, pos.x) * step(0.5, pos.y);
  r = r + radius[3] * step(pos.x, 0.5) * step(0.5, pos.y);
  return $boxDist(pos, size, r);
  `);
__publicField(HolePunchEffect, "onEffectMask", `
  return mix(maskColor, vec4(0.0), $fillMask(shaderMask));
  `);

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/shaders/UnsupportedShader.js
var ROUNDED_RECTANGLE_SHADER_TYPE = "RoundedRectangle";
var UnsupportedShader = class extends CoreShader {
  constructor(shType) {
    super();
    __publicField(this, "shType");
    this.shType = shType;
  }
  bindRenderOp() {
  }
  bindProps() {
  }
  attach() {
  }
  detach() {
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/ShaderController.js
var ShaderController = class {
  constructor(type, shader, props, stage2) {
    __publicField(this, "type");
    __publicField(this, "shader");
    __publicField(this, "resolvedProps");
    __publicField(this, "props");
    this.type = type;
    this.shader = shader;
    this.resolvedProps = props;
    const keys = Object.keys(props);
    const l = keys.length;
    const definedProps = {};
    for (let i = 0; i < l; i++) {
      const name = keys[i];
      Object.defineProperty(definedProps, name, {
        get: () => {
          return this.resolvedProps[name];
        },
        set: (value) => {
          this.resolvedProps[name] = value;
          stage2.requestRender();
        }
      });
    }
    this.props = definedProps;
  }
  getResolvedProps() {
    return this.resolvedProps;
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/DynamicShaderController.js
var DynamicShaderController = class {
  constructor(shader, props, shManager) {
    __publicField(this, "shader");
    __publicField(this, "resolvedProps");
    __publicField(this, "props");
    __publicField(this, "type");
    this.shader = shader;
    this.type = "DynamicShader";
    this.resolvedProps = props;
    const effectConstructors = shManager.getRegisteredEffects();
    const definedProps = {};
    const effects = props.effects;
    const effectsLength = effects.length;
    for (let i = 0; i < effectsLength; i++) {
      const { name: effectName, props: effectProps, type: effectType } = effects[i];
      if (effectName === void 0) {
        continue;
      }
      const definedEffectProps = {};
      const propEntries = Object.keys(effectProps);
      const propEntriesLength = propEntries.length;
      for (let j = 0; j < propEntriesLength; j++) {
        const propName = propEntries[j];
        Object.defineProperty(definedEffectProps, propName, {
          get: () => {
            return this.resolvedProps.effects[i].props[propName].value;
          },
          set: (value) => {
            var _a2, _b;
            const target = this.resolvedProps.effects[i].props[propName];
            target.value = value;
            if (target.hasValidator) {
              value = target.validatedValue = (_a2 = effectConstructors[effectType].uniforms[propName]) == null ? void 0 : _a2.validator(value, effectProps);
            }
            if (target.hasProgramValueUpdater) {
              (_b = effectConstructors[effectType].uniforms[propName]) == null ? void 0 : _b.updateProgramValue(target);
            } else {
              target.programValue = value;
            }
            shManager.renderer.stage.requestRender();
          }
        });
      }
      Object.defineProperty(definedProps, effectName, {
        get: () => {
          return definedEffectProps;
        }
      });
    }
    this.props = definedProps;
  }
  getResolvedProps() {
    return this.resolvedProps;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/CoreShaderManager.js
var CoreShaderManager = class {
  constructor() {
    __publicField(this, "shCache", /* @__PURE__ */ new Map());
    __publicField(this, "shConstructors", {});
    __publicField(this, "attachedShader", null);
    __publicField(this, "effectConstructors", {});
    __publicField(this, "renderer");
    this.registerShaderType("DefaultShader", DefaultShader);
    this.registerShaderType("DefaultShaderBatched", DefaultShaderBatched);
    this.registerShaderType("RoundedRectangle", RoundedRectangle);
    this.registerShaderType("DynamicShader", DynamicShader);
    this.registerShaderType("SdfShader", SdfShader);
    this.registerEffectType("border", BorderEffect);
    this.registerEffectType("borderBottom", BorderBottomEffect);
    this.registerEffectType("borderLeft", BorderLeftEffect);
    this.registerEffectType("borderRight", BorderRightEffect);
    this.registerEffectType("borderTop", BorderTopEffect);
    this.registerEffectType("fadeOut", FadeOutEffect);
    this.registerEffectType("linearGradient", LinearGradientEffect);
    this.registerEffectType("radialGradient", RadialGradientEffect);
    this.registerEffectType("grayscale", GrayscaleEffect);
    this.registerEffectType("glitch", GlitchEffect);
    this.registerEffectType("radius", RadiusEffect);
    this.registerEffectType("radialProgress", RadialProgressEffect);
    this.registerEffectType("holePunch", HolePunchEffect);
  }
  registerShaderType(shType, shClass) {
    this.shConstructors[shType] = shClass;
  }
  registerEffectType(effectType, effectClass) {
    this.effectConstructors[effectType] = effectClass;
  }
  getRegisteredEffects() {
    return this.effectConstructors;
  }
  getRegisteredShaders() {
    return this.shConstructors;
  }
  /**
   * Loads a shader (if not already loaded) and returns a controller for it.
   *
   * @param shType
   * @param props
   * @returns
   */
  loadShader(shType, props) {
    if (!this.renderer) {
      throw new Error(`Renderer is not been defined`);
    }
    const ShaderClass = this.shConstructors[shType];
    if (!ShaderClass) {
      throw new Error(`Shader type "${shType}" is not registered`);
    }
    if (this.renderer.mode === "canvas" && ShaderClass.prototype instanceof WebGlCoreShader) {
      return this._createShaderCtr(shType, new UnsupportedShader(shType), props);
    }
    if (shType === "DynamicShader") {
      return this.loadDynamicShader(props);
    }
    const resolvedProps = ShaderClass.resolveDefaults(props);
    const cacheKey = ShaderClass.makeCacheKey(resolvedProps) || ShaderClass.name;
    if (cacheKey && this.shCache.has(cacheKey)) {
      return this._createShaderCtr(shType, this.shCache.get(cacheKey), resolvedProps);
    }
    const shader = new ShaderClass(this.renderer, props);
    if (cacheKey) {
      this.shCache.set(cacheKey, shader);
    }
    return this._createShaderCtr(shType, shader, resolvedProps);
  }
  loadDynamicShader(props) {
    if (!this.renderer) {
      throw new Error(`Renderer is not been defined`);
    }
    const resolvedProps = DynamicShader.resolveDefaults(props, this.effectConstructors);
    const cacheKey = DynamicShader.makeCacheKey(resolvedProps, this.effectConstructors);
    if (cacheKey && this.shCache.has(cacheKey)) {
      return this._createDynShaderCtr(this.shCache.get(cacheKey), resolvedProps);
    }
    const shader = new DynamicShader(this.renderer, props, this.effectConstructors);
    if (cacheKey) {
      this.shCache.set(cacheKey, shader);
    }
    return this._createDynShaderCtr(shader, resolvedProps);
  }
  _createShaderCtr(type, shader, props) {
    return new ShaderController(type, shader, props, this.renderer.stage);
  }
  _createDynShaderCtr(shader, props) {
    shader.bindUniformMethods(props);
    return new DynamicShaderController(shader, props, this);
  }
  useShader(shader) {
    if (this.attachedShader === shader) {
      return;
    }
    if (this.attachedShader) {
      this.attachedShader.detach();
    }
    shader.attach();
    this.attachedShader = shader;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/TextRenderer.js
var trPropSetterDefaults = {
  x: (state, value) => {
    state.props.x = value;
  },
  y: (state, value) => {
    state.props.y = value;
  },
  width: (state, value) => {
    state.props.width = value;
  },
  height: (state, value) => {
    state.props.height = value;
  },
  color: (state, value) => {
    state.props.color = value;
  },
  zIndex: (state, value) => {
    state.props.zIndex = value;
  },
  fontFamily: (state, value) => {
    state.props.fontFamily = value;
  },
  fontWeight: (state, value) => {
    state.props.fontWeight = value;
  },
  fontStyle: (state, value) => {
    state.props.fontStyle = value;
  },
  fontStretch: (state, value) => {
    state.props.fontStretch = value;
  },
  fontSize: (state, value) => {
    state.props.fontSize = value;
  },
  text: (state, value) => {
    state.props.text = value;
  },
  textAlign: (state, value) => {
    state.props.textAlign = value;
  },
  contain: (state, value) => {
    state.props.contain = value;
  },
  offsetY: (state, value) => {
    state.props.offsetY = value;
  },
  scrollable: (state, value) => {
    state.props.scrollable = value;
  },
  scrollY: (state, value) => {
    state.props.scrollY = value;
  },
  letterSpacing: (state, value) => {
    state.props.letterSpacing = value;
  },
  lineHeight: (state, value) => {
    state.props.lineHeight = value;
  },
  maxLines: (state, value) => {
    state.props.maxLines = value;
  },
  textBaseline: (state, value) => {
    state.props.textBaseline = value;
  },
  verticalAlign: (state, value) => {
    state.props.verticalAlign = value;
  },
  overflowSuffix: (state, value) => {
    state.props.overflowSuffix = value;
  },
  debug: (state, value) => {
    state.props.debug = value;
  }
};
var TextRenderer = class {
  constructor(stage2) {
    __publicField(this, "stage");
    __publicField(this, "set");
    this.stage = stage2;
    const propSetters = {
      ...trPropSetterDefaults,
      ...this.getPropertySetters()
    };
    const propSet = {};
    Object.keys(propSetters).forEach((key) => {
      Object.defineProperty(propSet, key, {
        value: (state, value) => {
          if (state.props[key] !== value) {
            propSetters[key](state, value);
            this.stage.requestRender();
          }
        },
        writable: false,
        configurable: false
        // Prevents property from being deleted
      });
    });
    this.set = propSet;
  }
  setStatus(state, status, error) {
    if (state.status === status) {
      return;
    }
    state.status = status;
    state.emitter.emit(status, error);
  }
  /**
   * Allows the CoreTextNode to communicate changes to the isRenderable state of
   * the itself.
   *
   * @param state
   * @param renderable
   */
  setIsRenderable(state, renderable) {
    state.isRenderable = renderable;
  }
  /**
   * Destroy/Clean up the state object
   *
   * @remarks
   * Opposite of createState(). Frees any event listeners / resources held by
   * the state that may not reliably get garbage collected.
   *
   * @param state
   */
  destroyState(state) {
    this.setStatus(state, "destroyed");
    state.emitter.removeAllListeners();
  }
  /**
   * Schedule a state update via queueMicrotask
   *
   * @remarks
   * This method is used to schedule a state update via queueMicrotask. This
   * method should be called whenever a state update is needed, and it will
   * ensure that the state is only updated once per microtask.
   * @param state
   * @returns
   */
  scheduleUpdateState(state) {
    if (state.updateScheduled) {
      return;
    }
    state.updateScheduled = true;
    queueMicrotask(() => {
      if (state.status === "destroyed") {
        return;
      }
      state.updateScheduled = false;
      this.updateState(state);
    });
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/lib/ContextSpy.js
var ContextSpy = class {
  constructor() {
    __publicField(this, "data", {});
  }
  reset() {
    this.data = {};
  }
  increment(name) {
    if (!this.data[name]) {
      this.data[name] = 0;
    }
    this.data[name]++;
  }
  getData() {
    return { ...this.data };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/TextureMemoryManager.js
var TextureMemoryManager = class {
  constructor(stage2, settings2) {
    __publicField(this, "stage");
    __publicField(this, "memUsed", 0);
    __publicField(this, "loadedTextures", /* @__PURE__ */ new Map());
    __publicField(this, "criticalThreshold");
    __publicField(this, "targetThreshold");
    __publicField(this, "cleanupInterval");
    __publicField(this, "debugLogging");
    __publicField(this, "lastCleanupTime", 0);
    __publicField(this, "criticalCleanupRequested", false);
    /**
     * The current frame time in milliseconds
     *
     * @remarks
     * This is used to determine when to perform Idle Texture Cleanups.
     *
     * Set by stage via `updateFrameTime` method.
     */
    __publicField(this, "frameTime", 0);
    this.stage = stage2;
    const { criticalThreshold } = settings2;
    this.criticalThreshold = Math.round(criticalThreshold);
    const targetFraction = Math.max(0, Math.min(1, settings2.targetThresholdLevel));
    this.targetThreshold = Math.round(criticalThreshold * targetFraction);
    this.cleanupInterval = settings2.cleanupInterval;
    this.debugLogging = settings2.debugLogging;
    if (settings2.debugLogging) {
      let lastMemUse = 0;
      setInterval(() => {
        if (lastMemUse !== this.memUsed) {
          lastMemUse = this.memUsed;
          console.log(`[TextureMemoryManager] Memory used: ${bytesToMb(this.memUsed)} mb / ${bytesToMb(this.criticalThreshold)} mb (${(this.memUsed / this.criticalThreshold * 100).toFixed(1)}%)`);
        }
      }, 1e3);
    }
    if (criticalThreshold === 0) {
      this.setTextureMemUse = () => {
      };
    }
  }
  setTextureMemUse(texture, byteSize) {
    if (this.loadedTextures.has(texture)) {
      this.memUsed -= this.loadedTextures.get(texture);
    }
    if (byteSize === 0) {
      this.loadedTextures.delete(texture);
      return;
    } else {
      this.memUsed += byteSize;
      this.loadedTextures.set(texture, byteSize);
    }
    if (this.memUsed > this.criticalThreshold) {
      this.criticalCleanupRequested = true;
    }
  }
  checkCleanup() {
    return this.criticalCleanupRequested || this.memUsed > this.targetThreshold && this.frameTime - this.lastCleanupTime >= this.cleanupInterval;
  }
  cleanup() {
    const critical = this.criticalCleanupRequested;
    this.lastCleanupTime = this.frameTime;
    this.criticalCleanupRequested = false;
    if (critical) {
      this.stage.queueFrameEvent("criticalCleanup", {
        memUsed: this.memUsed,
        criticalThreshold: this.criticalThreshold
      });
    }
    if (this.debugLogging) {
      console.log(`[TextureMemoryManager] Cleaning up textures. Critical: ${critical}`);
    }
    const textures = [...this.loadedTextures.keys()].sort((textureA, textureB) => {
      const txARenderable = textureA.renderable;
      const txBRenderable = textureB.renderable;
      if (txARenderable === txBRenderable) {
        return textureA.lastRenderableChangeTime - textureB.lastRenderableChangeTime;
      } else if (txARenderable) {
        return 1;
      } else if (txBRenderable) {
        return -1;
      }
      return 0;
    });
    const memTarget = this.targetThreshold;
    const txManager = this.stage.txManager;
    for (const texture of textures) {
      if (texture.renderable) {
        break;
      }
      if (texture.preventCleanup === false) {
        texture.ctxTexture.free();
        txManager.removeTextureFromCache(texture);
      }
      if (this.memUsed <= memTarget) {
        break;
      }
    }
    if (this.memUsed >= this.criticalThreshold) {
      this.stage.queueFrameEvent("criticalCleanupFailed", {
        memUsed: this.memUsed,
        criticalThreshold: this.criticalThreshold
      });
      console.warn(`[TextureMemoryManager] Memory usage above critical threshold after cleanup: ${this.memUsed}`);
    }
  }
  /**
   * Get the current texture memory usage information
   *
   * @remarks
   * This method is for debugging purposes and returns information about the
   * current memory usage of the textures in the Renderer.
   */
  getMemoryInfo() {
    let renderableTexturesLoaded = 0;
    const renderableMemUsed = [...this.loadedTextures.keys()].reduce(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      (acc, texture) => {
        renderableTexturesLoaded += texture.renderable ? 1 : 0;
        return acc + (texture.renderable ? this.loadedTextures.get(texture) : 0);
      },
      0
    );
    return {
      criticalThreshold: this.criticalThreshold,
      targetThreshold: this.targetThreshold,
      renderableMemUsed,
      memUsed: this.memUsed,
      renderableTexturesLoaded,
      loadedTextures: this.loadedTextures.size
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/CoreContextTexture.js
var CoreContextTexture = class {
  constructor(memManager, textureSource) {
    __publicField(this, "textureSource");
    __publicField(this, "memManager");
    this.memManager = memManager;
    this.textureSource = textureSource;
  }
  setTextureMemUse(byteSize) {
    this.memManager.setTextureMemUse(this.textureSource, byteSize);
  }
  get renderable() {
    return this.textureSource.renderable;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/CoreRenderer.js
var CoreRenderer = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "mode");
    __publicField(this, "stage");
    //// Core Managers
    __publicField(this, "txManager");
    __publicField(this, "txMemManager");
    __publicField(this, "shManager");
    __publicField(this, "rttNodes", []);
    this.options = options;
    this.stage = options.stage;
    this.txManager = options.txManager;
    this.txMemManager = options.txMemManager;
    this.shManager = options.shManager;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/CoreTextNode.js
var CoreTextNode = class extends CoreNode {
  constructor(stage2, props, textRenderer) {
    super(stage2, props);
    __publicField(this, "textRenderer");
    __publicField(this, "trState");
    __publicField(this, "_textRendererOverride", null);
    __publicField(this, "onTextLoaded", () => {
      const { contain } = this;
      const setWidth = this.trState.props.width;
      const setHeight = this.trState.props.height;
      const calcWidth = this.trState.textW || 0;
      const calcHeight2 = this.trState.textH || 0;
      if (contain === "both") {
        this.props.width = setWidth;
        this.props.height = setHeight;
      } else if (contain === "width") {
        this.props.width = setWidth;
        this.props.height = calcHeight2;
      } else if (contain === "none") {
        this.props.width = calcWidth;
        this.props.height = calcHeight2;
      }
      this.updateLocalTransform();
      this.stage.requestRender();
      this.emit("loaded", {
        type: "text",
        dimensions: {
          width: this.trState.textW || 0,
          height: this.trState.textH || 0
        }
      });
    });
    __publicField(this, "onTextFailed", (target, error) => {
      this.emit("failed", {
        type: "text",
        error
      });
    });
    this._textRendererOverride = props.textRendererOverride;
    this.textRenderer = textRenderer;
    const textRendererState = this.createState({
      x: this.absX,
      y: this.absY,
      width: props.width,
      height: props.height,
      textAlign: props.textAlign,
      color: props.color,
      zIndex: props.zIndex,
      contain: props.contain,
      scrollable: props.scrollable,
      scrollY: props.scrollY,
      offsetY: props.offsetY,
      letterSpacing: props.letterSpacing,
      debug: props.debug,
      fontFamily: props.fontFamily,
      fontSize: props.fontSize,
      fontStretch: props.fontStretch,
      fontStyle: props.fontStyle,
      fontWeight: props.fontWeight,
      text: props.text,
      lineHeight: props.lineHeight,
      maxLines: props.maxLines,
      textBaseline: props.textBaseline,
      verticalAlign: props.verticalAlign,
      overflowSuffix: props.overflowSuffix
    });
    this.trState = textRendererState;
  }
  get width() {
    return this.props.width;
  }
  set width(value) {
    this.props.width = value;
    this.textRenderer.set.width(this.trState, value);
    if (this.contain === "none") {
      this.setUpdateType(UpdateType.Local);
    }
  }
  get height() {
    return this.props.height;
  }
  set height(value) {
    this.props.height = value;
    this.textRenderer.set.height(this.trState, value);
    if (this.contain !== "both") {
      this.setUpdateType(UpdateType.Local);
    }
  }
  get color() {
    return this.trState.props.color;
  }
  set color(value) {
    this.textRenderer.set.color(this.trState, value);
  }
  get text() {
    return this.trState.props.text;
  }
  set text(value) {
    this.textRenderer.set.text(this.trState, value);
  }
  get textRendererOverride() {
    return this._textRendererOverride;
  }
  set textRendererOverride(value) {
    this._textRendererOverride = value;
    this.textRenderer.destroyState(this.trState);
    const textRenderer = this.stage.resolveTextRenderer(this.trState.props, this._textRendererOverride);
    if (!textRenderer) {
      console.warn("Text Renderer not found for font", this.trState.props.fontFamily);
      return;
    }
    this.textRenderer = textRenderer;
    this.trState = this.createState(this.trState.props);
  }
  get fontSize() {
    return this.trState.props.fontSize;
  }
  set fontSize(value) {
    this.textRenderer.set.fontSize(this.trState, value);
  }
  get fontFamily() {
    return this.trState.props.fontFamily;
  }
  set fontFamily(value) {
    this.textRenderer.set.fontFamily(this.trState, value);
  }
  get fontStretch() {
    return this.trState.props.fontStretch;
  }
  set fontStretch(value) {
    this.textRenderer.set.fontStretch(this.trState, value);
  }
  get fontStyle() {
    return this.trState.props.fontStyle;
  }
  set fontStyle(value) {
    this.textRenderer.set.fontStyle(this.trState, value);
  }
  get fontWeight() {
    return this.trState.props.fontWeight;
  }
  set fontWeight(value) {
    this.textRenderer.set.fontWeight(this.trState, value);
  }
  get textAlign() {
    return this.trState.props.textAlign;
  }
  set textAlign(value) {
    this.textRenderer.set.textAlign(this.trState, value);
  }
  get contain() {
    return this.trState.props.contain;
  }
  set contain(value) {
    this.textRenderer.set.contain(this.trState, value);
  }
  get scrollable() {
    return this.trState.props.scrollable;
  }
  set scrollable(value) {
    this.textRenderer.set.scrollable(this.trState, value);
  }
  get scrollY() {
    return this.trState.props.scrollY;
  }
  set scrollY(value) {
    this.textRenderer.set.scrollY(this.trState, value);
  }
  get offsetY() {
    return this.trState.props.offsetY;
  }
  set offsetY(value) {
    this.textRenderer.set.offsetY(this.trState, value);
  }
  get letterSpacing() {
    return this.trState.props.letterSpacing;
  }
  set letterSpacing(value) {
    this.textRenderer.set.letterSpacing(this.trState, value);
  }
  get lineHeight() {
    return this.trState.props.lineHeight;
  }
  set lineHeight(value) {
    this.textRenderer.set.lineHeight(this.trState, value);
  }
  get maxLines() {
    return this.trState.props.maxLines;
  }
  set maxLines(value) {
    this.textRenderer.set.maxLines(this.trState, value);
  }
  get textBaseline() {
    return this.trState.props.textBaseline;
  }
  set textBaseline(value) {
    this.textRenderer.set.textBaseline(this.trState, value);
  }
  get verticalAlign() {
    return this.trState.props.verticalAlign;
  }
  set verticalAlign(value) {
    this.textRenderer.set.verticalAlign(this.trState, value);
  }
  get overflowSuffix() {
    return this.trState.props.overflowSuffix;
  }
  set overflowSuffix(value) {
    this.textRenderer.set.overflowSuffix(this.trState, value);
  }
  get debug() {
    return this.trState.props.debug;
  }
  set debug(value) {
    this.textRenderer.set.debug(this.trState, value);
  }
  update(delta, parentClippingRect) {
    super.update(delta, parentClippingRect);
    assertTruthy(this.globalTransform);
    this.textRenderer.set.x(this.trState, this.globalTransform.tx);
    this.textRenderer.set.y(this.trState, this.globalTransform.ty);
  }
  hasRenderableProperties() {
    if (this.trState && this.trState.props.text !== "") {
      return true;
    }
    return super.hasRenderableProperties();
  }
  onChangeIsRenderable(isRenderable) {
    super.onChangeIsRenderable(isRenderable);
    this.textRenderer.setIsRenderable(this.trState, isRenderable);
  }
  renderQuads(renderer3) {
    var _a2;
    assertTruthy(this.globalTransform);
    if (!this.textRenderer.renderQuads) {
      super.renderQuads(renderer3);
      return;
    }
    if (this.parentHasRenderTexture) {
      if (!renderer3.renderToTextureActive) {
        return;
      }
      if (this.parentRenderTexture !== renderer3.activeRttNode) {
        return;
      }
    }
    if (this.parentHasRenderTexture && ((_a2 = this.props.parent) == null ? void 0 : _a2.rtt)) {
      this.globalTransform = Matrix3d.identity();
      if (this.localTransform) {
        this.globalTransform.multiply(this.localTransform);
      }
    }
    assertTruthy(this.globalTransform);
    this.textRenderer.renderQuads(this.trState, this.globalTransform, this.clippingRect, this.worldAlpha, this.parentHasRenderTexture, this.framebufferDimensions);
  }
  /**
   * Destroy the node and cleanup all resources
   */
  destroy() {
    super.destroy();
    this.textRenderer.destroyState(this.trState);
  }
  /**
   * Resolve a text renderer and a new state based on the current text renderer props provided
   * @param props
   * @returns
   */
  createState(props) {
    const textRendererState = this.textRenderer.createState(props, this);
    textRendererState.emitter.on("loaded", this.onTextLoaded);
    textRendererState.emitter.on("failed", this.onTextFailed);
    this.textRenderer.scheduleUpdateState(textRendererState);
    return textRendererState;
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/utils.js
function santizeCustomDataMap(d) {
  const validTypes = {
    boolean: true,
    string: true,
    number: true,
    undefined: true
  };
  const keys = Object.keys(d);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!key) {
      continue;
    }
    const value = d[key];
    const valueType = typeof value;
    if (valueType === "string" && value.length > 2048) {
      console.warn(`Custom Data value for ${key} is too long, it will be truncated to 2048 characters`);
      d[key] = value.substring(0, 2048);
    }
    if (!validTypes[valueType]) {
      console.warn(`Custom Data value for ${key} is not a boolean, string, or number, it will be ignored`);
      delete d[key];
    }
  }
  return d;
}

// node_modules/@lightningjs/renderer/dist/src/core/Stage.js
var bufferMemory = 2e6;
var autoStart = true;
var Stage = class {
  /**
   * Stage constructor
   */
  constructor(options) {
    __publicField(this, "options");
    /// Module Instances
    __publicField(this, "animationManager");
    __publicField(this, "txManager");
    __publicField(this, "txMemManager");
    __publicField(this, "fontManager");
    __publicField(this, "textRenderers");
    __publicField(this, "shManager");
    __publicField(this, "renderer");
    __publicField(this, "root");
    __publicField(this, "boundsMargin");
    __publicField(this, "defShaderCtr");
    __publicField(this, "strictBound");
    __publicField(this, "preloadBound");
    __publicField(this, "strictBounds");
    /**
     * Renderer Event Bus for the Stage to emit events onto
     *
     * @remarks
     * In reality this is just the RendererMain instance, which is an EventEmitter.
     * this allows us to directly emit events from the Stage to RendererMain
     * without having to set up forwarding handlers.
     */
    __publicField(this, "eventBus");
    /// State
    __publicField(this, "deltaTime", 0);
    __publicField(this, "lastFrameTime", 0);
    __publicField(this, "currentFrameTime", 0);
    __publicField(this, "fpsNumFrames", 0);
    __publicField(this, "fpsElapsedTime", 0);
    __publicField(this, "renderRequested", false);
    __publicField(this, "frameEventQueue", []);
    __publicField(this, "fontResolveMap", {});
    /// Debug data
    __publicField(this, "contextSpy", null);
    this.options = options;
    const { canvas, clearColor, appWidth, appHeight, boundsMargin, enableContextSpy, forceWebGL2, numImageWorkers, textureMemory, renderEngine: renderEngine2, fontEngines } = options;
    this.eventBus = options.eventBus;
    this.txManager = new CoreTextureManager(numImageWorkers);
    this.txMemManager = new TextureMemoryManager(this, textureMemory);
    this.shManager = new CoreShaderManager();
    this.animationManager = new AnimationManager();
    this.contextSpy = enableContextSpy ? new ContextSpy() : null;
    this.strictBounds = options.strictBounds;
    let bm = [0, 0, 0, 0];
    if (boundsMargin) {
      bm = Array.isArray(boundsMargin) ? boundsMargin : [boundsMargin, boundsMargin, boundsMargin, boundsMargin];
    }
    this.boundsMargin = bm;
    this.strictBound = createBound(0, 0, appWidth, appHeight);
    this.preloadBound = createPreloadBounds(this.strictBound, bm);
    const rendererOptions = {
      stage: this,
      canvas,
      pixelRatio: options.devicePhysicalPixelRatio * options.deviceLogicalPixelRatio,
      clearColor: clearColor ?? 4278190080,
      bufferMemory,
      txManager: this.txManager,
      txMemManager: this.txMemManager,
      shManager: this.shManager,
      contextSpy: this.contextSpy,
      forceWebGL2
    };
    this.renderer = new renderEngine2(rendererOptions);
    const renderMode = this.renderer.mode || "webgl";
    this.defShaderCtr = this.renderer.getDefShaderCtr();
    setPremultiplyMode(renderMode);
    this.txManager.renderer = this.renderer;
    this.textRenderers = {};
    fontEngines.forEach((fontEngineConstructor) => {
      const fontEngineInstance = new fontEngineConstructor(this);
      const className = fontEngineInstance.type;
      if (className === "sdf" && renderMode === "canvas") {
        console.warn("SdfTextRenderer is not compatible with Canvas renderer. Skipping...");
        return;
      }
      if (fontEngineInstance instanceof TextRenderer) {
        if (className === "canvas") {
          this.textRenderers["canvas"] = fontEngineInstance;
        } else if (className === "sdf") {
          this.textRenderers["sdf"] = fontEngineInstance;
        }
      }
    });
    if (Object.keys(this.textRenderers).length === 0) {
      console.warn("No text renderers available. Your text will not render.");
    }
    this.fontManager = new TrFontManager(this.textRenderers);
    const rootNode = new CoreNode(this, {
      x: 0,
      y: 0,
      width: appWidth,
      height: appHeight,
      alpha: 1,
      autosize: false,
      clipping: false,
      color: 0,
      colorTop: 0,
      colorBottom: 0,
      colorLeft: 0,
      colorRight: 0,
      colorTl: 0,
      colorTr: 0,
      colorBl: 0,
      colorBr: 0,
      zIndex: 0,
      zIndexLocked: 0,
      scaleX: 1,
      scaleY: 1,
      mountX: 0,
      mountY: 0,
      mount: 0,
      pivot: 0.5,
      pivotX: 0.5,
      pivotY: 0.5,
      rotation: 0,
      parent: null,
      texture: null,
      textureOptions: {},
      shader: this.defShaderCtr,
      rtt: false,
      src: null,
      scale: 1,
      preventCleanup: false,
      strictBounds: this.strictBounds
    });
    this.root = rootNode;
    if (autoStart) {
      startLoop(this);
    }
  }
  updateFrameTime() {
    const newFrameTime = getTimeStamp();
    this.lastFrameTime = this.currentFrameTime;
    this.currentFrameTime = newFrameTime;
    this.deltaTime = !this.lastFrameTime ? 100 / 6 : newFrameTime - this.lastFrameTime;
    this.txManager.frameTime = newFrameTime;
    this.txMemManager.frameTime = newFrameTime;
    this.eventBus.emit("frameTick", {
      time: this.currentFrameTime,
      delta: this.deltaTime
    });
  }
  /**
   * Update animations
   */
  updateAnimations() {
    const { animationManager } = this;
    if (!this.root) {
      return;
    }
    animationManager.update(this.deltaTime);
  }
  /**
   * Check if the scene has updates
   */
  hasSceneUpdates() {
    return !!this.root.updateType || this.renderRequested;
  }
  /**
   * Start a new frame draw
   */
  drawFrame() {
    const { renderer: renderer3, renderRequested } = this;
    assertTruthy(renderer3);
    if (this.root.updateType !== 0) {
      this.root.update(this.deltaTime, this.root.clippingRect);
    }
    renderer3.reset();
    if (this.txMemManager.criticalCleanupRequested) {
      this.txMemManager.cleanup();
    }
    if (renderer3.rttNodes.length > 0) {
      renderer3.renderRTTNodes();
    }
    this.addQuads(this.root);
    renderer3 == null ? void 0 : renderer3.render();
    this.calculateFps();
    if (renderRequested) {
      this.renderRequested = false;
    }
  }
  /**
   * Queue an event to be emitted after the current/next frame is rendered
   *
   * @remarks
   * When we are operating in the context of the render loop, we may want to
   * emit events that are related to the current frame. However, we generally do
   * NOT want to emit events directly in the middle of the render loop, since
   * this could enable event handlers to modify the scene graph and cause
   * unexpected behavior. Instead, we queue up events to be emitted and then
   * flush the queue after the frame has been rendered.
   *
   * @param name
   * @param data
   */
  queueFrameEvent(name, data) {
    this.frameEventQueue.push([name, data]);
  }
  /**
   * Emit all queued frame events
   *
   * @remarks
   * This method should be called after the frame has been rendered to emit
   * all events that were queued during the frame.
   *
   * See {@link queueFrameEvent} for more information.
   */
  flushFrameEvents() {
    for (const [name, data] of this.frameEventQueue) {
      this.eventBus.emit(name, data);
    }
    this.frameEventQueue = [];
  }
  calculateFps() {
    var _a2, _b;
    const { fpsUpdateInterval } = this.options;
    if (fpsUpdateInterval) {
      this.fpsNumFrames++;
      this.fpsElapsedTime += this.deltaTime;
      if (this.fpsElapsedTime >= fpsUpdateInterval) {
        const fps = Math.round(this.fpsNumFrames * 1e3 / this.fpsElapsedTime);
        this.fpsNumFrames = 0;
        this.fpsElapsedTime = 0;
        this.queueFrameEvent("fpsUpdate", {
          fps,
          contextSpyData: ((_a2 = this.contextSpy) == null ? void 0 : _a2.getData()) ?? null
        });
        (_b = this.contextSpy) == null ? void 0 : _b.reset();
      }
    }
  }
  addQuads(node) {
    assertTruthy(this.renderer);
    if (node.isRenderable === true) {
      node.renderQuads(this.renderer);
    }
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (child === void 0) {
        continue;
      }
      if (child.worldAlpha === 0 || child.strictBounds === true && child.renderState === CoreNodeRenderState.OutOfBounds) {
        continue;
      }
      this.addQuads(child);
    }
  }
  /**
   * Request a render pass without forcing an update
   */
  requestRender() {
    this.renderRequested = true;
  }
  /**
   * Given a font name, and possible renderer override, return the best compatible text renderer.
   *
   * @remarks
   * Will try to return a canvas renderer if no other suitable renderer can be resolved.
   *
   * @param fontFamily
   * @param textRendererOverride
   * @returns
   */
  resolveTextRenderer(trProps, textRendererOverride = null) {
    const fontCacheString = `${trProps.fontFamily}${trProps.fontStyle}${trProps.fontWeight}${trProps.fontStretch}${textRendererOverride ? textRendererOverride : ""}`;
    if (this.fontResolveMap[fontCacheString] !== void 0) {
      return this.fontResolveMap[fontCacheString];
    }
    let rendererId = textRendererOverride;
    let overrideFallback = false;
    if (rendererId) {
      const possibleRenderer = this.textRenderers[rendererId];
      if (!possibleRenderer) {
        console.warn(`Text renderer override '${rendererId}' not found.`);
        rendererId = null;
        overrideFallback = true;
      } else if (!possibleRenderer.canRenderFont(trProps)) {
        console.warn(`Cannot use override text renderer '${rendererId}' for font`, trProps);
        rendererId = null;
        overrideFallback = true;
      }
    }
    if (!rendererId) {
      for (const [trId, tr] of Object.entries(this.textRenderers)) {
        if (tr.canRenderFont(trProps)) {
          rendererId = trId;
          break;
        }
      }
      if (!rendererId && this.textRenderers.canvas !== void 0) {
        rendererId = "canvas";
      }
    }
    if (overrideFallback) {
      console.warn(`Falling back to text renderer ${String(rendererId)}`);
    }
    if (!rendererId) {
      return null;
    }
    const resolvedTextRenderer = this.textRenderers[rendererId];
    assertTruthy(resolvedTextRenderer, "resolvedTextRenderer undefined");
    this.fontResolveMap[fontCacheString] = resolvedTextRenderer;
    return resolvedTextRenderer;
  }
  /**
   * Create a shader controller instance
   *
   * @param type
   * @param props
   * @returns
   */
  createShaderCtr(type, props) {
    return this.shManager.loadShader(type, props);
  }
  createNode(props) {
    const resolvedProps = this.resolveNodeDefaults(props);
    return new CoreNode(this, resolvedProps);
  }
  createTextNode(props) {
    const fontSize = props.fontSize ?? 16;
    const resolvedProps = {
      ...this.resolveNodeDefaults(props),
      text: props.text ?? "",
      textRendererOverride: props.textRendererOverride ?? null,
      fontSize,
      fontFamily: props.fontFamily ?? "sans-serif",
      fontStyle: props.fontStyle ?? "normal",
      fontWeight: props.fontWeight ?? "normal",
      fontStretch: props.fontStretch ?? "normal",
      textAlign: props.textAlign ?? "left",
      contain: props.contain ?? "none",
      scrollable: props.scrollable ?? false,
      scrollY: props.scrollY ?? 0,
      offsetY: props.offsetY ?? 0,
      letterSpacing: props.letterSpacing ?? 0,
      lineHeight: props.lineHeight,
      maxLines: props.maxLines ?? 0,
      textBaseline: props.textBaseline ?? "alphabetic",
      verticalAlign: props.verticalAlign ?? "middle",
      overflowSuffix: props.overflowSuffix ?? "...",
      debug: props.debug ?? {},
      shaderProps: null
    };
    const resolvedTextRenderer = this.resolveTextRenderer(resolvedProps, props.textRendererOverride);
    if (!resolvedTextRenderer) {
      throw new Error(`No compatible text renderer found for ${resolvedProps.fontFamily}`);
    }
    return new CoreTextNode(this, resolvedProps, resolvedTextRenderer);
  }
  /**
   * Resolves the default property values for a Node
   *
   * @remarks
   * This method is used internally by the RendererMain to resolve the default
   * property values for a Node. It is exposed publicly so that it can be used
   * by Core Driver implementations.
   *
   * @param props
   * @returns
   */
  resolveNodeDefaults(props) {
    const color = props.color ?? 4294967295;
    const colorTl = props.colorTl ?? props.colorTop ?? props.colorLeft ?? color;
    const colorTr = props.colorTr ?? props.colorTop ?? props.colorRight ?? color;
    const colorBl = props.colorBl ?? props.colorBottom ?? props.colorLeft ?? color;
    const colorBr = props.colorBr ?? props.colorBottom ?? props.colorRight ?? color;
    let data = {};
    if (this.options.inspector === true) {
      data = santizeCustomDataMap(props.data ?? {});
    }
    return {
      x: props.x ?? 0,
      y: props.y ?? 0,
      width: props.width ?? 0,
      height: props.height ?? 0,
      alpha: props.alpha ?? 1,
      autosize: props.autosize ?? false,
      clipping: props.clipping ?? false,
      color,
      colorTop: props.colorTop ?? color,
      colorBottom: props.colorBottom ?? color,
      colorLeft: props.colorLeft ?? color,
      colorRight: props.colorRight ?? color,
      colorBl,
      colorBr,
      colorTl,
      colorTr,
      zIndex: props.zIndex ?? 0,
      zIndexLocked: props.zIndexLocked ?? 0,
      parent: props.parent ?? null,
      texture: props.texture ?? null,
      textureOptions: props.textureOptions ?? {},
      shader: props.shader ?? this.defShaderCtr,
      // Since setting the `src` will trigger a texture load, we need to set it after
      // we set the texture. Otherwise, problems happen.
      src: props.src ?? null,
      srcHeight: props.srcHeight,
      srcWidth: props.srcWidth,
      srcX: props.srcX,
      srcY: props.srcY,
      scale: props.scale ?? null,
      scaleX: props.scaleX ?? props.scale ?? 1,
      scaleY: props.scaleY ?? props.scale ?? 1,
      mount: props.mount ?? 0,
      mountX: props.mountX ?? props.mount ?? 0,
      mountY: props.mountY ?? props.mount ?? 0,
      pivot: props.pivot ?? 0.5,
      pivotX: props.pivotX ?? props.pivot ?? 0.5,
      pivotY: props.pivotY ?? props.pivot ?? 0.5,
      rotation: props.rotation ?? 0,
      rtt: props.rtt ?? false,
      data,
      preventCleanup: props.preventCleanup ?? false,
      imageType: props.imageType,
      strictBounds: props.strictBounds ?? this.strictBounds
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/Renderer.js
var RendererMain = class extends EventEmitter {
  /**
   * Constructs a new Renderer instance
   *
   * @param settings Renderer settings
   * @param target Element ID or HTMLElement to insert the canvas into
   * @param driver Core Driver to use
   */
  constructor(settings2, target) {
    var _a2, _b, _c, _d;
    super();
    __publicField(this, "root");
    __publicField(this, "canvas");
    __publicField(this, "settings");
    __publicField(this, "stage");
    __publicField(this, "inspector", null);
    const resolvedTxSettings = {
      criticalThreshold: ((_a2 = settings2.textureMemory) == null ? void 0 : _a2.criticalThreshold) || 124e6,
      targetThresholdLevel: ((_b = settings2.textureMemory) == null ? void 0 : _b.targetThresholdLevel) || 0.5,
      cleanupInterval: ((_c = settings2.textureMemory) == null ? void 0 : _c.cleanupInterval) || 3e4,
      debugLogging: ((_d = settings2.textureMemory) == null ? void 0 : _d.debugLogging) || false
    };
    const resolvedSettings = {
      appWidth: settings2.appWidth || 1920,
      appHeight: settings2.appHeight || 1080,
      textureMemory: resolvedTxSettings,
      boundsMargin: settings2.boundsMargin || 0,
      deviceLogicalPixelRatio: settings2.deviceLogicalPixelRatio || 1,
      devicePhysicalPixelRatio: settings2.devicePhysicalPixelRatio || window.devicePixelRatio,
      clearColor: settings2.clearColor ?? 0,
      fpsUpdateInterval: settings2.fpsUpdateInterval || 0,
      numImageWorkers: settings2.numImageWorkers !== void 0 ? settings2.numImageWorkers : 2,
      enableContextSpy: settings2.enableContextSpy ?? false,
      forceWebGL2: settings2.forceWebGL2 ?? false,
      inspector: settings2.inspector ?? false,
      renderEngine: settings2.renderEngine,
      quadBufferSize: settings2.quadBufferSize ?? 4 * 1024 * 1024,
      fontEngines: settings2.fontEngines,
      strictBounds: settings2.strictBounds ?? true
    };
    this.settings = resolvedSettings;
    const { appWidth, appHeight, deviceLogicalPixelRatio, devicePhysicalPixelRatio, inspector } = resolvedSettings;
    const deviceLogicalWidth = appWidth * deviceLogicalPixelRatio;
    const deviceLogicalHeight = appHeight * deviceLogicalPixelRatio;
    const canvas = document.createElement("canvas");
    this.canvas = canvas;
    canvas.width = deviceLogicalWidth * devicePhysicalPixelRatio;
    canvas.height = deviceLogicalHeight * devicePhysicalPixelRatio;
    canvas.style.width = `${deviceLogicalWidth}px`;
    canvas.style.height = `${deviceLogicalHeight}px`;
    this.stage = new Stage({
      appWidth: this.settings.appWidth,
      appHeight: this.settings.appHeight,
      boundsMargin: this.settings.boundsMargin,
      clearColor: this.settings.clearColor,
      canvas: this.canvas,
      deviceLogicalPixelRatio: this.settings.deviceLogicalPixelRatio,
      devicePhysicalPixelRatio: this.settings.devicePhysicalPixelRatio,
      enableContextSpy: this.settings.enableContextSpy,
      forceWebGL2: this.settings.forceWebGL2,
      fpsUpdateInterval: this.settings.fpsUpdateInterval,
      numImageWorkers: this.settings.numImageWorkers,
      renderEngine: this.settings.renderEngine,
      textureMemory: resolvedTxSettings,
      eventBus: this,
      quadBufferSize: this.settings.quadBufferSize,
      fontEngines: this.settings.fontEngines,
      inspector: this.settings.inspector !== null,
      strictBounds: this.settings.strictBounds
    });
    this.root = this.stage.root;
    let targetEl;
    if (typeof target === "string") {
      targetEl = document.getElementById(target);
    } else {
      targetEl = target;
    }
    if (!targetEl) {
      throw new Error("Could not find target element");
    }
    targetEl.appendChild(canvas);
    if (inspector && !isProductionEnvironment()) {
      this.inspector = new inspector(canvas, resolvedSettings);
    }
  }
  /**
   * Create a new scene graph node
   *
   * @remarks
   * A node is the main graphical building block of the Renderer scene graph. It
   * can be a container for other nodes, or it can be a leaf node that renders a
   * solid color, gradient, image, or specific texture, using a specific shader.
   *
   * To create a text node, see {@link createTextNode}.
   *
   * See {@link CoreNode} for more details.
   *
   * @param props
   * @returns
   */
  createNode(props) {
    const node = this.stage.createNode(props);
    if (this.inspector) {
      return this.inspector.createNode(node);
    }
    return node;
  }
  /**
   * Create a new scene graph text node
   *
   * @remarks
   * A text node is the second graphical building block of the Renderer scene
   * graph. It renders text using a specific text renderer that is automatically
   * chosen based on the font requested and what type of fonts are installed
   * into an app.
   *
   * See {@link ITextNode} for more details.
   *
   * @param props
   * @returns
   */
  createTextNode(props) {
    const textNode = this.stage.createTextNode(props);
    if (this.inspector) {
      return this.inspector.createTextNode(textNode);
    }
    return textNode;
  }
  /**
   * Destroy a node
   *
   * @remarks
   * This method destroys a node
   *
   * @param node
   * @returns
   */
  destroyNode(node) {
    if (this.inspector) {
      this.inspector.destroyNode(node.id);
    }
    return node.destroy();
  }
  /**
   * Create a new texture reference
   *
   * @remarks
   * This method creates a new reference to a texture. The texture is not
   * loaded until it is used on a node.
   *
   * It can be assigned to a node's `texture` property, or it can be used
   * when creating a SubTexture.
   *
   * @param textureType
   * @param props
   * @param options
   * @returns
   */
  createTexture(textureType, props) {
    return this.stage.txManager.loadTexture(textureType, props);
  }
  /**
   * Create a new shader controller for a shader type
   *
   * @remarks
   * This method creates a new Shader Controller for a specific shader type.
   *
   * If the shader has not been loaded yet, it will be loaded. Otherwise, the
   * existing shader will be reused.
   *
   * It can be assigned to a Node's `shader` property.
   *
   * @param shaderType
   * @param props
   * @returns
   */
  createShader(shaderType, props) {
    return this.stage.shManager.loadShader(shaderType, props);
  }
  /**
   * Create a new Dynamic Shader controller
   *
   * @remarks
   * A Dynamic Shader is a shader that can be composed of an array of mulitple
   * effects. Each effect can be animated or changed after creation (provided
   * the effect is given a name).
   *
   * Example:
   * ```ts
   * renderer.createNode({
   *   shader: renderer.createDynamicShader([
   *     renderer.createEffect('radius', {
   *       radius: 0
   *     }, 'effect1'),
   *     renderer.createEffect('border', {
   *       color: 0xff00ffff,
   *       width: 10,
   *     }, 'effect2'),
   *   ]),
   * });
   * ```
   *
   * @param effects
   * @returns
   */
  createDynamicShader(effects) {
    return this.stage.shManager.loadDynamicShader({
      effects
    });
  }
  /**
   * Create an effect to be used in a Dynamic Shader
   *
   * @remark
   * The {name} parameter is optional but required if you want to animate the effect
   * or change the effect's properties after creation.
   *
   * See {@link createDynamicShader} for an example.
   *
   * @param type
   * @param props
   * @param name
   * @returns
   */
  createEffect(type, props, name) {
    return {
      name,
      type,
      props
    };
  }
  /**
   * Get a Node by its ID
   *
   * @param id
   * @returns
   */
  getNodeById(id) {
    var _a2;
    const root = (_a2 = this.stage) == null ? void 0 : _a2.root;
    if (!root) {
      return null;
    }
    const findNode = (node) => {
      if (node.id === id) {
        return node;
      }
      for (const child of node.children) {
        const found = findNode(child);
        if (found) {
          return found;
        }
      }
      return null;
    };
    return findNode(root);
  }
  toggleFreeze() {
    throw new Error("Not implemented");
  }
  advanceFrame() {
    throw new Error("Not implemented");
  }
  getBufferInfo() {
    return this.stage.renderer.getBufferInfo();
  }
  /**
   * Re-render the current frame without advancing any running animations.
   *
   * @remarks
   * Any state changes will be reflected in the re-rendered frame. Useful for
   * debugging.
   *
   * May not do anything if the render loop is running on a separate worker.
   */
  rerender() {
    throw new Error("Not implemented");
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/TrFontFace.js
var TrFontFace = class extends EventEmitter {
  constructor(options) {
    super();
    __publicField(this, "fontFamily");
    __publicField(this, "descriptors");
    __publicField(this, "loaded", false);
    __publicField(this, "metrics", null);
    const { fontFamily, descriptors, metrics } = options;
    if (metrics) {
      this.metrics = {
        ascender: metrics.ascender / metrics.unitsPerEm,
        descender: metrics.descender / metrics.unitsPerEm,
        lineGap: metrics.lineGap / metrics.unitsPerEm
      };
    }
    this.fontFamily = fontFamily;
    this.descriptors = {
      style: "normal",
      weight: "normal",
      stretch: "normal",
      ...descriptors
    };
  }
  /**
   * Convert a TrFontFaceDescriptors to a FontFaceDescriptors which differ slightly
   *
   * @param descriptors
   * @returns
   */
  static convertToCssFontFaceDescriptors(descriptors) {
    return {
      style: descriptors.style,
      weight: typeof descriptors.weight === "number" ? `${descriptors.weight}` : descriptors.weight,
      stretch: descriptors.stretch,
      unicodeRange: descriptors.unicodeRange,
      featureSettings: descriptors.featureSettings,
      display: descriptors.display
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/WebTrFontFace.js
var WebTrFontFace = class extends TrFontFace {
  constructor(options) {
    super(options);
    __publicField(this, "fontFace");
    __publicField(this, "fontUrl");
    const { fontFamily, fontUrl } = options;
    const fontUrlWithoutParentheses = fontUrl.replace(/\(|\)/g, "");
    const determinedDescriptors = this.descriptors;
    const cssDescriptors = {
      style: determinedDescriptors.style,
      weight: typeof determinedDescriptors.weight === "number" ? `${determinedDescriptors.weight}` : determinedDescriptors.weight,
      stretch: determinedDescriptors.stretch,
      unicodeRange: determinedDescriptors.unicodeRange,
      featureSettings: determinedDescriptors.featureSettings,
      display: determinedDescriptors.display
    };
    const fontFace = new FontFace(fontFamily, `url(${fontUrlWithoutParentheses})`, cssDescriptors);
    if (fontUrlWithoutParentheses.length > 0) {
      fontFace.load().then(() => {
        this.loaded = true;
        this.emit("loaded");
      }).catch(console.error);
    } else {
      this.loaded = true;
      this.emit("loaded");
    }
    this.fontFace = fontFace;
    this.fontUrl = fontUrl;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/CoreRenderOp.js
var CoreRenderOp = class {
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreRenderOp.js
var WebGlCoreRenderOp = class extends CoreRenderOp {
  constructor(glw, options, buffers, shader, shaderProps, alpha, clippingRect, dimensions, bufferIdx, zIndex, renderToTexture, parentHasRenderTexture, framebufferDimensions) {
    super();
    __publicField(this, "glw");
    __publicField(this, "options");
    __publicField(this, "buffers");
    __publicField(this, "shader");
    __publicField(this, "shaderProps");
    __publicField(this, "alpha");
    __publicField(this, "clippingRect");
    __publicField(this, "dimensions");
    __publicField(this, "bufferIdx");
    __publicField(this, "zIndex");
    __publicField(this, "renderToTexture");
    __publicField(this, "parentHasRenderTexture");
    __publicField(this, "framebufferDimensions");
    __publicField(this, "length", 0);
    __publicField(this, "numQuads", 0);
    __publicField(this, "textures", []);
    __publicField(this, "maxTextures");
    this.glw = glw;
    this.options = options;
    this.buffers = buffers;
    this.shader = shader;
    this.shaderProps = shaderProps;
    this.alpha = alpha;
    this.clippingRect = clippingRect;
    this.dimensions = dimensions;
    this.bufferIdx = bufferIdx;
    this.zIndex = zIndex;
    this.renderToTexture = renderToTexture;
    this.parentHasRenderTexture = parentHasRenderTexture;
    this.framebufferDimensions = framebufferDimensions;
    this.maxTextures = shader.supportsIndexedTextures ? glw.getParameter(glw.MAX_VERTEX_TEXTURE_IMAGE_UNITS) : 1;
  }
  addTexture(texture) {
    const { textures, maxTextures } = this;
    let existingIdx = -1;
    const texturesLength = textures.length;
    for (let i = 0; i < texturesLength; i++) {
      const t = textures[i];
      if (t === texture) {
        existingIdx = i;
        break;
      }
    }
    if (existingIdx !== -1) {
      return existingIdx;
    }
    if (texturesLength >= maxTextures) {
      return 4294967295;
    }
    this.textures.push(texture);
    return texturesLength;
  }
  draw() {
    const { glw, shader, shaderProps, options } = this;
    const { shManager } = options;
    shManager.useShader(shader);
    shader.bindRenderOp(this, shaderProps);
    const quadIdx = this.bufferIdx / 24 * 6 * 2;
    if (this.clippingRect.valid) {
      const { x, y, width, height } = this.clippingRect;
      const pixelRatio = options.pixelRatio;
      const canvasHeight = options.canvas.height;
      const clipX = Math.round(x * pixelRatio);
      const clipWidth = Math.round(width * pixelRatio);
      const clipHeight = Math.round(height * pixelRatio);
      const clipY = Math.round(canvasHeight - clipHeight - y * pixelRatio);
      glw.setScissorTest(true);
      glw.scissor(clipX, clipY, clipWidth, clipHeight);
    } else {
      glw.setScissorTest(false);
    }
    glw.drawElements(glw.TRIANGLES, 6 * this.numQuads, glw.UNSIGNED_SHORT, quadIdx);
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/internal/RendererUtils.js
function getWebGlParameters(glw) {
  const params = {
    MAX_RENDERBUFFER_SIZE: 0,
    MAX_TEXTURE_SIZE: 0,
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any
    MAX_VIEWPORT_DIMS: 0,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0,
    MAX_TEXTURE_IMAGE_UNITS: 0,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0,
    MAX_VERTEX_ATTRIBS: 0,
    MAX_VARYING_VECTORS: 0,
    MAX_VERTEX_UNIFORM_VECTORS: 0,
    MAX_FRAGMENT_UNIFORM_VECTORS: 0
  };
  const keys = Object.keys(params);
  keys.forEach((key) => {
    params[key] = glw.getParameter(glw[key]);
  });
  return params;
}
function getWebGlExtensions(glw) {
  const extensions = {
    ANGLE_instanced_arrays: null,
    WEBGL_compressed_texture_s3tc: null,
    WEBGL_compressed_texture_astc: null,
    WEBGL_compressed_texture_etc: null,
    WEBGL_compressed_texture_etc1: null,
    WEBGL_compressed_texture_pvrtc: null,
    WEBKIT_WEBGL_compressed_texture_pvrtc: null,
    WEBGL_compressed_texture_s3tc_srgb: null,
    OES_vertex_array_object: null
  };
  const keys = Object.keys(extensions);
  keys.forEach((key) => {
    extensions[key] = glw.getExtension(key);
  });
  return extensions;
}
function createIndexBuffer(glw, size) {
  const maxQuads = ~~(size / 80);
  const indices = new Uint16Array(maxQuads * 6);
  for (let i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
    indices[i] = j;
    indices[i + 1] = j + 1;
    indices[i + 2] = j + 2;
    indices[i + 3] = j + 2;
    indices[i + 4] = j + 1;
    indices[i + 5] = j + 3;
  }
  const buffer = glw.createBuffer();
  glw.elementArrayBufferData(buffer, indices, glw.STATIC_DRAW);
}
function isHTMLImageElement(obj) {
  return obj !== null && typeof obj === "object" && obj.constructor && obj.constructor.name === "HTMLImageElement";
}

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreCtxTexture.js
var TRANSPARENT_TEXTURE_DATA = new Uint8Array([0, 0, 0, 0]);
var WebGlCoreCtxTexture = class extends CoreContextTexture {
  constructor(glw, memManager, textureSource) {
    super(memManager, textureSource);
    __publicField(this, "glw");
    __publicField(this, "_nativeCtxTexture", null);
    __publicField(this, "_state", "freed");
    __publicField(this, "_w", 0);
    __publicField(this, "_h", 0);
    this.glw = glw;
  }
  get ctxTexture() {
    if (this._state === "freed") {
      this.load();
    }
    assertTruthy(this._nativeCtxTexture);
    return this._nativeCtxTexture;
  }
  get w() {
    return this._w;
  }
  get h() {
    return this._h;
  }
  /**
   * Load the texture data from the Texture source and upload it to the GPU
   *
   * @remarks
   * This method is called automatically when accessing the ctxTexture property
   * if the texture hasn't been loaded yet. But it can also be called manually
   * to force the texture to be pre-loaded prior to accessing the ctxTexture
   * property.
   */
  load() {
    if (this._state === "loading" || this._state === "loaded") {
      return;
    }
    this._state = "loading";
    this.textureSource.setState("loading");
    this._nativeCtxTexture = this.createNativeCtxTexture();
    if (this._nativeCtxTexture === null) {
      this._state = "failed";
      this.textureSource.setState("failed", new Error("Could not create WebGL Texture"));
      console.error("Could not create WebGL Texture");
      return;
    }
    this.onLoadRequest().then(({ width, height }) => {
      if (this._state === "freed") {
        return;
      }
      this._state = "loaded";
      this._w = width;
      this._h = height;
      this.textureSource.setState("loaded", { width, height });
    }).catch((err) => {
      if (this._state === "freed") {
        return;
      }
      this._state = "failed";
      this.textureSource.setState("failed", err);
      console.error(err);
    });
  }
  /**
   * Called when the texture data needs to be loaded and uploaded to a texture
   */
  async onLoadRequest() {
    var _a2;
    const { glw } = this;
    glw.texImage2D(0, glw.RGBA, 1, 1, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
    this.setTextureMemUse(TRANSPARENT_TEXTURE_DATA.byteLength);
    const textureData = await ((_a2 = this.textureSource) == null ? void 0 : _a2.getTextureData());
    if (!this._nativeCtxTexture) {
      assertTruthy(this._state === "freed");
      return { width: 0, height: 0 };
    }
    let width = 0;
    let height = 0;
    assertTruthy(this._nativeCtxTexture);
    glw.activeTexture(0);
    if (typeof ImageBitmap !== "undefined" && textureData.data instanceof ImageBitmap || textureData.data instanceof ImageData || // not using typeof HTMLImageElement due to web worker
    isHTMLImageElement(textureData.data)) {
      const data = textureData.data;
      width = data.width;
      height = data.height;
      glw.bindTexture(this._nativeCtxTexture);
      glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
      glw.texImage2D(0, glw.RGBA, glw.RGBA, glw.UNSIGNED_BYTE, data);
      this.setTextureMemUse(width * height * 4);
      if (glw.isWebGl2() || isPowerOfTwo(width) && isPowerOfTwo(height)) {
        glw.generateMipmap();
      }
    } else if (textureData.data === null) {
      width = 0;
      height = 0;
      glw.bindTexture(this._nativeCtxTexture);
      glw.texImage2D(0, glw.RGBA, 1, 1, 0, glw.RGBA, glw.UNSIGNED_BYTE, TRANSPARENT_TEXTURE_DATA);
      this.setTextureMemUse(TRANSPARENT_TEXTURE_DATA.byteLength);
    } else if ("mipmaps" in textureData.data && textureData.data.mipmaps) {
      const { mipmaps, width: width2 = 0, height: height2 = 0, type, glInternalFormat } = textureData.data;
      const view = type === "ktx" ? new DataView(mipmaps[0] ?? new ArrayBuffer(0)) : mipmaps[0];
      glw.bindTexture(this._nativeCtxTexture);
      glw.compressedTexImage2D(0, glInternalFormat, width2, height2, 0, view);
      glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
      glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
      glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
      glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
      this.setTextureMemUse(view.byteLength);
    } else if (textureData.data && textureData.data instanceof Uint8Array) {
      width = 1;
      height = 1;
      glw.bindTexture(this._nativeCtxTexture);
      glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
      glw.texImage2D(0, glw.RGBA, width, height, 0, glw.RGBA, glw.UNSIGNED_BYTE, textureData.data);
      this.setTextureMemUse(width * height * 4);
    } else {
      console.error(`WebGlCoreCtxTexture.onLoadRequest: Unexpected textureData returned`, textureData);
    }
    return {
      width,
      height
    };
  }
  /**
   * Free the WebGLTexture from the GPU
   *
   * @returns
   */
  free() {
    if (this._state === "freed") {
      return;
    }
    this._state = "freed";
    this.textureSource.setState("freed");
    this._w = 0;
    this._h = 0;
    if (!this._nativeCtxTexture) {
      return;
    }
    const { glw } = this;
    glw.deleteTexture(this._nativeCtxTexture);
    this.setTextureMemUse(0);
    this._nativeCtxTexture = null;
  }
  /**
   * Create native context texture
   *
   * @remarks
   * When this method returns the returned texture will be bound to the GL context state.
   *
   * @param width
   * @param height
   * @returns
   */
  createNativeCtxTexture() {
    const { glw } = this;
    const nativeTexture = glw.createTexture();
    if (!nativeTexture) {
      return null;
    }
    glw.activeTexture(0);
    glw.bindTexture(nativeTexture);
    glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
    glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
    glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
    glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
    return nativeTexture;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreCtxSubTexture.js
var WebGlCoreCtxSubTexture = class extends WebGlCoreCtxTexture {
  constructor(glw, memManager, textureSource) {
    super(glw, memManager, textureSource);
  }
  async onLoadRequest() {
    var _a2, _b;
    const props = await this.textureSource.getTextureData();
    if (props.data instanceof Uint8Array) {
      return { width: 1, height: 1 };
    }
    return {
      width: ((_a2 = props.data) == null ? void 0 : _a2.width) || 0,
      height: ((_b = props.data) == null ? void 0 : _b.height) || 0
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/internal/BufferCollection.js
var BufferCollection = class {
  constructor(config) {
    __publicField(this, "config");
    this.config = config;
  }
  /**
   * Get the WebGLBuffer associated with the given attribute name if it exists.
   *
   * @param attributeName
   * @returns
   */
  getBuffer(attributeName) {
    var _a2;
    return (_a2 = this.config.find((item) => item.attributes[attributeName])) == null ? void 0 : _a2.buffer;
  }
  /**
   * Get the AttributeInfo associated with the given attribute name if it exists.
   *
   * @param attributeName
   * @returns
   */
  getAttributeInfo(attributeName) {
    var _a2;
    return (_a2 = this.config.find((item) => item.attributes[attributeName])) == null ? void 0 : _a2.attributes[attributeName];
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/internal/WebGlUtils.js
function isWebGl2(gl) {
  return self.WebGL2RenderingContext && gl instanceof self.WebGL2RenderingContext;
}

// node_modules/@lightningjs/renderer/dist/src/core/lib/WebGlContextWrapper.js
var WebGlContextWrapper = class {
  //#endregion WebGL Enums
  constructor(gl) {
    __publicField(this, "gl");
    //#region Cached WebGL State
    __publicField(this, "activeTextureUnit", 0);
    __publicField(this, "texture2dUnits");
    __publicField(this, "texture2dParams", /* @__PURE__ */ new WeakMap());
    __publicField(this, "scissorEnabled");
    __publicField(this, "scissorX");
    __publicField(this, "scissorY");
    __publicField(this, "scissorWidth");
    __publicField(this, "scissorHeight");
    __publicField(this, "blendEnabled");
    __publicField(this, "blendSrcRgb");
    __publicField(this, "blendDstRgb");
    __publicField(this, "blendSrcAlpha");
    __publicField(this, "blendDstAlpha");
    __publicField(this, "boundArrayBuffer");
    __publicField(this, "boundElementArrayBuffer");
    __publicField(this, "curProgram");
    //#endregion Cached WebGL State
    //#region Canvas
    __publicField(this, "canvas");
    //#endregion Canvas
    //#region WebGL Enums
    __publicField(this, "MAX_RENDERBUFFER_SIZE");
    __publicField(this, "MAX_TEXTURE_SIZE");
    __publicField(this, "MAX_VIEWPORT_DIMS");
    __publicField(this, "MAX_VERTEX_TEXTURE_IMAGE_UNITS");
    __publicField(this, "MAX_TEXTURE_IMAGE_UNITS");
    __publicField(this, "MAX_COMBINED_TEXTURE_IMAGE_UNITS");
    __publicField(this, "MAX_VERTEX_ATTRIBS");
    __publicField(this, "MAX_VARYING_VECTORS");
    __publicField(this, "MAX_VERTEX_UNIFORM_VECTORS");
    __publicField(this, "MAX_FRAGMENT_UNIFORM_VECTORS");
    __publicField(this, "TEXTURE_MAG_FILTER");
    __publicField(this, "TEXTURE_MIN_FILTER");
    __publicField(this, "TEXTURE_WRAP_S");
    __publicField(this, "TEXTURE_WRAP_T");
    __publicField(this, "LINEAR");
    __publicField(this, "CLAMP_TO_EDGE");
    __publicField(this, "RGBA");
    __publicField(this, "UNSIGNED_BYTE");
    __publicField(this, "UNPACK_PREMULTIPLY_ALPHA_WEBGL");
    __publicField(this, "UNPACK_FLIP_Y_WEBGL");
    __publicField(this, "FLOAT");
    __publicField(this, "TRIANGLES");
    __publicField(this, "UNSIGNED_SHORT");
    __publicField(this, "ONE");
    __publicField(this, "ONE_MINUS_SRC_ALPHA");
    __publicField(this, "VERTEX_SHADER");
    __publicField(this, "FRAGMENT_SHADER");
    __publicField(this, "STATIC_DRAW");
    __publicField(this, "COMPILE_STATUS");
    __publicField(this, "LINK_STATUS");
    __publicField(this, "DYNAMIC_DRAW");
    __publicField(this, "COLOR_ATTACHMENT0");
    this.gl = gl;
    this.activeTextureUnit = gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0;
    const maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.texture2dUnits = new Array(maxTextureUnits).fill(void 0).map((_, i) => {
      this.activeTexture(i);
      return gl.getParameter(gl.TEXTURE_BINDING_2D);
    });
    this.activeTexture(this.activeTextureUnit);
    this.scissorEnabled = gl.isEnabled(gl.SCISSOR_TEST);
    const scissorBox = gl.getParameter(gl.SCISSOR_BOX);
    this.scissorX = scissorBox[0];
    this.scissorY = scissorBox[1];
    this.scissorWidth = scissorBox[2];
    this.scissorHeight = scissorBox[3];
    this.blendEnabled = gl.isEnabled(gl.BLEND);
    this.blendSrcRgb = gl.getParameter(gl.BLEND_SRC_RGB);
    this.blendDstRgb = gl.getParameter(gl.BLEND_DST_RGB);
    this.blendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
    this.blendDstAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
    this.boundArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
    this.boundElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
    this.curProgram = gl.getParameter(gl.CURRENT_PROGRAM);
    this.canvas = gl.canvas;
    this.MAX_RENDERBUFFER_SIZE = gl.MAX_RENDERBUFFER_SIZE;
    this.MAX_TEXTURE_SIZE = gl.MAX_TEXTURE_SIZE;
    this.MAX_VIEWPORT_DIMS = gl.MAX_VIEWPORT_DIMS;
    this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
    this.MAX_TEXTURE_IMAGE_UNITS = gl.MAX_TEXTURE_IMAGE_UNITS;
    this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS;
    this.MAX_VERTEX_ATTRIBS = gl.MAX_VERTEX_ATTRIBS;
    this.MAX_VARYING_VECTORS = gl.MAX_VARYING_VECTORS;
    this.MAX_VERTEX_UNIFORM_VECTORS = gl.MAX_VERTEX_UNIFORM_VECTORS;
    this.MAX_FRAGMENT_UNIFORM_VECTORS = gl.MAX_FRAGMENT_UNIFORM_VECTORS;
    this.TEXTURE_MAG_FILTER = gl.TEXTURE_MAG_FILTER;
    this.TEXTURE_MIN_FILTER = gl.TEXTURE_MIN_FILTER;
    this.TEXTURE_WRAP_S = gl.TEXTURE_WRAP_S;
    this.TEXTURE_WRAP_T = gl.TEXTURE_WRAP_T;
    this.LINEAR = gl.LINEAR;
    this.CLAMP_TO_EDGE = gl.CLAMP_TO_EDGE;
    this.RGBA = gl.RGBA;
    this.UNSIGNED_BYTE = gl.UNSIGNED_BYTE;
    this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL;
    this.UNPACK_FLIP_Y_WEBGL = gl.UNPACK_FLIP_Y_WEBGL;
    this.FLOAT = gl.FLOAT;
    this.TRIANGLES = gl.TRIANGLES;
    this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
    this.ONE = gl.ONE;
    this.ONE_MINUS_SRC_ALPHA = gl.ONE_MINUS_SRC_ALPHA;
    this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
    this.TRIANGLES = gl.TRIANGLES;
    this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
    this.VERTEX_SHADER = gl.VERTEX_SHADER;
    this.FRAGMENT_SHADER = gl.FRAGMENT_SHADER;
    this.STATIC_DRAW = gl.STATIC_DRAW;
    this.COMPILE_STATUS = gl.COMPILE_STATUS;
    this.LINK_STATUS = gl.LINK_STATUS;
    this.DYNAMIC_DRAW = gl.DYNAMIC_DRAW;
    this.COLOR_ATTACHMENT0 = gl.COLOR_ATTACHMENT0;
  }
  /**
   * Returns true if the WebGL context is WebGL2
   *
   * @returns
   */
  isWebGl2() {
    return isWebGl2(this.gl);
  }
  /**
   * ```
   * gl.activeTexture(textureUnit + gl.TEXTURE0);
   * ```
   *
   * @remarks
   * **WebGL Difference**: `textureUnit` is based from 0, not `gl.TEXTURE0`.
   *
   * @param textureUnit
   */
  activeTexture(textureUnit) {
    const { gl } = this;
    if (this.activeTextureUnit !== textureUnit) {
      gl.activeTexture(textureUnit + gl.TEXTURE0);
      this.activeTextureUnit = textureUnit;
    }
  }
  /**
   * ```
   * gl.bindTexture(gl.TEXTURE_2D, texture);
   * ```
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
   *
   * @param texture
   */
  bindTexture(texture) {
    const { gl, activeTextureUnit, texture2dUnits } = this;
    if (texture2dUnits[activeTextureUnit] === texture) {
      return;
    }
    texture2dUnits[activeTextureUnit] = texture;
    gl.bindTexture(this.gl.TEXTURE_2D, texture);
  }
  _getActiveTexture() {
    const { activeTextureUnit, texture2dUnits } = this;
    return texture2dUnits[activeTextureUnit];
  }
  /**
   * ```
   * gl.texParameteri(gl.TEXTURE_2D, pname, param);
   * ```
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
   *
   * @param pname
   * @param param
   * @returns
   */
  texParameteri(pname, param) {
    const { gl, texture2dParams } = this;
    const activeTexture = this._getActiveTexture();
    if (!activeTexture) {
      throw new Error("No active texture");
    }
    let textureParams = texture2dParams.get(activeTexture);
    if (!textureParams) {
      textureParams = {};
      texture2dParams.set(activeTexture, textureParams);
    }
    if (textureParams[pname] === param) {
      return;
    }
    textureParams[pname] = param;
    gl.texParameteri(gl.TEXTURE_2D, pname, param);
  }
  texImage2D(level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels) {
    const { gl } = this;
    if (format) {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels);
    } else {
      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource);
    }
  }
  /**
   * ```
   * gl.compressedTexImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, data);
   * ```
   *
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
   */
  compressedTexImage2D(level, internalformat, width, height, border, data) {
    const { gl } = this;
    gl.compressedTexImage2D(gl.TEXTURE_2D, level, internalformat, width, height, border, data);
  }
  /**
   * ```
   * gl.pixelStorei(pname, param);
   * ```
   *
   * @param pname
   * @param param
   */
  pixelStorei(pname, param) {
    const { gl } = this;
    gl.pixelStorei(pname, param);
  }
  /**
   * ```
   * gl.generateMipmap(gl.TEXTURE_2D);
   * ```
   *
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
   */
  generateMipmap() {
    const { gl } = this;
    gl.generateMipmap(gl.TEXTURE_2D);
  }
  /**
   * ```
   * gl.createTexture();
   * ```
   *
   * @returns
   */
  createTexture() {
    const { gl } = this;
    return gl.createTexture();
  }
  /**
   * ```
   * gl.deleteTexture(texture);
   * ```
   *
   * @param texture
   */
  deleteTexture(texture) {
    const { gl } = this;
    if (texture) {
      this.texture2dParams.delete(texture);
    }
    gl.deleteTexture(texture);
  }
  /**
   * ```
   * gl.viewport(x, y, width, height);
   * ```
   */
  viewport(x, y, width, height) {
    const { gl } = this;
    gl.viewport(x, y, width, height);
  }
  /**
   * ```
   * gl.clearColor(red, green, blue, alpha);
   * ```
   *
   * @param red
   * @param green
   * @param blue
   * @param alpha
   */
  clearColor(red, green, blue, alpha) {
    const { gl } = this;
    gl.clearColor(red, green, blue, alpha);
  }
  /**
   * ```
   * gl["enable"|"disable"](gl.SCISSOR_TEST);
   * ```
   * @param enable
   */
  setScissorTest(enable) {
    const { gl, scissorEnabled } = this;
    if (enable === scissorEnabled) {
      return;
    }
    if (enable) {
      gl.enable(gl.SCISSOR_TEST);
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
    this.scissorEnabled = enable;
  }
  /**
   * ```
   * gl.scissor(x, y, width, height);
   * ```
   *
   * @param x
   * @param y
   * @param width
   * @param height
   */
  scissor(x, y, width, height) {
    const { gl, scissorX, scissorY, scissorWidth, scissorHeight } = this;
    if (x !== scissorX || y !== scissorY || width !== scissorWidth || height !== scissorHeight) {
      gl.scissor(x, y, width, height);
      this.scissorX = x;
      this.scissorY = y;
      this.scissorWidth = width;
      this.scissorHeight = height;
    }
  }
  /**
   * ```
   * gl["enable"|"disable"](gl.BLEND);
   * ```
   *
   * @param blend
   * @returns
   */
  setBlend(blend) {
    const { gl, blendEnabled } = this;
    if (blend === blendEnabled) {
      return;
    }
    if (blend) {
      gl.enable(gl.BLEND);
    } else {
      gl.disable(gl.BLEND);
    }
    this.blendEnabled = blend;
  }
  /**
   * ```
   * gl.blendFunc(src, dst);
   * ```
   *
   * @param src
   * @param dst
   */
  blendFunc(src, dst) {
    const { gl, blendSrcRgb, blendDstRgb, blendSrcAlpha, blendDstAlpha } = this;
    if (src !== blendSrcRgb || dst !== blendDstRgb || src !== blendSrcAlpha || dst !== blendDstAlpha) {
      gl.blendFunc(src, dst);
      this.blendSrcRgb = src;
      this.blendDstRgb = dst;
      this.blendSrcAlpha = src;
      this.blendDstAlpha = dst;
    }
  }
  /**
   * ```
   * gl.createBuffer();
   * ```
   *
   * @returns
   */
  createBuffer() {
    const { gl } = this;
    return gl.createBuffer();
  }
  /**
   * ```
   * gl.createFramebuffer();
   * ```
   * @returns
   */
  createFramebuffer() {
    const { gl } = this;
    return gl.createFramebuffer();
  }
  /**
   * ```
   * gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
   * ```
   *
   * @param framebuffer
   */
  bindFramebuffer(framebuffer) {
    const { gl } = this;
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  }
  /**
   * ```
   * gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
   * ```
   * @remarks
   * **WebGL Difference**: Bind target is always `gl.FRAMEBUFFER` and textarget is always `gl.TEXTURE_2D`
   */
  framebufferTexture2D(attachment, texture, level) {
    const { gl } = this;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, level);
  }
  /**
   * ```
   * gl.clear(gl.COLOR_BUFFER_BIT);
   * ```
   *
   * @remarks
   * **WebGL Difference**: Clear mask is always `gl.COLOR_BUFFER_BIT`
   */
  clear() {
    const { gl } = this;
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  /**
   * ```
   * gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
   * gl.bufferData(gl.ARRAY_BUFFER, data, usage);
   * ```
   *
   * @remarks
   * **WebGL Combo**: `gl.bindBuffer` and `gl.bufferData` are combined into one function.
   *
   * @param buffer
   * @param data
   * @param usage
   */
  arrayBufferData(buffer, data, usage) {
    const { gl, boundArrayBuffer } = this;
    if (boundArrayBuffer !== buffer) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      this.boundArrayBuffer = buffer;
    }
    gl.bufferData(gl.ARRAY_BUFFER, data, usage);
  }
  /**
   * ```
   * gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
   * gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, usage);
   * ```
   * @remarks
   * **WebGL Combo**: `gl.bindBuffer` and `gl.bufferData` are combined into one function.
   *
   * @param buffer
   * @param data
   * @param usage
   */
  elementArrayBufferData(buffer, data, usage) {
    const { gl, boundElementArrayBuffer } = this;
    if (boundElementArrayBuffer !== buffer) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
      this.boundElementArrayBuffer = buffer;
    }
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, usage);
  }
  /**
   * ```
   * gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
   * gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
   * ```
   *
   * @remarks
   * **WebGL Combo**: `gl.bindBuffer` and `gl.vertexAttribPointer` are combined into one function.
   *
   * @param buffer
   * @param index
   * @param size
   * @param type
   * @param normalized
   * @param stride
   * @param offset
   */
  vertexAttribPointer(buffer, index, size, type, normalized, stride, offset) {
    const { gl, boundArrayBuffer } = this;
    if (boundArrayBuffer !== buffer) {
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      this.boundArrayBuffer = buffer;
    }
    gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
  }
  /**
   * ```
   * gl.useProgram(program);
   * ```
   *
   * @param program
   * @returns
   */
  useProgram(program) {
    const { gl, curProgram } = this;
    if (curProgram === program) {
      return;
    }
    gl.useProgram(program);
    this.curProgram = program;
  }
  /**
   * Sets the value of a single float uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The value to set.
   */
  uniform1f(location, v0) {
    const { gl } = this;
    gl.uniform1f(location, v0);
  }
  /**
   * Sets the value of a float array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of values to set.
   */
  uniform1fv(location, value) {
    const { gl } = this;
    gl.uniform1fv(location, value);
  }
  /**
   * Sets the value of a single integer uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The value to set.
   */
  uniform1i(location, v0) {
    const { gl } = this;
    gl.uniform1i(location, v0);
  }
  /**
   * Sets the value of an integer array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of values to set.
   */
  uniform1iv(location, value) {
    const { gl } = this;
    gl.uniform1iv(location, value);
  }
  /**
   * Sets the value of a vec2 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   */
  uniform2f(location, v0, v1) {
    const { gl } = this;
    gl.uniform2f(location, v0, v1);
  }
  /**
   * Sets the value of a vec2 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of vec2 values to set.
   */
  uniform2fv(location, value) {
    const { gl } = this;
    gl.uniform2fv(location, value);
  }
  /**
   * Sets the value of a ivec2 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   */
  uniform2i(location, v0, v1) {
    const { gl } = this;
    gl.uniform2i(location, v0, v1);
  }
  /**
   * Sets the value of an ivec2 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of ivec2 values to set.
   */
  uniform2iv(location, value) {
    const { gl } = this;
    gl.uniform2iv(location, value);
  }
  /**
   * Sets the value of a vec3 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   * @param v2 - The third component of the vector.
   */
  uniform3f(location, v0, v1, v2) {
    const { gl } = this;
    gl.uniform3f(location, v0, v1, v2);
  }
  /**
   * Sets the value of a vec3 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of vec3 values to set.
   */
  uniform3fv(location, value) {
    const { gl } = this;
    gl.uniform3fv(location, value);
  }
  /**
   * Sets the value of a ivec3 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   * @param v2 - The third component of the vector.
   */
  uniform3i(location, v0, v1, v2) {
    const { gl } = this;
    gl.uniform3i(location, v0, v1, v2);
  }
  /**
   * Sets the value of an ivec3 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of ivec3 values to set.
   */
  uniform3iv(location, value) {
    const { gl } = this;
    gl.uniform3iv(location, value);
  }
  /**
   * Sets the value of a vec4 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   * @param v2 - The third component of the vector.
   * @param v3 - The fourth component of the vector.
   */
  uniform4f(location, v0, v1, v2, v3) {
    const { gl } = this;
    gl.uniform4f(location, v0, v1, v2, v3);
  }
  /**
   * Sets the value of a vec4 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of vec4 values to set.
   */
  uniform4fv(location, value) {
    const { gl } = this;
    gl.uniform4fv(location, value);
  }
  /**
   * Sets the value of a ivec4 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param v0 - The first component of the vector.
   * @param v1 - The second component of the vector.
   * @param v2 - The third component of the vector.
   * @param v3 - The fourth component of the vector.
   */
  uniform4i(location, v0, v1, v2, v3) {
    const { gl } = this;
    gl.uniform4i(location, v0, v1, v2, v3);
  }
  /**
   * Sets the value of an ivec4 array uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param value - The array of ivec4 values to set.
   */
  uniform4iv(location, value) {
    const { gl } = this;
    gl.uniform4iv(location, value);
  }
  /**
   * Sets the value of a mat2 uniform variable.
   *
   * @param location - The location of the uniform variable.
   * @param transpose - Whether to transpose the matrix.
   * @param value - The array of mat2 values to set.
   */
  uniformMatrix2fv(location, value) {
    const { gl } = this;
    gl.uniformMatrix2fv(location, false, value);
  }
  /**
   * Sets the value of a mat2 uniform variable.
   * @param location - The location of the uniform variable.
   * @param value - The array of mat2 values to set.
   */
  uniformMatrix3fv(location, value) {
    const { gl } = this;
    gl.uniformMatrix3fv(location, false, value);
  }
  /**
   * Sets the value of a mat4 uniform variable.
   * @param location - The location of the uniform variable.
   * @param value - The array of mat4 values to set.
   */
  uniformMatrix4fv(location, value) {
    const { gl } = this;
    gl.uniformMatrix4fv(location, false, value);
  }
  /**
   * ```
   * gl.getParameter(pname);
   * ```
   *
   * @param pname
   * @returns
   */
  getParameter(pname) {
    const { gl } = this;
    return gl.getParameter(pname);
  }
  /**
   * ```
   * gl.drawElements(mode, count, type, offset);
   * ```
   *
   * @param mode
   * @param count
   * @param type
   * @param offset
   */
  drawElements(mode, count, type, offset) {
    const { gl } = this;
    gl.drawElements(mode, count, type, offset);
  }
  /**
   * ```
   * gl.drawArrays(mode, first, count);
   * ```
   *
   * @param name
   * @returns
   */
  getExtension(name) {
    const { gl } = this;
    return gl.getExtension(name);
  }
  /**
   * ```
   * gl.createVertexArray();
   * ```
   *
   * @returns
   */
  createVertexArray() {
    const { gl } = this;
    assertTruthy(gl instanceof WebGL2RenderingContext);
    return gl.createVertexArray();
  }
  /**
   * ```
   * gl.bindVertexArray(vertexArray);
   * ```
   *
   * @param vertexArray
   */
  bindVertexArray(vertexArray) {
    const { gl } = this;
    assertTruthy(gl instanceof WebGL2RenderingContext);
    gl.bindVertexArray(vertexArray);
  }
  /**
   * ```
   * gl.getAttribLocation(program, name);
   * ```
   *
   * @param program
   * @param name
   * @returns
   */
  getAttribLocation(program, name) {
    const { gl } = this;
    return gl.getAttribLocation(program, name);
  }
  /**
   * ```
   * gl.getUniformLocation(program, name);
   * ```
   *
   * @param program
   * @param name
   * @returns
   */
  getUniformLocation(program, name) {
    const { gl } = this;
    return gl.getUniformLocation(program, name);
  }
  /**
   * ```
   * gl.enableVertexAttribArray(index);
   * ```
   *
   * @param index
   */
  enableVertexAttribArray(index) {
    const { gl } = this;
    gl.enableVertexAttribArray(index);
  }
  /**
   * ```
   * gl.disableVertexAttribArray(index);
   * ```
   *
   * @param index
   */
  disableVertexAttribArray(index) {
    const { gl } = this;
    gl.disableVertexAttribArray(index);
  }
  /**
   * ```
   * gl.createShader(type);
   * ```
   *
   * @param type
   * @returns
   */
  createShader(type) {
    const { gl } = this;
    return gl.createShader(type);
  }
  /**
   * ```
   * gl.compileShader(shader);
   * ```
   *
   * @param shader
   * @returns
   */
  compileShader(shader) {
    const { gl } = this;
    gl.compileShader(shader);
  }
  /**
   * ```
   * gl.attachShader(program, shader);
   * ```
   *
   * @param program
   * @param shader
   */
  attachShader(program, shader) {
    const { gl } = this;
    gl.attachShader(program, shader);
  }
  /**
   * ```
   * gl.linkProgram(program);
   * ```
   *
   * @param program
   */
  linkProgram(program) {
    const { gl } = this;
    gl.linkProgram(program);
  }
  /**
   * ```
   * gl.deleteProgram(shader);
   * ```
   *
   * @param shader
   */
  deleteProgram(shader) {
    const { gl } = this;
    gl.deleteProgram(shader);
  }
  /**
   * ```
   * gl.getShaderParameter(shader, pname);
   * ```
   *
   * @param shader
   * @param pname
   */
  getShaderParameter(shader, pname) {
    const { gl } = this;
    return gl.getShaderParameter(shader, pname);
  }
  /**
   * ```
   * gl.getShaderInfoLog(shader);
   * ```
   *
   * @param shader
   */
  getShaderInfoLog(shader) {
    const { gl } = this;
    return gl.getShaderInfoLog(shader);
  }
  /**
   * ```
   * gl.createProgram();
   * ```
   *
   * @returns
   */
  createProgram() {
    const { gl } = this;
    return gl.createProgram();
  }
  /**
   * ```
   * gl.getProgramParameter(program, pname);
   * ```
   *
   * @param program
   * @param pname
   * @returns
   */
  getProgramParameter(program, pname) {
    const { gl } = this;
    return gl.getProgramParameter(program, pname);
  }
  /**
   * ```
   * gl.getProgramInfoLog(program);
   * ```
   *
   * @param program
   * @returns
   */
  getProgramInfoLog(program) {
    const { gl } = this;
    return gl.getProgramInfoLog(program);
  }
  /**
   * ```
   * gl.shaderSource(shader, source);
   * ```
   *
   * @param shader
   * @param source
   */
  shaderSource(shader, source) {
    const { gl } = this;
    gl.shaderSource(shader, source);
  }
  /**
   * ```
   * gl.deleteShader(shader);
   * ```
   *
   * @param shader
   */
  deleteShader(shader) {
    const { gl } = this;
    gl.deleteShader(shader);
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreCtxRenderTexture.js
var WebGlCoreCtxRenderTexture = class extends WebGlCoreCtxTexture {
  constructor(glw, memManager, textureSource) {
    super(glw, memManager, textureSource);
    __publicField(this, "framebuffer");
    const framebuffer = glw.createFramebuffer();
    assertTruthy(framebuffer, "Unable to create framebuffer");
    this.framebuffer = framebuffer;
  }
  async onLoadRequest() {
    const { glw } = this;
    const nativeTexture = this._nativeCtxTexture = this.createNativeCtxTexture();
    const { width, height } = this.textureSource;
    glw.texImage2D(0, glw.RGBA, width, height, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
    this.setTextureMemUse(width * height * 4);
    glw.bindFramebuffer(this.framebuffer);
    glw.framebufferTexture2D(glw.COLOR_ATTACHMENT0, nativeTexture, 0);
    glw.bindFramebuffer(null);
    return {
      width,
      height
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/webgl/WebGlCoreRenderer.js
var WORDS_PER_QUAD = 24;
var WebGlCoreRenderer = class extends CoreRenderer {
  constructor(options) {
    super(options);
    //// WebGL Native Context and Data
    __publicField(this, "glw");
    __publicField(this, "system");
    //// Persistent data
    __publicField(this, "quadBuffer");
    __publicField(this, "fQuadBuffer");
    __publicField(this, "uiQuadBuffer");
    __publicField(this, "renderOps", []);
    //// Render Op / Buffer Filling State
    __publicField(this, "curBufferIdx", 0);
    __publicField(this, "curRenderOp", null);
    __publicField(this, "rttNodes", []);
    __publicField(this, "activeRttNode", null);
    //// Default Shader
    __publicField(this, "defShaderCtrl");
    __publicField(this, "defaultShader");
    __publicField(this, "quadBufferCollection");
    /**
     * White pixel texture used by default when no texture is specified.
     */
    __publicField(this, "defaultTexture");
    __publicField(this, "quadBufferUsage", 0);
    /**
     * Whether the renderer is currently rendering to a texture.
     */
    __publicField(this, "renderToTextureActive", false);
    this.quadBuffer = new ArrayBuffer(this.stage.options.quadBufferSize);
    this.fQuadBuffer = new Float32Array(this.quadBuffer);
    this.uiQuadBuffer = new Uint32Array(this.quadBuffer);
    this.mode = "webgl";
    const { canvas, clearColor, bufferMemory: bufferMemory2 } = options;
    this.defaultTexture = new ColorTexture(this.txManager);
    this.defaultTexture.setRenderableOwner(this, true);
    this.defaultTexture.once("loaded", () => {
      this.stage.requestRender();
    });
    const gl = createWebGLContext(canvas, options.forceWebGL2, options.contextSpy);
    const glw = this.glw = new WebGlContextWrapper(gl);
    const color = getNormalizedRgbaComponents(clearColor);
    glw.viewport(0, 0, canvas.width, canvas.height);
    glw.clearColor(color[0], color[1], color[2], color[3]);
    glw.setBlend(true);
    glw.blendFunc(glw.ONE, glw.ONE_MINUS_SRC_ALPHA);
    createIndexBuffer(glw, bufferMemory2);
    this.system = {
      parameters: getWebGlParameters(this.glw),
      extensions: getWebGlExtensions(this.glw)
    };
    this.shManager.renderer = this;
    this.defShaderCtrl = this.shManager.loadShader("DefaultShader");
    this.defaultShader = this.defShaderCtrl.shader;
    const quadBuffer = glw.createBuffer();
    assertTruthy(quadBuffer);
    const stride = 6 * Float32Array.BYTES_PER_ELEMENT;
    this.quadBufferCollection = new BufferCollection([
      {
        buffer: quadBuffer,
        attributes: {
          a_position: {
            name: "a_position",
            size: 2,
            type: glw.FLOAT,
            normalized: false,
            stride,
            offset: 0
            // start at the beginning of the buffer
          },
          a_textureCoordinate: {
            name: "a_textureCoordinate",
            size: 2,
            type: glw.FLOAT,
            normalized: false,
            stride,
            offset: 2 * Float32Array.BYTES_PER_ELEMENT
          },
          a_color: {
            name: "a_color",
            size: 4,
            type: glw.UNSIGNED_BYTE,
            normalized: true,
            stride,
            offset: 4 * Float32Array.BYTES_PER_ELEMENT
          },
          a_textureIndex: {
            name: "a_textureIndex",
            size: 1,
            type: glw.FLOAT,
            normalized: false,
            stride,
            offset: 5 * Float32Array.BYTES_PER_ELEMENT
          }
        }
      }
    ]);
  }
  reset() {
    const { glw } = this;
    this.curBufferIdx = 0;
    this.curRenderOp = null;
    this.renderOps.length = 0;
    glw.setScissorTest(false);
    glw.clear();
  }
  getShaderManager() {
    return this.shManager;
  }
  createCtxTexture(textureSource) {
    if (textureSource instanceof SubTexture) {
      return new WebGlCoreCtxSubTexture(this.glw, this.txMemManager, textureSource);
    } else if (textureSource instanceof RenderTexture) {
      return new WebGlCoreCtxRenderTexture(this.glw, this.txMemManager, textureSource);
    }
    return new WebGlCoreCtxTexture(this.glw, this.txMemManager, textureSource);
  }
  /**
   * This function adds a quad (a rectangle composed of two triangles) to the WebGL rendering pipeline.
   *
   * It takes a set of options that define the quad's properties, such as its dimensions, colors, texture, shader, and transformation matrix.
   * The function first updates the shader properties with the current dimensions if necessary, then sets the default texture if none is provided.
   * It then checks if a new render operation is needed, based on the current shader and clipping rectangle.
   * If a new render operation is needed, it creates one and updates the current render operation.
   * The function then adjusts the texture coordinates based on the texture options and adds the texture to the texture manager.
   *
   * Finally, it calculates the vertices for the quad, taking into account any transformations, and adds them to the quad buffer.
   * The function updates the length and number of quads in the current render operation, and updates the current buffer index.
   */
  addQuad(params) {
    const { fQuadBuffer, uiQuadBuffer } = this;
    let texture = params.texture || this.defaultTexture;
    if (params.shaderProps !== null) {
      if (hasOwn(params.shaderProps, "$dimensions") == true) {
        const dimensions = params.shaderProps.$dimensions;
        dimensions.width = params.width;
        dimensions.height = params.height;
      }
      if (hasOwn(params.shaderProps, "$alpha") === true) {
        params.shaderProps.$alpha = params.alpha;
      }
    }
    assertTruthy(texture.ctxTexture !== void 0, "Invalid texture type");
    let { curBufferIdx: bufferIdx, curRenderOp } = this;
    const targetDims = { width: -1, height: -1 };
    targetDims.width = params.width;
    targetDims.height = params.height;
    const targetShader = params.shader || this.defaultShader;
    assertTruthy(targetShader.getUniformLocation !== void 0, "Invalid WebGL shader");
    if (this.reuseRenderOp(params) === false) {
      this.newRenderOp(targetShader, params.shaderProps, params.alpha, targetDims, params.clippingRect, bufferIdx, params.rtt, params.parentHasRenderTexture, params.framebufferDimensions);
      curRenderOp = this.curRenderOp;
      assertTruthy(curRenderOp);
    }
    let texCoordX1 = 0;
    let texCoordY1 = 0;
    let texCoordX2 = 1;
    let texCoordY2 = 1;
    if (texture.type === TextureType.subTexture) {
      const { x: tx, y: ty, width: tw, height: th } = texture.props;
      const { width: parentW = 0, height: parentH = 0 } = texture.parentTexture.dimensions || { width: 0, height: 0 };
      texCoordX1 = tx / parentW;
      texCoordX2 = texCoordX1 + tw / parentW;
      texCoordY1 = ty / parentH;
      texCoordY2 = texCoordY1 + th / parentH;
      texture = texture.parentTexture;
    }
    if (texture.type === TextureType.image && params.textureOptions !== null && params.textureOptions.resizeMode !== void 0 && texture.dimensions !== null) {
      const resizeMode = params.textureOptions.resizeMode;
      const { width: tw, height: th } = texture.dimensions;
      if (resizeMode.type === "cover") {
        const scaleX = params.width / tw;
        const scaleY = params.height / th;
        const scale = Math.max(scaleX, scaleY);
        const precision = 1 / scale;
        if (scale && scaleX && scaleX < scale) {
          const desiredSize = precision * params.width;
          texCoordX1 = (1 - desiredSize / tw) * (resizeMode.clipX ?? 0.5);
          texCoordX2 = texCoordX1 + desiredSize / tw;
        }
        if (scale && scaleY && scaleY < scale) {
          const desiredSize = precision * params.height;
          texCoordY1 = (1 - desiredSize / th) * (resizeMode.clipY ?? 0.5);
          texCoordY2 = texCoordY1 + desiredSize / th;
        }
      }
    }
    let flipY = 0;
    if (params.textureOptions !== null) {
      if (params.textureOptions.flipX === true) {
        [texCoordX1, texCoordX2] = [texCoordX2, texCoordX1];
      }
      flipY = +(params.textureOptions.flipY || false);
    }
    if (flipY ^ +(texture.type === TextureType.renderToTexture)) {
      [texCoordY1, texCoordY2] = [texCoordY2, texCoordY1];
    }
    const ctxTexture = texture.ctxTexture;
    assertTruthy(ctxTexture.ctxTexture !== void 0);
    const textureIdx = this.addTexture(ctxTexture, bufferIdx);
    assertTruthy(this.curRenderOp !== null);
    if (params.renderCoords) {
      fQuadBuffer[bufferIdx++] = params.renderCoords.x1;
      fQuadBuffer[bufferIdx++] = params.renderCoords.y1;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = params.renderCoords.x2;
      fQuadBuffer[bufferIdx++] = params.renderCoords.y2;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = params.renderCoords.x4;
      fQuadBuffer[bufferIdx++] = params.renderCoords.y4;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = params.renderCoords.x3;
      fQuadBuffer[bufferIdx++] = params.renderCoords.y3;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBr;
      fQuadBuffer[bufferIdx++] = textureIdx;
    } else if (params.tb !== 0 || params.tc !== 0) {
      fQuadBuffer[bufferIdx++] = params.tx;
      fQuadBuffer[bufferIdx++] = params.ty;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = params.tx + params.width * params.ta;
      fQuadBuffer[bufferIdx++] = params.ty + params.width * params.tc;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = params.tx + params.height * params.tb;
      fQuadBuffer[bufferIdx++] = params.ty + params.height * params.td;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = params.tx + params.width * params.ta + params.height * params.tb;
      fQuadBuffer[bufferIdx++] = params.ty + params.width * params.tc + params.height * params.td;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBr;
      fQuadBuffer[bufferIdx++] = textureIdx;
    } else {
      const rightCornerX = params.tx + params.width * params.ta;
      const rightCornerY = params.ty + params.height * params.td;
      fQuadBuffer[bufferIdx++] = params.tx;
      fQuadBuffer[bufferIdx++] = params.ty;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = rightCornerX;
      fQuadBuffer[bufferIdx++] = params.ty;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY1;
      uiQuadBuffer[bufferIdx++] = params.colorTr;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = params.tx;
      fQuadBuffer[bufferIdx++] = rightCornerY;
      fQuadBuffer[bufferIdx++] = texCoordX1;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBl;
      fQuadBuffer[bufferIdx++] = textureIdx;
      fQuadBuffer[bufferIdx++] = rightCornerX;
      fQuadBuffer[bufferIdx++] = rightCornerY;
      fQuadBuffer[bufferIdx++] = texCoordX2;
      fQuadBuffer[bufferIdx++] = texCoordY2;
      uiQuadBuffer[bufferIdx++] = params.colorBr;
      fQuadBuffer[bufferIdx++] = textureIdx;
    }
    this.curRenderOp.length += WORDS_PER_QUAD;
    this.curRenderOp.numQuads++;
    this.curBufferIdx = bufferIdx;
  }
  /**
   * Replace the existing RenderOp with a new one that uses the specified Shader
   * and starts at the specified buffer index.
   *
   * @param shader
   * @param bufferIdx
   */
  newRenderOp(shader, shaderProps, alpha, dimensions, clippingRect, bufferIdx, renderToTexture, parentHasRenderTexture, framebufferDimensions) {
    const curRenderOp = new WebGlCoreRenderOp(
      this.glw,
      this.options,
      this.quadBufferCollection,
      shader,
      shaderProps,
      alpha,
      clippingRect,
      dimensions,
      bufferIdx,
      0,
      // Z-Index is only used for explictly added Render Ops
      renderToTexture,
      parentHasRenderTexture,
      framebufferDimensions
    );
    this.curRenderOp = curRenderOp;
    this.renderOps.push(curRenderOp);
  }
  /**
   * Add a texture to the current RenderOp. If the texture cannot be added to the
   * current RenderOp, a new RenderOp will be created and the texture will be added
   * to that one.
   *
   * If the texture cannot be added to the new RenderOp, an error will be thrown.
   *
   * @param texture
   * @param bufferIdx
   * @param recursive
   * @returns Assigned Texture Index of the texture in the render op
   */
  addTexture(texture, bufferIdx, recursive) {
    const { curRenderOp } = this;
    assertTruthy(curRenderOp);
    const textureIdx = curRenderOp.addTexture(texture);
    if (textureIdx === 4294967295) {
      if (recursive) {
        throw new Error("Unable to add texture to render op");
      }
      this.newRenderOp(curRenderOp.shader, curRenderOp.shaderProps, curRenderOp.alpha, curRenderOp.dimensions, curRenderOp.clippingRect, bufferIdx);
      return this.addTexture(texture, bufferIdx, true);
    }
    return textureIdx;
  }
  /**
   * Test if the current Render operation can be reused for the specified parameters.
   * @param params
   * @returns
   */
  reuseRenderOp(params) {
    var _a2;
    const { shader, shaderProps, parentHasRenderTexture, rtt, clippingRect } = params;
    const targetShader = shader || this.defaultShader;
    if (((_a2 = this.curRenderOp) == null ? void 0 : _a2.shader) !== targetShader) {
      return false;
    }
    if (!compareRect(this.curRenderOp.clippingRect, clippingRect)) {
      return false;
    }
    if (parentHasRenderTexture || rtt) {
      return false;
    }
    if (this.curRenderOp.shader !== this.defaultShader && (!shaderProps || !this.curRenderOp.shader.canBatchShaderProps(this.curRenderOp.shaderProps, shaderProps))) {
      return false;
    }
    return true;
  }
  /**
   * add RenderOp to the render pipeline
   */
  addRenderOp(renderable) {
    this.renderOps.push(renderable);
    this.curRenderOp = null;
  }
  /**
   * Render the current set of RenderOps to render to the specified surface.
   *
   * TODO: 'screen' is the only supported surface at the moment.
   *
   * @param surface
   */
  render(surface = "screen") {
    const { glw, quadBuffer } = this;
    const arr = new Float32Array(quadBuffer, 0, this.curBufferIdx);
    const buffer = this.quadBufferCollection.getBuffer("a_position") ?? null;
    glw.arrayBufferData(buffer, arr, glw.STATIC_DRAW);
    const doLog = false;
    if (doLog) {
      console.log("renderOps", this.renderOps.length);
    }
    for (let i = 0, length = this.renderOps.length; i < length; i++) {
      const renderOp = this.renderOps[i];
      if (doLog) {
        console.log("Quads per operation", renderOp.numQuads);
      }
      renderOp.draw();
    }
    this.quadBufferUsage = this.curBufferIdx * arr.BYTES_PER_ELEMENT;
  }
  renderToTexture(node) {
    for (let i = 0; i < this.rttNodes.length; i++) {
      if (this.rttNodes[i] === node) {
        return;
      }
    }
    this.insertRTTNodeInOrder(node);
  }
  /**
   * Inserts an RTT node into `this.rttNodes` while maintaining the correct rendering order based on hierarchy.
   *
   * Rendering order for RTT nodes is critical when nested RTT nodes exist in a parent-child relationship.
   * Specifically:
   *  - Child RTT nodes must be rendered before their RTT-enabled parents to ensure proper texture composition.
   *  - If an RTT node is added and it has existing RTT children, it should be rendered after those children.
   *
   * This function addresses both cases by:
   * 1. **Checking Upwards**: It traverses the node's hierarchy upwards to identify any RTT parent
   *    already in `rttNodes`. If an RTT parent is found, the new node is placed before this parent.
   * 2. **Checking Downwards**: It traverses the node’s children recursively to find any RTT-enabled
   *    children that are already in `rttNodes`. If such children are found, the new node is inserted
   *    after the last (highest index) RTT child node.
   *
   * The final calculated insertion index ensures the new node is positioned in `rttNodes` to respect
   * both parent-before-child and child-before-parent rendering rules, preserving the correct order
   * for the WebGL renderer.
   *
   * @param node - The RTT-enabled CoreNode to be added to `rttNodes` in the appropriate hierarchical position.
   */
  insertRTTNodeInOrder(node) {
    let insertIndex = this.rttNodes.length;
    let currentNode = node;
    while (currentNode) {
      if (!currentNode.parent) {
        break;
      }
      const parentIndex = this.rttNodes.indexOf(currentNode.parent);
      if (parentIndex !== -1) {
        insertIndex = parentIndex;
        break;
      }
      currentNode = currentNode.parent;
    }
    const maxChildIndex = this.findMaxChildRTTIndex(node);
    if (maxChildIndex !== -1) {
      insertIndex = Math.max(insertIndex, maxChildIndex + 1);
    }
    this.rttNodes.splice(insertIndex, 0, node);
  }
  // Helper function to find the highest index of any RTT children of a node within rttNodes
  findMaxChildRTTIndex(node) {
    let maxIndex = -1;
    const traverseChildren = (currentNode) => {
      const currentIndex = this.rttNodes.indexOf(currentNode);
      if (currentIndex !== -1) {
        maxIndex = Math.max(maxIndex, currentIndex);
      }
      for (const child of currentNode.children) {
        traverseChildren(child);
      }
    };
    traverseChildren(node);
    return maxIndex;
  }
  renderRTTNodes() {
    const { glw } = this;
    const { txManager } = this.stage;
    for (let i = 0; i < this.rttNodes.length; i++) {
      const node = this.rttNodes[i];
      if (!node || !node.hasRTTupdates) {
        continue;
      }
      this.activeRttNode = node;
      assertTruthy(node.texture, "RTT node missing texture");
      const ctxTexture = node.texture.ctxTexture;
      assertTruthy(ctxTexture instanceof WebGlCoreCtxRenderTexture);
      this.renderToTextureActive = true;
      glw.bindFramebuffer(ctxTexture.framebuffer);
      glw.viewport(0, 0, ctxTexture.w, ctxTexture.h);
      glw.clearColor(0, 0, 0, 0);
      glw.clear();
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        if (!child) {
          continue;
        }
        this.stage.addQuads(child);
        child.hasRTTupdates = false;
      }
      this.render();
      this.renderOps.length = 0;
      node.hasRTTupdates = false;
    }
    const color = getNormalizedRgbaComponents(this.stage.options.clearColor);
    glw.clearColor(color[0], color[1], color[2], color[3]);
    glw.bindFramebuffer(null);
    glw.viewport(0, 0, this.glw.canvas.width, this.glw.canvas.height);
    this.renderToTextureActive = false;
  }
  removeRTTNode(node) {
    const index = this.rttNodes.indexOf(node);
    if (index === -1) {
      return;
    }
    this.rttNodes.splice(index, 1);
  }
  getBufferInfo() {
    const bufferInfo = {
      totalAvailable: this.stage.options.quadBufferSize,
      totalUsed: this.quadBufferUsage
    };
    return bufferInfo;
  }
  getDefShaderCtr() {
    return this.defShaderCtrl;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/SpecialCodepoints.js
var SpecialCodepoints = {
  LINE_FEED: 10,
  CARRIAGE_RETURN: 13,
  SPACE: 32,
  TAB: 9,
  ZERO_WIDTH_SPACE: 8203,
  ZERO_WIDTH_NON_JOINER: 8204,
  ZERO_WIDTH_JOINER: 8205,
  LEFT_TO_RIGHT_MARK: 8206,
  RIGHT_TO_LEFT_MARK: 8207,
  LEFT_TO_RIGHT_EMBEDDING: 8234,
  RIGHT_TO_LEFT_EMBEDDING: 8235,
  POP_DIRECTIONAL_FORMATTING: 8236,
  LEFT_TO_RIGHT_OVERRIDE: 8237,
  RIGHT_TO_LEFT_OVERRIDE: 8238,
  LINE_SEPARATOR: 8232,
  PARAGRAPH_SEPARATOR: 8233,
  OBJECT_REPLACEMENT_CHARACTER: 65532,
  REPLACEMENT_CHARACTER: 65533,
  ZERO_WIDTH_NO_BREAK_SPACE: 65279,
  LEFT_TO_RIGHT_ISOLATE: 8294,
  RIGHT_TO_LEFT_ISOLATE: 8295,
  FIRST_STRONG_ISOLATE: 8296,
  POP_DIRECTIONAL_ISOLATE: 8297,
  INHIBIT_SYMMETRIC_SWAPPING: 8298,
  ACTIVATE_SYMMETRIC_SWAPPING: 8299,
  INHIBIT_ARABIC_FORM_SHAPING: 8300,
  ACTIVATE_ARABIC_FORM_SHAPING: 8301,
  NATIONAL_DIGIT_SHAPES: 8302,
  NOMINAL_DIGIT_SHAPES: 8303,
  LEFT_TO_RIGHT_BOUNDARY: 8206,
  RIGHT_TO_LEFT_BOUNDARY: 8207
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/SdfTrFontFace/internal/FontShaper.js
var FontShaper = class {
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/SdfTrFontFace/internal/SdfFontShaper.js
var SdfFontShaper = class extends FontShaper {
  constructor(data, glyphMap) {
    super();
    __publicField(this, "data");
    __publicField(this, "glyphMap");
    __publicField(this, "kernings");
    this.data = data;
    this.glyphMap = glyphMap;
    const kernings = this.kernings = {};
    data.kernings.forEach((kerning) => {
      const second = kerning.second;
      const firsts = kernings[second] = kernings[second] || {};
      firsts[kerning.first] = kerning.amount;
    });
    this.kernings = kernings;
  }
  *shapeText(props, codepoints) {
    var _a2;
    let codepointResult;
    let lastGlyphId = void 0;
    while ((codepointResult = codepoints.peek()) && !codepointResult.done) {
      const codepoint = codepointResult.value;
      const glyph = this.glyphMap.get(codepoint);
      codepoints.next();
      if (glyph !== void 0) {
        const kerning = lastGlyphId !== void 0 ? (((_a2 = this.kernings[glyph.id]) == null ? void 0 : _a2[lastGlyphId]) || 0) + props.letterSpacing : 0;
        lastGlyphId = glyph.id;
        yield {
          mapped: true,
          glyphId: glyph.id,
          codepoint,
          cluster: codepoints.lastIndex,
          xAdvance: glyph.xadvance + kerning,
          yAdvance: 0,
          xOffset: glyph.xoffset + kerning,
          yOffset: glyph.yoffset,
          xBearing: 0,
          yBearing: 0,
          width: glyph.width,
          height: glyph.height
        };
      } else {
        if (codepoint === SpecialCodepoints.LINE_FEED) {
          lastGlyphId = void 0;
        }
        yield {
          mapped: false,
          codepoint,
          cluster: codepoints.lastIndex
        };
      }
    }
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/font-face-types/SdfTrFontFace/SdfTrFontFace.js
var SdfTrFontFace = class extends TrFontFace {
  constructor(type, options) {
    super(options);
    __publicField(this, "type");
    __publicField(this, "texture");
    /**
     * Height of the tallest character in the font including the whitespace above it
     * in SDF/vertex units.
     */
    __publicField(this, "maxCharHeight", 0);
    __publicField(this, "data");
    __publicField(this, "shaper");
    __publicField(this, "glyphMap", /* @__PURE__ */ new Map());
    const { atlasUrl, atlasDataUrl, stage: stage2 } = options;
    this.type = type;
    const renderer3 = stage2.renderer;
    assertTruthy(renderer3 instanceof WebGlCoreRenderer, "SDF Font Faces can only be used with the WebGL Renderer");
    this.texture = stage2.txManager.loadTexture("ImageTexture", {
      src: atlasUrl,
      // IMPORTANT: The SDF shader requires the alpha channel to NOT be
      // premultiplied on the atlas texture. If it is premultiplied, the
      // rendering of SDF glyphs (especially single-channel SDF fonts) will
      // be very jagged.
      premultiplyAlpha: false
    });
    this.texture.on("loaded", () => {
      this.checkLoaded();
      stage2.requestRender();
    });
    this.texture.ctxTexture.load();
    fetch(atlasDataUrl).then(async (response) => {
      var _a2;
      this.data = await response.json();
      assertTruthy(this.data);
      let maxCharHeight = 0;
      this.data.chars.forEach((glyph) => {
        this.glyphMap.set(glyph.id, glyph);
        const charHeight = glyph.yoffset + glyph.height;
        if (charHeight > maxCharHeight) {
          maxCharHeight = charHeight;
        }
      });
      this.maxCharHeight = maxCharHeight;
      this.shaper = new SdfFontShaper(this.data, this.glyphMap);
      if (!this.metrics) {
        if ((_a2 = this.data) == null ? void 0 : _a2.lightningMetrics) {
          const { ascender, descender, lineGap, unitsPerEm } = this.data.lightningMetrics;
          this.metrics = {
            ascender: ascender / unitsPerEm,
            descender: descender / unitsPerEm,
            lineGap: lineGap / unitsPerEm
          };
        } else {
          throw new Error(`Font metrics not found in ${this.type} font ${this.fontFamily}. Make sure you are using the latest version of the Lightning 3 \`msdf-generator\` tool to generate your SDF fonts.`);
        }
      }
      this.checkLoaded();
    }).catch(console.error);
  }
  getAtlasEntry(glyphId) {
    const glyph = this.glyphMap.get(glyphId);
    if (glyph === void 0) {
      throw new Error(`Glyph ${glyphId} not found in font ${this.fontFamily}`);
    }
    return {
      x: glyph.x,
      y: glyph.y,
      width: glyph.width,
      height: glyph.height
    };
  }
  checkLoaded() {
    if (this.loaded)
      return;
    if (this.texture.state === "loaded" && this.data) {
      this.loaded = true;
      this.emit("loaded");
    }
  }
};

// node_modules/@lightningjs/blits/src/lib/reactivity/effect.js
var currentEffect = null;
var currentKey = null;
var paused = false;
var pauseTracking = () => {
  paused = true;
};
var resumeTracking = () => {
  paused = false;
};
var objectMap = /* @__PURE__ */ new WeakMap();
var globalEffectsMap = /* @__PURE__ */ new Map();
var removeGlobalEffects = (effectsToRemove) => {
  if (globalEffectsMap.size === 0) return;
  for (const [effect2, target] of globalEffectsMap) {
    if (effectsToRemove.indexOf(effect2) === -1) continue;
    const effectsSet = objectMap.get(target);
    if (effectsSet === void 0) continue;
    for (const set of effectsSet.values()) {
      set.delete(effect2);
      globalEffectsMap.delete(effect2);
    }
  }
};
var track = (target, key, global = false) => {
  if (currentEffect) {
    if (paused) {
      return;
    }
    if (currentKey !== null && key !== currentKey) {
      return;
    }
    let effectsMap = objectMap.get(target);
    if (!effectsMap) {
      effectsMap = /* @__PURE__ */ new Map();
      objectMap.set(target, effectsMap);
    }
    let effects = effectsMap.get(key);
    if (!effects) {
      effects = /* @__PURE__ */ new Set();
      effectsMap.set(key, effects);
    }
    effects.add(currentEffect);
    if (global === true) globalEffectsMap.set(currentEffect, target);
  }
};
var trigger = (target, key, force = false) => {
  if (paused === true) return;
  const effectsMap = objectMap.get(target);
  if (!effectsMap) {
    return;
  }
  const effects = effectsMap.get(key);
  if (effects) {
    for (let effect2 of effects) {
      effect2(force);
    }
  }
};
var effect = (effect2, key = null) => {
  currentEffect = effect2;
  currentKey = key;
  currentEffect();
  currentEffect = null;
  currentKey = null;
};

// node_modules/@lightningjs/blits/src/helpers/deepEqualArray.js
var deepEqualArray = (array1, array2) => {
  if (array1 === array2) return true;
  if (array1.length !== array2.length) return false;
  let l = array1.length;
  while (l--) {
    const value1 = array1[l];
    const value2 = array2[l];
    if (Array.isArray(value1) && Array.isArray(value2)) {
      if (deepEqualArray(value1, value2) === false) return false;
    } else if (typeof value1 === "object" && value1 !== null && typeof value2 === "object" && value2 !== null) {
      if (deepEqualArray(Object.entries(value1), Object.entries(value2)) === false) return false;
    } else if (value1 !== value2) {
      return false;
    }
  }
  return true;
};
var deepEqualArray_default = deepEqualArray;

// node_modules/@lightningjs/blits/src/lib/reactivity/reactive.js
var arrayPatchMethods = ["push", "pop", "shift", "unshift", "splice", "sort"];
var proxyMap = /* @__PURE__ */ new WeakMap();
var getRaw = (value) => {
  const raw = value && value[symbols_default.raw];
  return raw ? getRaw(raw) : value;
};
var reactiveProxy = (original, _parent = null, _key, global) => {
  if (typeof original === "object") {
    if (original[symbols_default.id] !== void 0) return original;
    if (original.constructor.name === ImageTexture.name) return original;
  }
  const existingProxy = proxyMap.get(original);
  if (existingProxy !== void 0) {
    return existingProxy;
  }
  const handler2 = {
    get(target, key, receiver) {
      if (key === symbols_default.raw) {
        return original;
      }
      if (Array.isArray(target) === true) {
        if (typeof target[key] === "object" && target[key] !== null) {
          if (Array.isArray(target[key]) === true) {
            track(target, key, global);
          }
          return reactiveProxy(getRaw(target[key]), target, key);
        }
        if (arrayPatchMethods.indexOf(key) !== -1) {
          return function(...args) {
            pauseTracking();
            const result = target[key].apply(this, args);
            resumeTracking();
            trigger(_parent, _key);
            return result;
          };
        }
        if (key === "length") {
          return original.length;
        }
        return Reflect.get(target, key, receiver);
      }
      if (typeof target[key] === "object" && target[key] !== null) {
        if (Array.isArray(target[key]) === true) {
          track(target, key, global);
        }
        return reactiveProxy(getRaw(target[key]), target, key);
      }
      track(target, key, global);
      return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
      const oldRawValue = getRaw(target[key]);
      const rawValue = getRaw(value);
      let result = true;
      const isEqual = Array.isArray(rawValue) === true ? deepEqualArray_default(oldRawValue, rawValue) : oldRawValue === rawValue;
      if (isEqual === false) {
        if (Array.isArray(value) === true) value = getRaw(value).slice(0);
        result = Reflect.set(target, key, value, receiver);
      }
      if (result === true && isEqual === false) {
        if (Array.isArray(target) === true && key in target === true) {
          trigger(_parent, _key, true);
        }
        trigger(target, key, true);
      }
      return result;
    }
  };
  const proxy = new Proxy(original, handler2);
  proxyMap.set(original, proxy);
  return proxy;
};
var reactiveDefineProperty = (target, global) => {
  Object.keys(target).forEach((key) => {
    let internalValue = target[key];
    if (target[key] !== null && typeof target[key] === "object") {
      if (Object.getPrototypeOf(target[key]) === Object.prototype) {
        return reactiveDefineProperty(target[key]);
      } else if (Array.isArray(target[key]) === true) {
        for (let i = 0; i < arrayPatchMethods.length - 1; i++) {
          target[key][arrayPatchMethods[i]] = function(v) {
            Array.prototype[arrayPatchMethods[i]].call(this, v);
            trigger(target, key);
          };
        }
      }
    }
    Object.defineProperty(target, key, {
      enumerable: true,
      configurable: true,
      get() {
        track(target, key, global);
        return internalValue;
      },
      set(newValue) {
        let oldValue = internalValue;
        if (oldValue !== newValue) {
          internalValue = newValue;
          trigger(target, key);
        }
      }
    });
  });
  return target;
};
var reactive = (target, mode = "Proxy", global = false) => {
  return mode === "defineProperty" ? reactiveDefineProperty(target, global) : reactiveProxy(target, void 0, void 0, global);
};

// node_modules/@lightningjs/blits/src/lib/lifecycle.js
var states = [
  "init",
  // fired upon component instantiation
  "ready",
  // fired when component instantiated, reactivity setup done and template spawned
  "focus",
  // fired when receiving focus (can occur multiple times)
  "unfocus",
  // fired when losing focus (can occur multiple times)
  "destroy",
  // fired when component is destroyed and removed
  "attach",
  // fired when entering the viewport margin and attached to the render tree
  "detach",
  // fired when leaving the viewport margin and detached from the render tree
  "enter",
  // fired when entering the visible viewport
  "exit"
  // fired when leaving the visible viewport
];
var lifecycle_default = {
  previous: null,
  current: null,
  get state() {
    return this.current;
  },
  set state(v) {
    if (states.indexOf(v) > -1 && (v !== this.current || v === "focus")) {
      Log.debug(
        `Setting lifecycle state from ${this.current} to ${v} for ${this.component.componentId}`
      );
      this.previous = this.current;
      this.current = v;
      privateEmit(v, this.component[symbols_default.identifier], this.component);
      emit(v, this.component[symbols_default.identifier], this.component);
    }
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/constants.js
var FLOATS_PER_GLYPH = 24;

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/getStartConditions.js
function getStartConditions(sdfFontSize, sdfLineHeight, fontFace, verticalAlign, offsetY, fontSizeRatio, renderWindow, lineCache, textH) {
  const startLineIndex = Math.min(Math.max(renderWindow.firstLineIdx, 0), lineCache.length);
  const sdfStartX = 0;
  const { metrics } = fontFace;
  assertTruthy(metrics, "Font metrics not loaded");
  assertTruthy(fontFace.data, "Font data not loaded");
  const sdfBareLineHeight = (metrics.ascender - metrics.descender) * sdfFontSize;
  let sdfVerticalAlignYOffset = 0;
  if (verticalAlign === "middle") {
    sdfVerticalAlignYOffset = (sdfLineHeight - sdfBareLineHeight) / 2;
  } else if (verticalAlign === "bottom") {
    sdfVerticalAlignYOffset = sdfLineHeight - sdfBareLineHeight;
  }
  const sdfOffsetY = offsetY / fontSizeRatio;
  const sdfEncodedAscender = fontFace.data.common.base;
  const sdfConfiguredAscender = metrics.ascender * sdfFontSize;
  const sdfAscenderAdjOffset = sdfConfiguredAscender - sdfEncodedAscender;
  const sdfStartY = sdfOffsetY + sdfAscenderAdjOffset + startLineIndex * sdfLineHeight + sdfVerticalAlignYOffset;
  if (textH && sdfStartY >= textH / fontSizeRatio) {
    return;
  }
  return {
    sdfX: sdfStartX,
    sdfY: sdfStartY,
    lineIndex: startLineIndex
  };
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/PeekableGenerator.js
var PeekableIterator = class {
  constructor(iterator, indexBase = 0) {
    __publicField(this, "iterator");
    __publicField(this, "peekBuffer", []);
    __publicField(this, "_lastIndex");
    this.iterator = iterator;
    this.iterator = iterator;
    this._lastIndex = indexBase - 1;
    this.peekBuffer = [];
  }
  next() {
    const nextResult = this.peekBuffer.length > 0 ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.peekBuffer.pop()
    ) : this.iterator.next();
    if (nextResult.done) {
      this._lastIndex = -1;
    } else {
      this._lastIndex++;
    }
    return nextResult;
  }
  peek() {
    if (this.peekBuffer.length > 0) {
      return this.peekBuffer[0];
    }
    const result = this.iterator.next();
    this.peekBuffer.push(result);
    return result;
  }
  get lastIndex() {
    return this._lastIndex;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/getUnicodeCodepoints.js
function* getUnicodeCodepoints(text, start = 0) {
  let i = start;
  while (i < text.length) {
    const codePoint = text.codePointAt(i);
    if (codePoint === void 0) {
      throw new Error("Invalid Unicode code point");
    }
    yield codePoint;
    i += codePoint <= 65535 ? 1 : 2;
  }
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/measureText.js
function measureText(text, shaperProps, shaper) {
  const glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, 0), 0));
  let width = 0;
  for (const glyph of glyphs) {
    if (glyph.mapped && glyph.codepoint !== 8203) {
      width += glyph.xAdvance;
    }
  }
  return width;
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/layoutText.js
function layoutText(curLineIndex, startX, startY, text, textAlign, width, height, fontSize, lineHeight, letterSpacing, vertexBuffer, contain, lineCache, rwSdf, trFontFace, forceFullLayoutCalc, scrollable, overflowSuffix, maxLines) {
  assertTruthy(trFontFace, "Font face must be loaded");
  assertTruthy(trFontFace.loaded, "Font face must be loaded");
  assertTruthy(trFontFace.data, "Font face must be loaded");
  assertTruthy(trFontFace.shaper, "Font face must be loaded");
  const fontSizeRatio = fontSize / trFontFace.data.info.size;
  const vertexLineHeight = lineHeight / fontSizeRatio;
  const vertexW = width / fontSizeRatio;
  const vertexLSpacing = letterSpacing / fontSizeRatio;
  const startingLineCacheEntry = lineCache[curLineIndex];
  const startingCodepointIndex = (startingLineCacheEntry == null ? void 0 : startingLineCacheEntry.codepointIndex) || 0;
  const startingMaxX = (startingLineCacheEntry == null ? void 0 : startingLineCacheEntry.maxX) || 0;
  const startingMaxY = (startingLineCacheEntry == null ? void 0 : startingLineCacheEntry.maxY) || 0;
  let maxX = startingMaxX;
  let maxY = startingMaxY;
  let curX = startX;
  let curY = startY;
  let bufferOffset = 0;
  const lastWord = {
    codepointIndex: -1,
    bufferOffset: -1,
    xStart: -1
  };
  const shaper = trFontFace.shaper;
  const shaperProps = {
    letterSpacing: vertexLSpacing
  };
  let glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, startingCodepointIndex), startingCodepointIndex));
  let glyphResult;
  let curLineBufferStart = -1;
  const bufferLineInfos = [];
  const vertexTruncateHeight = height / fontSizeRatio;
  const overflowSuffVertexWidth = measureText(overflowSuffix, shaperProps, shaper);
  let moreLines = true;
  while (moreLines) {
    const nextLineWillFit = (maxLines === 0 || curLineIndex + 1 < maxLines) && (contain !== "both" || scrollable || curY + vertexLineHeight + trFontFace.maxCharHeight <= vertexTruncateHeight);
    const lineVertexW = nextLineWillFit ? vertexW : vertexW - overflowSuffVertexWidth;
    let xStartLastWordBoundary = 0;
    const lineIsBelowWindowTop = curY + trFontFace.maxCharHeight >= rwSdf.y1;
    const lineIsAboveWindowBottom = curY <= rwSdf.y2;
    const lineIsWithinWindow = lineIsBelowWindowTop && lineIsAboveWindowBottom;
    while ((glyphResult = glyphs.next()) && !glyphResult.done) {
      const glyph = glyphResult.value;
      if (curLineIndex === lineCache.length) {
        lineCache.push({
          codepointIndex: glyph.cluster,
          maxY,
          maxX
        });
      } else if (curLineIndex > lineCache.length) {
        throw new Error("Unexpected lineCache length");
      }
      if (glyph.codepoint === 32 || glyph.codepoint === 10 || glyph.codepoint === 8203) {
        if (lastWord.codepointIndex !== -1) {
          lastWord.codepointIndex = -1;
          xStartLastWordBoundary = curX;
        }
      } else if (lastWord.codepointIndex === -1) {
        lastWord.codepointIndex = glyph.cluster;
        lastWord.bufferOffset = bufferOffset;
        lastWord.xStart = xStartLastWordBoundary;
      }
      if (glyph.mapped) {
        const charEndX = curX + glyph.xOffset + glyph.width;
        if (
          // We are containing the text
          contain !== "none" && // The current glyph reaches outside the contained width
          charEndX >= lineVertexW && // There is a last word that we can break to the next line
          lastWord.codepointIndex !== -1 && // Prevents infinite loop when a single word is longer than the width
          lastWord.xStart > 0
        ) {
          if (nextLineWillFit) {
            glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, lastWord.codepointIndex), lastWord.codepointIndex));
            bufferOffset = lastWord.bufferOffset;
            break;
          } else {
            glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(overflowSuffix, 0), 0));
            curX = lastWord.xStart;
            bufferOffset = lastWord.bufferOffset;
            contain = "none";
          }
        } else {
          const quadX = curX + glyph.xOffset;
          const quadY = curY + glyph.yOffset;
          if (lineIsWithinWindow) {
            if (curLineBufferStart === -1) {
              curLineBufferStart = bufferOffset;
            }
            const atlasEntry = trFontFace.getAtlasEntry(glyph.glyphId);
            const u = atlasEntry.x / trFontFace.data.common.scaleW;
            const v = atlasEntry.y / trFontFace.data.common.scaleH;
            const uvWidth = atlasEntry.width / trFontFace.data.common.scaleW;
            const uvHeight = atlasEntry.height / trFontFace.data.common.scaleH;
            vertexBuffer[bufferOffset++] = quadX;
            vertexBuffer[bufferOffset++] = quadY;
            vertexBuffer[bufferOffset++] = u;
            vertexBuffer[bufferOffset++] = v;
            vertexBuffer[bufferOffset++] = quadX + glyph.width;
            vertexBuffer[bufferOffset++] = quadY;
            vertexBuffer[bufferOffset++] = u + uvWidth;
            vertexBuffer[bufferOffset++] = v;
            vertexBuffer[bufferOffset++] = quadX;
            vertexBuffer[bufferOffset++] = quadY + glyph.height;
            vertexBuffer[bufferOffset++] = u;
            vertexBuffer[bufferOffset++] = v + uvHeight;
            vertexBuffer[bufferOffset++] = quadX + glyph.width;
            vertexBuffer[bufferOffset++] = quadY + glyph.height;
            vertexBuffer[bufferOffset++] = u + uvWidth;
            vertexBuffer[bufferOffset++] = v + uvHeight;
          }
          maxY = Math.max(maxY, quadY + glyph.height);
          maxX = Math.max(maxX, quadX + glyph.width);
          curX += glyph.xAdvance;
        }
      } else {
        if (glyph.codepoint === 10) {
          if (nextLineWillFit) {
            break;
          } else {
            glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(overflowSuffix, 0), 0));
            contain = "none";
          }
        }
      }
    }
    if (curLineBufferStart !== -1) {
      bufferLineInfos.push({
        bufferStart: curLineBufferStart,
        bufferEnd: bufferOffset
      });
      curLineBufferStart = -1;
    }
    curX = 0;
    curY += vertexLineHeight;
    curLineIndex++;
    lastWord.codepointIndex = -1;
    xStartLastWordBoundary = 0;
    if (!forceFullLayoutCalc && contain === "both" && curY > rwSdf.y2) {
      moreLines = false;
    } else if (glyphResult && glyphResult.done) {
      moreLines = false;
    } else if (!nextLineWillFit) {
      moreLines = false;
    }
  }
  if (textAlign === "center") {
    const vertexTextW = contain === "none" ? maxX : vertexW;
    for (let i = 0; i < bufferLineInfos.length; i++) {
      const line = bufferLineInfos[i];
      const lineWidth = (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        vertexBuffer[line.bufferEnd - 4] - vertexBuffer[line.bufferStart]
      );
      const xOffset = (vertexTextW - lineWidth) / 2;
      for (let j = line.bufferStart; j < line.bufferEnd; j += 4) {
        vertexBuffer[j] += xOffset;
      }
    }
  } else if (textAlign === "right") {
    const vertexTextW = contain === "none" ? maxX : vertexW;
    for (let i = 0; i < bufferLineInfos.length; i++) {
      const line = bufferLineInfos[i];
      const lineWidth = line.bufferEnd === line.bufferStart ? 0 : (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        vertexBuffer[line.bufferEnd - 4] - vertexBuffer[line.bufferStart]
      );
      const xOffset = vertexTextW - lineWidth;
      for (let j = line.bufferStart; j < line.bufferEnd; j += 4) {
        vertexBuffer[j] += xOffset;
      }
    }
  }
  assertTruthy(glyphResult);
  return {
    bufferNumFloats: bufferOffset,
    bufferNumQuads: bufferOffset / 16,
    layoutNumCharacters: glyphResult.done ? text.length - startingCodepointIndex : glyphResult.value.cluster - startingCodepointIndex + 1,
    fullyProcessed: !!glyphResult.done,
    maxX,
    maxY,
    numLines: lineCache.length
  };
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/util.js
function roundUpToMultiple(value, multiple) {
  return Math.ceil(value / multiple) * multiple;
}
function roundDownToMultiple(value, multiple) {
  return Math.floor(value / multiple) * multiple;
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/internal/setRenderWindow.js
function setRenderWindow(outRenderWindow, x, y, scrollY, lineHeight, bufferMargin, visibleWindow, fontSizeRatio) {
  const { screen, sdf } = outRenderWindow;
  if (!isBoundPositive(visibleWindow)) {
    screen.x1 = 0;
    screen.y1 = 0;
    screen.x2 = 0;
    screen.y2 = 0;
    sdf.x1 = 0;
    sdf.y1 = 0;
    sdf.x2 = 0;
    sdf.y2 = 0;
    outRenderWindow.numLines = 0;
    outRenderWindow.firstLineIdx = 0;
  } else {
    const x1 = visibleWindow.x1 - x;
    const x2 = x1 + (visibleWindow.x2 - visibleWindow.x1);
    const y1Base = visibleWindow.y1 - y + scrollY;
    const y1 = roundDownToMultiple(y1Base - bufferMargin, lineHeight || 1);
    const y2 = roundUpToMultiple(y1Base + (visibleWindow.y2 - visibleWindow.y1) + bufferMargin, lineHeight || 1);
    screen.x1 = x1;
    screen.y1 = y1;
    screen.x2 = x2;
    screen.y2 = y2;
    sdf.x1 = x1 / fontSizeRatio;
    sdf.y1 = y1 / fontSizeRatio;
    sdf.x2 = x2 / fontSizeRatio;
    sdf.y2 = y2 / fontSizeRatio;
    outRenderWindow.numLines = Math.ceil((y2 - y1) / lineHeight);
    outRenderWindow.firstLineIdx = lineHeight ? Math.floor(y1 / lineHeight) : 0;
  }
  outRenderWindow.valid = true;
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/TextRenderingUtils.js
function calcDefaultLineHeight(metrics, fontSize) {
  return fontSize * (metrics.ascender - metrics.descender + metrics.lineGap);
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/SdfTextRenderer/SdfTextRenderer.js
var tmpRect = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
var SdfTextRenderer = class extends TextRenderer {
  constructor(stage2) {
    super(stage2);
    /**
     * Map of font family names to a set of font faces.
     */
    __publicField(this, "ssdfFontFamilies", {});
    __publicField(this, "msdfFontFamilies", {});
    __publicField(this, "fontFamilyArray", [
      this.ssdfFontFamilies,
      this.msdfFontFamilies
    ]);
    __publicField(this, "sdfShader");
    __publicField(this, "rendererBounds");
    __publicField(this, "type", "sdf");
    this.sdfShader = this.stage.shManager.loadShader("SdfShader").shader;
    this.rendererBounds = {
      x1: 0,
      y1: 0,
      x2: this.stage.options.appWidth,
      y2: this.stage.options.appHeight
    };
  }
  //#region Overrides
  getPropertySetters() {
    return {
      fontFamily: (state, value) => {
        state.props.fontFamily = value;
        this.releaseFontFace(state);
        this.invalidateLayoutCache(state);
      },
      fontWeight: (state, value) => {
        state.props.fontWeight = value;
        this.releaseFontFace(state);
        this.invalidateLayoutCache(state);
      },
      fontStyle: (state, value) => {
        state.props.fontStyle = value;
        this.releaseFontFace(state);
        this.invalidateLayoutCache(state);
      },
      fontStretch: (state, value) => {
        state.props.fontStretch = value;
        this.releaseFontFace(state);
        this.invalidateLayoutCache(state);
      },
      fontSize: (state, value) => {
        state.props.fontSize = value;
        this.invalidateLayoutCache(state);
      },
      text: (state, value) => {
        state.props.text = value;
        this.invalidateLayoutCache(state);
      },
      textAlign: (state, value) => {
        state.props.textAlign = value;
        this.invalidateLayoutCache(state);
      },
      color: (state, value) => {
        state.props.color = value;
      },
      x: (state, value) => {
        state.props.x = value;
        if (state.elementBounds.valid) {
          this.setElementBoundsX(state);
          if (!state.renderWindow.valid && boundsOverlap(state.elementBounds, this.rendererBounds)) {
            this.scheduleUpdateState(state);
          }
        }
      },
      y: (state, value) => {
        state.props.y = value;
        if (state.elementBounds.valid) {
          this.setElementBoundsY(state);
          if (!state.renderWindow.valid && boundsOverlap(state.elementBounds, this.rendererBounds)) {
            this.scheduleUpdateState(state);
          }
        }
      },
      contain: (state, value) => {
        state.props.contain = value;
        this.invalidateLayoutCache(state);
      },
      width: (state, value) => {
        state.props.width = value;
        if (state.props.contain !== "none") {
          this.invalidateLayoutCache(state);
        }
      },
      height: (state, value) => {
        state.props.height = value;
        if (state.props.contain === "both") {
          this.invalidateLayoutCache(state);
        }
      },
      offsetY: (state, value) => {
        state.props.offsetY = value;
        this.invalidateLayoutCache(state);
      },
      scrollable: (state, value) => {
        state.props.scrollable = value;
        this.invalidateLayoutCache(state);
      },
      scrollY: (state, value) => {
        state.props.scrollY = value;
        this.scheduleUpdateState(state);
      },
      letterSpacing: (state, value) => {
        state.props.letterSpacing = value;
        this.invalidateLayoutCache(state);
      },
      lineHeight: (state, value) => {
        state.props.lineHeight = value;
        state.resLineHeight = void 0;
        this.invalidateLayoutCache(state);
      },
      maxLines: (state, value) => {
        state.props.maxLines = value;
        this.invalidateLayoutCache(state);
      },
      textBaseline: (state, value) => {
        state.props.textBaseline = value;
        this.invalidateLayoutCache(state);
      },
      verticalAlign: (state, value) => {
        state.props.verticalAlign = value;
        this.invalidateLayoutCache(state);
      },
      overflowSuffix: (state, value) => {
        state.props.overflowSuffix = value;
        this.invalidateLayoutCache(state);
      },
      debug: (state, value) => {
        state.props.debug = value;
      }
    };
  }
  canRenderFont(props) {
    const { fontFamily } = props;
    return fontFamily in this.ssdfFontFamilies || fontFamily in this.msdfFontFamilies || fontFamily === "$$SDF_FAILURE_TEST$$";
  }
  isFontFaceSupported(fontFace) {
    return fontFace instanceof SdfTrFontFace;
  }
  addFontFace(fontFace) {
    assertTruthy(fontFace instanceof SdfTrFontFace);
    const familyName = fontFace.fontFamily;
    const fontFamiles = fontFace.type === "ssdf" ? this.ssdfFontFamilies : fontFace.type === "msdf" ? this.msdfFontFamilies : void 0;
    if (!fontFamiles) {
      console.warn(`Invalid font face type: ${fontFace.type}`);
      return;
    }
    let faceSet = fontFamiles[familyName];
    if (!faceSet) {
      faceSet = /* @__PURE__ */ new Set();
      fontFamiles[familyName] = faceSet;
    }
    faceSet.add(fontFace);
  }
  createState(props) {
    return {
      props,
      status: "initialState",
      updateScheduled: false,
      emitter: new EventEmitter(),
      lineCache: [],
      forceFullLayoutCalc: false,
      renderWindow: {
        screen: {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0
        },
        sdf: {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0
        },
        firstLineIdx: 0,
        numLines: 0,
        valid: false
      },
      elementBounds: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        valid: false
      },
      clippingRect: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        valid: false
      },
      bufferNumFloats: 0,
      bufferNumQuads: 0,
      vertexBuffer: void 0,
      webGlBuffers: null,
      bufferUploaded: false,
      textH: void 0,
      textW: void 0,
      distanceRange: 0,
      trFontFace: void 0,
      isRenderable: false,
      resLineHeight: void 0,
      debugData: {
        updateCount: 0,
        layoutCount: 0,
        lastLayoutNumCharacters: 0,
        layoutSum: 0,
        drawSum: 0,
        drawCount: 0,
        bufferSize: 0
      }
    };
  }
  updateState(state) {
    let { trFontFace } = state;
    const { textH, lineCache, debugData, forceFullLayoutCalc } = state;
    debugData.updateCount++;
    if (state.status === "initialState") {
      this.setStatus(state, "loading");
    }
    if (trFontFace === void 0) {
      trFontFace = this.resolveFontFace(state.props);
      state.trFontFace = trFontFace;
      if (trFontFace === void 0) {
        const msg = `SdfTextRenderer: Could not resolve font face for family: '${state.props.fontFamily}'`;
        console.error(msg);
        this.setStatus(state, "failed", new Error(msg));
        return;
      }
      trFontFace.texture.setRenderableOwner(state, true);
    }
    if (trFontFace.loaded === false) {
      trFontFace.once("loaded", () => {
        this.scheduleUpdateState(state);
      });
      return;
    }
    assertTruthy(trFontFace.data, "Font face data should be loaded");
    assertTruthy(trFontFace.metrics, "Font face metrics should be loaded");
    const { text, fontSize, x, y, contain, width, height, verticalAlign, scrollable, overflowSuffix, maxLines } = state.props;
    const scrollY = contain === "both" && scrollable ? state.props.scrollY : 0;
    const { renderWindow } = state;
    const sdfFontSize = trFontFace.data.info.size;
    const fontSizeRatio = fontSize / sdfFontSize;
    let resLineHeight = state.resLineHeight;
    if (resLineHeight === void 0) {
      const lineHeight = state.props.lineHeight;
      if (lineHeight === void 0) {
        resLineHeight = calcDefaultLineHeight(trFontFace.metrics, fontSize);
      } else {
        resLineHeight = lineHeight;
      }
      state.resLineHeight = resLineHeight;
    }
    const sdfLineHeight = resLineHeight / fontSizeRatio;
    state.distanceRange = fontSizeRatio * trFontFace.data.distanceField.distanceRange;
    const neededLength = text.length * FLOATS_PER_GLYPH;
    let vertexBuffer = state.vertexBuffer;
    if (!vertexBuffer || vertexBuffer.length < neededLength) {
      vertexBuffer = new Float32Array(neededLength * 2);
    }
    const elementBounds = state.elementBounds;
    if (!elementBounds.valid) {
      this.setElementBoundsX(state);
      this.setElementBoundsY(state);
      elementBounds.valid = true;
    }
    if (!forceFullLayoutCalc && renderWindow.valid) {
      const rwScreen = renderWindow.screen;
      if (x + rwScreen.x1 <= elementBounds.x1 && x + rwScreen.x2 >= elementBounds.x2 && y - scrollY + rwScreen.y1 <= elementBounds.y1 && y - scrollY + rwScreen.y2 >= elementBounds.y2) {
        this.setStatus(state, "loaded");
        return;
      }
      renderWindow.valid = false;
      this.setStatus(state, "loading");
    }
    const { offsetY, textAlign } = state.props;
    if (!renderWindow.valid) {
      const isPossiblyOnScreen = boundsOverlap(elementBounds, this.rendererBounds);
      if (!isPossiblyOnScreen) {
        return;
      }
      setRenderWindow(renderWindow, x, y, scrollY, resLineHeight, contain === "both" ? elementBounds.y2 - elementBounds.y1 : 0, elementBounds, fontSizeRatio);
    }
    const start = getStartConditions(sdfFontSize, sdfLineHeight, trFontFace, verticalAlign, offsetY, fontSizeRatio, renderWindow, lineCache, textH);
    if (!start) {
      this.setStatus(state, "loaded");
      return;
    }
    const { letterSpacing } = state.props;
    const out2 = layoutText(start.lineIndex, start.sdfX, start.sdfY, text, textAlign, width, height, fontSize, resLineHeight, letterSpacing, vertexBuffer, contain, lineCache, renderWindow.sdf, trFontFace, forceFullLayoutCalc, scrollable, overflowSuffix, maxLines);
    state.bufferUploaded = false;
    state.bufferNumFloats = out2.bufferNumFloats;
    state.bufferNumQuads = out2.bufferNumQuads;
    state.vertexBuffer = vertexBuffer;
    state.renderWindow = renderWindow;
    debugData.lastLayoutNumCharacters = out2.layoutNumCharacters;
    debugData.bufferSize = vertexBuffer.byteLength;
    if (out2.fullyProcessed) {
      state.textW = out2.maxX * fontSizeRatio;
      state.textH = out2.numLines * sdfLineHeight * fontSizeRatio;
    }
    this.setStatus(state, "loaded");
  }
  renderQuads(state, transform, clippingRect, alpha, parentHasRenderTexture, framebufferDimensions) {
    var _a2, _b;
    if (!state.vertexBuffer) {
      return;
    }
    const renderer3 = this.stage.renderer;
    assertTruthy(renderer3 instanceof WebGlCoreRenderer);
    const { fontSize, color, contain, scrollable, zIndex, debug } = state.props;
    const scrollY = contain === "both" && scrollable ? state.props.scrollY : 0;
    const { textW = 0, textH = 0, distanceRange, vertexBuffer, bufferUploaded, trFontFace, elementBounds } = state;
    let { webGlBuffers } = state;
    if (!webGlBuffers) {
      const glw = renderer3.glw;
      const stride = 4 * Float32Array.BYTES_PER_ELEMENT;
      const webGlBuffer = glw.createBuffer();
      assertTruthy(webGlBuffer);
      state.webGlBuffers = new BufferCollection([
        {
          buffer: webGlBuffer,
          attributes: {
            a_position: {
              name: "a_position",
              size: 2,
              type: glw.FLOAT,
              normalized: false,
              stride,
              offset: 0
              // start at the beginning of the buffer
            },
            a_textureCoordinate: {
              name: "a_textureCoordinate",
              size: 2,
              type: glw.FLOAT,
              normalized: false,
              stride,
              offset: 2 * Float32Array.BYTES_PER_ELEMENT
            }
          }
        }
      ]);
      state.bufferUploaded = false;
      assertTruthy(state.webGlBuffers);
      webGlBuffers = state.webGlBuffers;
    }
    if (!bufferUploaded) {
      const glw = renderer3.glw;
      const buffer = (webGlBuffers == null ? void 0 : webGlBuffers.getBuffer("a_textureCoordinate")) ?? null;
      glw.arrayBufferData(buffer, vertexBuffer, glw.STATIC_DRAW);
      state.bufferUploaded = true;
    }
    assertTruthy(trFontFace);
    if (scrollable && contain === "both") {
      assertTruthy(elementBounds.valid);
      const elementRect = convertBoundToRect(elementBounds, tmpRect);
      if (clippingRect.valid) {
        state.clippingRect.valid = true;
        clippingRect = intersectRect(clippingRect, elementRect, state.clippingRect);
      } else {
        state.clippingRect.valid = true;
        clippingRect = copyRect(elementRect, state.clippingRect);
      }
    }
    const renderOp = new WebGlCoreRenderOp(renderer3.glw, renderer3.options, webGlBuffers, this.sdfShader, {
      transform: transform.getFloatArr(),
      // IMPORTANT: The SDF Shader expects the color NOT to be premultiplied
      // for the best blending results. Which is why we use `mergeColorAlpha`
      // instead of `mergeColorAlphaPremultiplied` here.
      color: mergeColorAlpha(color, alpha),
      size: fontSize / (((_a2 = trFontFace.data) == null ? void 0 : _a2.info.size) || 0),
      scrollY,
      distanceRange,
      debug: debug.sdfShaderDebug
    }, alpha, clippingRect, { height: textH, width: textW }, 0, zIndex, false, parentHasRenderTexture, framebufferDimensions);
    const texture = (_b = state.trFontFace) == null ? void 0 : _b.texture;
    assertTruthy(texture);
    const ctxTexture = texture.ctxTexture;
    renderOp.addTexture(ctxTexture);
    renderOp.length = state.bufferNumFloats;
    renderOp.numQuads = state.bufferNumQuads;
    renderer3.addRenderOp(renderOp);
  }
  setIsRenderable(state, renderable) {
    var _a2;
    super.setIsRenderable(state, renderable);
    (_a2 = state.trFontFace) == null ? void 0 : _a2.texture.setRenderableOwner(state, renderable);
  }
  destroyState(state) {
    var _a2;
    super.destroyState(state);
    (_a2 = state.trFontFace) == null ? void 0 : _a2.texture.setRenderableOwner(state, false);
  }
  //#endregion Overrides
  resolveFontFace(props) {
    return this.stage.fontManager.resolveFontFace(this.fontFamilyArray, props, "sdf");
  }
  /**
   * Release the loaded SDF font face
   *
   * @param state
   */
  releaseFontFace(state) {
    state.resLineHeight = void 0;
    if (state.trFontFace) {
      state.trFontFace.texture.setRenderableOwner(state, false);
      state.trFontFace = void 0;
    }
  }
  /**
   * Invalidate the layout cache stored in the state. This will cause the text
   * to be re-layed out on the next update.
   *
   * @remarks
   * This also invalidates the visible window cache.
   *
   * @param state
   */
  invalidateLayoutCache(state) {
    state.renderWindow.valid = false;
    state.elementBounds.valid = false;
    state.textH = void 0;
    state.textW = void 0;
    state.lineCache = [];
    this.setStatus(state, "loading");
    this.scheduleUpdateState(state);
  }
  setElementBoundsX(state) {
    const { x, contain, width } = state.props;
    const { elementBounds } = state;
    elementBounds.x1 = x;
    elementBounds.x2 = contain !== "none" ? x + width : Infinity;
  }
  setElementBoundsY(state) {
    const { y, contain, height } = state.props;
    const { elementBounds } = state;
    elementBounds.y1 = y;
    elementBounds.y2 = contain === "both" ? y + height : Infinity;
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/TextTextureRendererUtils.js
function isZeroWidthSpace(space) {
  return space === "" || space === "​";
}
function getWebFontMetrics(context, fontFace, fontSize) {
  if (fontFace.metrics) {
    return fontFace.metrics;
  }
  const browserMetrics = context.measureText("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
  console.warn(`Font metrics not provided for Canvas Web font ${fontFace.fontFamily}. Using fallback values. It is HIGHLY recommended you use the latest version of the Lightning 3 \`msdf-generator\` tool to extract the default metrics for the font and provide them in the Canvas Web font definition.`);
  let metrics;
  if (browserMetrics.actualBoundingBoxDescent && browserMetrics.actualBoundingBoxAscent) {
    metrics = {
      ascender: browserMetrics.actualBoundingBoxAscent / fontSize,
      descender: -browserMetrics.actualBoundingBoxDescent / fontSize,
      lineGap: 0.2
    };
  } else {
    metrics = {
      ascender: 0.8,
      descender: -0.2,
      lineGap: 0.2
    };
  }
  fontFace.metrics = metrics;
  return metrics;
}

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/LightningTextTextureRenderer.js
var MAX_TEXTURE_DIMENSION = 2048;
function calcHeight(textBaseline, fontSize, lineHeight, numLines, offsetY) {
  const baselineOffset = textBaseline !== "bottom" ? 0.5 * fontSize : 0;
  return lineHeight * (numLines - 1) + baselineOffset + Math.max(lineHeight, fontSize) + (offsetY || 0);
}
var LightningTextTextureRenderer = class {
  constructor(canvas, context) {
    __publicField(this, "_canvas");
    __publicField(this, "_context");
    __publicField(this, "_settings");
    this._canvas = canvas;
    this._context = context;
    this._settings = this.mergeDefaults({});
  }
  set settings(v) {
    this._settings = this.mergeDefaults(v);
  }
  get settings() {
    return this._settings;
  }
  getPrecision() {
    return this._settings.precision;
  }
  setFontProperties() {
    this._context.font = this._getFontSetting();
    this._context.textBaseline = this._settings.textBaseline;
  }
  _getFontSetting() {
    const ff = [this._settings.fontFamily];
    const ffs = [];
    for (let i = 0, n2 = ff.length; i < n2; i++) {
      if (ff[i] === "serif" || ff[i] === "sans-serif") {
        ffs.push(ff[i]);
      } else {
        ffs.push(`"${ff[i]}"`);
      }
    }
    return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`;
  }
  _load() {
    if (document.fonts) {
      const fontSetting = this._getFontSetting();
      try {
        if (!document.fonts.check(fontSetting, this._settings.text)) {
          return document.fonts.load(fontSetting, this._settings.text).catch((err) => {
            console.warn("[Lightning] Font load error", err, fontSetting);
          }).then(() => {
            if (!document.fonts.check(fontSetting, this._settings.text)) {
              console.warn("[Lightning] Font not found", fontSetting);
            }
          });
        }
      } catch (e) {
        console.warn("[Lightning] Can't check font loading for " + fontSetting);
      }
    }
  }
  calculateRenderInfo() {
    const renderInfo = {};
    const precision = this.getPrecision();
    const paddingLeft = this._settings.paddingLeft * precision;
    const paddingRight = this._settings.paddingRight * precision;
    const fontSize = this._settings.fontSize * precision;
    let offsetY = this._settings.offsetY === null ? null : this._settings.offsetY * precision;
    const w = this._settings.w * precision;
    const h = this._settings.h * precision;
    let wordWrapWidth = this._settings.wordWrapWidth * precision;
    const cutSx = this._settings.cutSx * precision;
    const cutEx = this._settings.cutEx * precision;
    const cutSy = this._settings.cutSy * precision;
    const cutEy = this._settings.cutEy * precision;
    const letterSpacing = (this._settings.letterSpacing || 0) * precision;
    const textIndent = this._settings.textIndent * precision;
    const trFontFace = this._settings.trFontFace;
    this.setFontProperties();
    assertTruthy(trFontFace);
    const metrics = getWebFontMetrics(this._context, trFontFace, fontSize);
    const defLineHeight = calcDefaultLineHeight(metrics, fontSize) * precision;
    const lineHeight = this._settings.lineHeight !== null ? this._settings.lineHeight * precision : defLineHeight;
    const maxHeight = this._settings.maxHeight;
    const containedMaxLines = maxHeight !== null && lineHeight > 0 ? Math.floor(maxHeight / lineHeight) : 0;
    const setMaxLines = this._settings.maxLines;
    const calcMaxLines = containedMaxLines > 0 && setMaxLines > 0 ? Math.min(containedMaxLines, setMaxLines) : Math.max(containedMaxLines, setMaxLines);
    let width = w || 2048 / this.getPrecision();
    let innerWidth = width - paddingLeft;
    if (innerWidth < 10) {
      width += 10 - innerWidth;
      innerWidth = 10;
    }
    if (!wordWrapWidth) {
      wordWrapWidth = innerWidth;
    }
    if (this._settings.textOverflow && !this._settings.wordWrap) {
      let suffix;
      switch (this._settings.textOverflow) {
        case "clip":
          suffix = "";
          break;
        case "ellipsis":
          suffix = this._settings.overflowSuffix;
          break;
        default:
          suffix = this._settings.textOverflow;
      }
      this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix);
    }
    let linesInfo;
    if (this._settings.wordWrap) {
      linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
    } else {
      linesInfo = { l: this._settings.text.split(/(?:\r\n|\r|\n)/), n: [] };
      const n2 = linesInfo.l.length;
      for (let i = 0; i < n2 - 1; i++) {
        linesInfo.n.push(i);
      }
    }
    let lines = linesInfo.l;
    if (calcMaxLines && lines.length > calcMaxLines) {
      const usedLines = lines.slice(0, calcMaxLines);
      let otherLines = null;
      if (this._settings.overflowSuffix) {
        const w2 = this._settings.overflowSuffix ? this.measureText(this._settings.overflowSuffix) : 0;
        const al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - w2, letterSpacing, textIndent);
        usedLines[usedLines.length - 1] = `${al.l[0]}${this._settings.overflowSuffix}`;
        otherLines = [al.l.length > 1 ? al.l[1] : ""];
      } else {
        otherLines = [""];
      }
      let i;
      const n2 = lines.length;
      let j = 0;
      const m = linesInfo.n.length;
      for (i = calcMaxLines; i < n2; i++) {
        otherLines[j] += `${otherLines[j] ? " " : ""}${lines[i]}`;
        if (i + 1 < m && linesInfo.n[i + 1]) {
          j++;
        }
      }
      renderInfo.remainingText = otherLines.join("\n");
      renderInfo.moreTextLines = true;
      lines = usedLines;
    } else {
      renderInfo.moreTextLines = false;
      renderInfo.remainingText = "";
    }
    let maxLineWidth = 0;
    const lineWidths = [];
    for (let i = 0; i < lines.length; i++) {
      const lineWidth = this.measureText(lines[i], letterSpacing) + (i === 0 ? textIndent : 0);
      lineWidths.push(lineWidth);
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    renderInfo.lineWidths = lineWidths;
    if (!w) {
      width = maxLineWidth + paddingLeft + paddingRight;
      innerWidth = maxLineWidth;
    }
    let height;
    if (h) {
      height = h;
    } else {
      height = calcHeight(this._settings.textBaseline, fontSize, lineHeight, lines.length, offsetY);
    }
    if (offsetY === null) {
      offsetY = fontSize;
    }
    renderInfo.w = width;
    renderInfo.h = height;
    renderInfo.lines = lines;
    renderInfo.precision = precision;
    if (!width) {
      width = 1;
    }
    if (!height) {
      height = 1;
    }
    if (cutSx || cutEx) {
      width = Math.min(width, cutEx - cutSx);
    }
    if (cutSy || cutEy) {
      height = Math.min(height, cutEy - cutSy);
    }
    renderInfo.width = width;
    renderInfo.innerWidth = innerWidth;
    renderInfo.height = height;
    renderInfo.fontSize = fontSize;
    renderInfo.cutSx = cutSx;
    renderInfo.cutSy = cutSy;
    renderInfo.cutEx = cutEx;
    renderInfo.cutEy = cutEy;
    renderInfo.lineHeight = lineHeight;
    renderInfo.defLineHeight = defLineHeight;
    renderInfo.lineWidths = lineWidths;
    renderInfo.offsetY = offsetY;
    renderInfo.paddingLeft = paddingLeft;
    renderInfo.paddingRight = paddingRight;
    renderInfo.letterSpacing = letterSpacing;
    renderInfo.textIndent = textIndent;
    renderInfo.metrics = metrics;
    return renderInfo;
  }
  draw(renderInfo, linesOverride) {
    const precision = this.getPrecision();
    const lines = (linesOverride == null ? void 0 : linesOverride.lines) || renderInfo.lines;
    const lineWidths = (linesOverride == null ? void 0 : linesOverride.lineWidths) || renderInfo.lineWidths;
    const height = linesOverride ? calcHeight(this._settings.textBaseline, renderInfo.fontSize, renderInfo.lineHeight, linesOverride.lines.length, this._settings.offsetY === null ? null : this._settings.offsetY * precision) : renderInfo.height;
    this._canvas.width = Math.min(Math.ceil(renderInfo.width + this._settings.textRenderIssueMargin), MAX_TEXTURE_DIMENSION);
    this._canvas.height = Math.min(Math.ceil(height), MAX_TEXTURE_DIMENSION);
    this.setFontProperties();
    if (renderInfo.fontSize >= 128) {
      this._context.globalAlpha = 0.01;
      this._context.fillRect(0, 0, 0.01, 0.01);
      this._context.globalAlpha = 1;
    }
    if (renderInfo.cutSx || renderInfo.cutSy) {
      this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
    }
    let linePositionX;
    let linePositionY;
    const drawLines = [];
    const { metrics } = renderInfo;
    const ascenderPx = metrics ? metrics.ascender * renderInfo.fontSize : renderInfo.fontSize;
    const bareLineHeightPx = (metrics.ascender - metrics.descender) * renderInfo.fontSize;
    for (let i = 0, n2 = lines.length; i < n2; i++) {
      linePositionX = i === 0 ? renderInfo.textIndent : 0;
      linePositionY = i * renderInfo.lineHeight + ascenderPx;
      if (this._settings.verticalAlign == "middle") {
        linePositionY += (renderInfo.lineHeight - bareLineHeightPx) / 2;
      } else if (this._settings.verticalAlign == "bottom") {
        linePositionY += renderInfo.lineHeight - bareLineHeightPx;
      }
      if (this._settings.textAlign === "right") {
        linePositionX += renderInfo.innerWidth - lineWidths[i];
      } else if (this._settings.textAlign === "center") {
        linePositionX += (renderInfo.innerWidth - lineWidths[i]) / 2;
      }
      linePositionX += renderInfo.paddingLeft;
      drawLines.push({
        text: lines[i],
        x: linePositionX,
        y: linePositionY,
        w: lineWidths[i]
      });
    }
    if (this._settings.highlight) {
      const color = this._settings.highlightColor;
      const hlHeight = this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5;
      const offset = this._settings.highlightOffset * precision;
      const hlPaddingLeft = this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft;
      const hlPaddingRight = this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight;
      this._context.fillStyle = getRgbaString(color);
      for (let i = 0; i < drawLines.length; i++) {
        const drawLine = drawLines[i];
        this._context.fillRect(drawLine.x - hlPaddingLeft, drawLine.y - renderInfo.offsetY + offset, drawLine.w + hlPaddingRight + hlPaddingLeft, hlHeight);
      }
    }
    let prevShadowSettings = null;
    if (this._settings.shadow) {
      prevShadowSettings = [
        this._context.shadowColor,
        this._context.shadowOffsetX,
        this._context.shadowOffsetY,
        this._context.shadowBlur
      ];
      this._context.shadowColor = getRgbaString(this._settings.shadowColor);
      this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
      this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
      this._context.shadowBlur = this._settings.shadowBlur * precision;
    }
    this._context.fillStyle = getRgbaString(this._settings.textColor);
    for (let i = 0, n2 = drawLines.length; i < n2; i++) {
      const drawLine = drawLines[i];
      if (renderInfo.letterSpacing === 0) {
        this._context.fillText(drawLine.text, drawLine.x, drawLine.y);
      } else {
        const textSplit = drawLine.text.split("");
        let x = drawLine.x;
        for (let i2 = 0, j = textSplit.length; i2 < j; i2++) {
          this._context.fillText(textSplit[i2], x, drawLine.y);
          x += this.measureText(textSplit[i2], renderInfo.letterSpacing);
        }
      }
    }
    if (prevShadowSettings) {
      this._context.shadowColor = prevShadowSettings[0];
      this._context.shadowOffsetX = prevShadowSettings[1];
      this._context.shadowOffsetY = prevShadowSettings[2];
      this._context.shadowBlur = prevShadowSettings[3];
    }
    if (renderInfo.cutSx || renderInfo.cutSy) {
      this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
    }
  }
  wrapWord(word, wordWrapWidth, suffix) {
    const suffixWidth = this._context.measureText(suffix).width;
    const wordLen = word.length;
    const wordWidth = this._context.measureText(word).width;
    if (wordWidth <= wordWrapWidth) {
      return word;
    }
    let cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
    let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
    if (truncWordWidth > wordWrapWidth) {
      while (cutoffIndex > 0) {
        truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
        if (truncWordWidth > wordWrapWidth) {
          cutoffIndex -= 1;
        } else {
          break;
        }
      }
    } else {
      while (cutoffIndex < wordLen) {
        truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
        if (truncWordWidth < wordWrapWidth) {
          cutoffIndex += 1;
        } else {
          cutoffIndex -= 1;
          break;
        }
      }
    }
    return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : "");
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   */
  wrapText(text, wordWrapWidth, letterSpacing, indent = 0) {
    const spaceRegex = / |\u200B/g;
    const lines = text.split(/\r?\n/g);
    let allLines = [];
    const realNewlines = [];
    for (let i = 0; i < lines.length; i++) {
      const resultLines = [];
      let result = "";
      let spaceLeft = wordWrapWidth - indent;
      const words = lines[i].split(spaceRegex);
      const spaces = lines[i].match(spaceRegex) || [];
      for (let j = 0; j < words.length; j++) {
        const space = spaces[j - 1] || "";
        const word = words[j];
        const wordWidth = this.measureText(word, letterSpacing);
        const wordWidthWithSpace = isZeroWidthSpace(space) ? wordWidth : wordWidth + this.measureText(space, letterSpacing);
        if (j === 0 || wordWidthWithSpace > spaceLeft) {
          if (j > 0) {
            resultLines.push(result);
            result = "";
          }
          result += word;
          spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
        } else {
          spaceLeft -= wordWidthWithSpace;
          result += space + word;
        }
      }
      resultLines.push(result);
      result = "";
      allLines = allLines.concat(resultLines);
      if (i < lines.length - 1) {
        realNewlines.push(allLines.length);
      }
    }
    return { l: allLines, n: realNewlines };
  }
  measureText(word, space = 0) {
    if (!space) {
      return this._context.measureText(word).width;
    }
    return word.split("").reduce((acc, char) => {
      if (isZeroWidthSpace(char)) {
        return acc;
      }
      return acc + this._context.measureText(char).width + space;
    }, 0);
  }
  mergeDefaults(settings2) {
    return {
      text: "",
      w: 0,
      h: 0,
      fontStyle: "normal",
      fontSize: 40,
      fontFamily: null,
      trFontFace: null,
      wordWrap: true,
      wordWrapWidth: 0,
      wordBreak: false,
      textOverflow: "",
      lineHeight: null,
      textBaseline: "alphabetic",
      textAlign: "left",
      verticalAlign: "top",
      offsetY: null,
      maxLines: 0,
      maxHeight: null,
      overflowSuffix: "...",
      textColor: [1, 1, 1, 1],
      paddingLeft: 0,
      paddingRight: 0,
      shadow: false,
      shadowColor: [0, 0, 0, 1],
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      shadowBlur: 5,
      highlight: false,
      highlightHeight: 0,
      highlightColor: [0, 0, 0, 1],
      highlightOffset: 0,
      highlightPaddingLeft: 0,
      highlightPaddingRight: 0,
      letterSpacing: 0,
      textIndent: 0,
      cutSx: 0,
      cutEx: 0,
      cutSy: 0,
      cutEy: 0,
      advancedRenderer: false,
      fontBaselineRatio: 0,
      precision: 1,
      textRenderIssueMargin: 0,
      ...settings2
    };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/text-rendering/renderers/CanvasTextRenderer.js
var resolvedGlobal = typeof self === "undefined" ? globalThis : self;
var _a;
var globalFontSet = ((_a = resolvedGlobal.document) == null ? void 0 : _a.fonts) || resolvedGlobal.fonts;
function getFontCssString(props) {
  const { fontFamily, fontStyle, fontWeight, fontStretch, fontSize } = props;
  return [fontStyle, fontWeight, fontStretch, `${fontSize}px`, fontFamily].join(" ");
}
var CanvasTextRenderer = class extends TextRenderer {
  constructor(stage2) {
    super(stage2);
    __publicField(this, "canvas");
    __publicField(this, "context");
    /**
     * Font family map used to store web font faces that were added to the
     * canvas text renderer.
     */
    __publicField(this, "fontFamilies", {});
    __publicField(this, "fontFamilyArray", [this.fontFamilies]);
    __publicField(this, "type", "canvas");
    __publicField(this, "loadFont", (state) => {
      const cssString = getFontCssString(state.props);
      const trFontFace = this.stage.fontManager.resolveFontFace(this.fontFamilyArray, state.props, "canvas");
      assertTruthy(trFontFace, `Could not resolve font face for ${cssString}`);
      state.fontInfo = {
        fontFace: trFontFace,
        cssString,
        // TODO: For efficiency we would use this here but it's not reliable on WPE -> document.fonts.check(cssString),
        loaded: false
      };
      if (!state.fontInfo.loaded) {
        globalFontSet.load(cssString).then(this.onFontLoaded.bind(this, state, cssString)).catch(this.onFontLoadError.bind(this, state, cssString));
        return;
      }
    });
    if (typeof OffscreenCanvas !== "undefined") {
      this.canvas = new OffscreenCanvas(0, 0);
    } else {
      this.canvas = document.createElement("canvas");
    }
    let context = this.canvas.getContext("2d", {
      willReadFrequently: true
    });
    if (!context) {
      this.canvas = document.createElement("canvas");
      context = this.canvas.getContext("2d", {
        willReadFrequently: true
      });
    }
    assertTruthy(context);
    this.context = context;
    this.addFontFace(new WebTrFontFace({
      fontFamily: "sans-serif",
      descriptors: {},
      fontUrl: ""
    }));
  }
  //#region Overrides
  getPropertySetters() {
    return {
      fontFamily: (state, value) => {
        state.props.fontFamily = value;
        state.fontInfo = void 0;
        this.invalidateLayoutCache(state);
      },
      fontWeight: (state, value) => {
        state.props.fontWeight = value;
        state.fontInfo = void 0;
        this.invalidateLayoutCache(state);
      },
      fontStyle: (state, value) => {
        state.props.fontStyle = value;
        state.fontInfo = void 0;
        this.invalidateLayoutCache(state);
      },
      fontStretch: (state, value) => {
        state.props.fontStretch = value;
        state.fontInfo = void 0;
        this.invalidateLayoutCache(state);
      },
      fontSize: (state, value) => {
        state.props.fontSize = value;
        state.fontInfo = void 0;
        this.invalidateLayoutCache(state);
      },
      text: (state, value) => {
        state.props.text = value;
        this.invalidateLayoutCache(state);
      },
      textAlign: (state, value) => {
        state.props.textAlign = value;
        this.invalidateLayoutCache(state);
      },
      color: (state, value) => {
        state.props.color = value;
        this.invalidateLayoutCache(state);
      },
      x: (state, value) => {
        state.props.x = value;
      },
      y: (state, value) => {
        state.props.y = value;
      },
      contain: (state, value) => {
        state.props.contain = value;
        this.invalidateLayoutCache(state);
      },
      width: (state, value) => {
        state.props.width = value;
        if (state.props.contain !== "none") {
          this.invalidateLayoutCache(state);
        }
      },
      height: (state, value) => {
        state.props.height = value;
        if (state.props.contain === "both") {
          this.invalidateLayoutCache(state);
        }
      },
      offsetY: (state, value) => {
        state.props.offsetY = value;
        this.invalidateLayoutCache(state);
      },
      scrollY: (state, value) => {
        state.props.scrollY = value;
      },
      letterSpacing: (state, value) => {
        state.props.letterSpacing = value;
        this.invalidateLayoutCache(state);
      },
      lineHeight: (state, value) => {
        state.props.lineHeight = value;
        this.invalidateLayoutCache(state);
      },
      maxLines: (state, value) => {
        state.props.maxLines = value;
        this.invalidateLayoutCache(state);
      },
      textBaseline: (state, value) => {
        state.props.textBaseline = value;
        this.invalidateLayoutCache(state);
      },
      verticalAlign: (state, value) => {
        state.props.verticalAlign = value;
        this.invalidateLayoutCache(state);
      },
      overflowSuffix: (state, value) => {
        state.props.overflowSuffix = value;
        this.invalidateLayoutCache(state);
      }
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  canRenderFont(props) {
    return true;
  }
  isFontFaceSupported(fontFace) {
    return fontFace instanceof WebTrFontFace;
  }
  addFontFace(fontFace) {
    assertTruthy(fontFace instanceof WebTrFontFace);
    const fontFamily = fontFace.fontFamily;
    if (fontFamily !== "sans-serif") {
      globalFontSet.add(fontFace.fontFace);
    }
    let faceSet = this.fontFamilies[fontFamily];
    if (!faceSet) {
      faceSet = /* @__PURE__ */ new Set();
      this.fontFamilies[fontFamily] = faceSet;
    }
    faceSet.add(fontFace);
  }
  createState(props, node) {
    return {
      node,
      props,
      status: "initialState",
      updateScheduled: false,
      emitter: new EventEmitter(),
      textureNode: void 0,
      lightning2TextRenderer: new LightningTextTextureRenderer(this.canvas, this.context),
      renderInfo: void 0,
      forceFullLayoutCalc: false,
      textW: 0,
      textH: 0,
      fontInfo: void 0,
      isRenderable: false,
      debugData: {
        updateCount: 0,
        layoutCount: 0,
        drawCount: 0,
        lastLayoutNumCharacters: 0,
        layoutSum: 0,
        drawSum: 0,
        bufferSize: 0
      }
    };
  }
  updateState(state) {
    if (state.status === "initialState") {
      this.setStatus(state, "loading");
    }
    if (state.status === "loaded") {
      return;
    }
    if (!state.fontInfo) {
      return this.loadFont(state);
    }
    if (!state.fontInfo.loaded) {
      return;
    }
    if (!state.renderInfo) {
      state.renderInfo = this.calculateRenderInfo(state);
      state.textH = state.renderInfo.lineHeight * state.renderInfo.lines.length;
      state.textW = state.renderInfo.width;
      this.renderSingleCanvasPage(state);
    }
  }
  renderSingleCanvasPage(state) {
    assertTruthy(state.renderInfo);
    const node = state.node;
    const texture = this.stage.txManager.loadTexture("ImageTexture", {
      src: (function(lightning2TextRenderer, renderInfo) {
        assertTruthy(renderInfo);
        lightning2TextRenderer.draw(renderInfo, {
          lines: renderInfo.lines,
          lineWidths: renderInfo.lineWidths
        });
        if (this.canvas.width === 0 || this.canvas.height === 0) {
          return null;
        }
        return this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
      }).bind(this, state.lightning2TextRenderer, state.renderInfo)
    });
    if (state.textureNode) {
      state.textureNode.texture = texture;
      state.textureNode.alpha = getNormalizedAlphaComponent(state.props.color);
    } else {
      const textureNode = this.stage.createNode({
        parent: node,
        texture,
        autosize: true,
        // The alpha channel of the color is ignored when rasterizing the text
        // texture so we need to pass it directly to the texture node.
        alpha: getNormalizedAlphaComponent(state.props.color)
      });
      state.textureNode = textureNode;
    }
    this.setStatus(state, "loaded");
  }
  calculateRenderInfo(state) {
    var _a2;
    state.lightning2TextRenderer.settings = {
      text: state.props.text,
      textAlign: state.props.textAlign,
      fontFamily: state.props.fontFamily,
      trFontFace: (_a2 = state.fontInfo) == null ? void 0 : _a2.fontFace,
      fontSize: state.props.fontSize,
      fontStyle: [
        state.props.fontStretch,
        state.props.fontStyle,
        state.props.fontWeight
      ].join(" "),
      textColor: getNormalizedRgbaComponents(state.props.color),
      offsetY: state.props.offsetY,
      wordWrap: state.props.contain !== "none",
      wordWrapWidth: state.props.contain === "none" ? void 0 : state.props.width,
      letterSpacing: state.props.letterSpacing,
      lineHeight: state.props.lineHeight ?? null,
      maxLines: state.props.maxLines,
      maxHeight: state.props.contain === "both" ? state.props.height - state.props.offsetY : null,
      textBaseline: state.props.textBaseline,
      verticalAlign: state.props.verticalAlign,
      overflowSuffix: state.props.overflowSuffix,
      w: state.props.contain !== "none" ? state.props.width : void 0
    };
    state.renderInfo = state.lightning2TextRenderer.calculateRenderInfo();
    return state.renderInfo;
  }
  renderQuads() {
    return;
  }
  destroyState(state) {
    if (state.status === "destroyed") {
      return;
    }
    super.destroyState(state);
    if (state.textureNode) {
      state.textureNode.destroy();
      delete state.textureNode;
    }
    delete state.renderInfo;
  }
  //#endregion Overrides
  /**
   * Invalidate the layout cache stored in the state. This will cause the text
   * to be re-rendered on the next update.
   *
   * @remarks
   * This also invalidates the visible window cache.
   *
   * @param state
   */
  invalidateLayoutCache(state) {
    state.renderInfo = void 0;
    this.setStatus(state, "loading");
    this.scheduleUpdateState(state);
  }
  onFontLoaded(state, cssString) {
    var _a2;
    if (cssString !== ((_a2 = state.fontInfo) == null ? void 0 : _a2.cssString) || !state.fontInfo) {
      return;
    }
    state.fontInfo.loaded = true;
    this.scheduleUpdateState(state);
  }
  onFontLoadError(state, cssString, error) {
    var _a2;
    if (cssString !== ((_a2 = state.fontInfo) == null ? void 0 : _a2.cssString) || !state.fontInfo) {
      return;
    }
    state.fontInfo.loaded = true;
    console.error(`CanvasTextRenderer: Error loading font '${state.fontInfo.cssString}'`, error);
    this.scheduleUpdateState(state);
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/internal/ColorUtils.js
var WHITE = {
  isWhite: true,
  a: 1,
  r: 255,
  g: 255,
  b: 255
};
function parseColor(abgr) {
  if (abgr === 4294967295) {
    return WHITE;
  }
  const a = (abgr >>> 24 & 255) / 255;
  const b = abgr >>> 16 & 255 & 255;
  const g = abgr >>> 8 & 255 & 255;
  const r = abgr & 255 & 255;
  return { isWhite: false, a, r, g, b };
}
function parseColorRgba(rgba2) {
  if (rgba2 === 4294967295) {
    return WHITE;
  }
  const r = rgba2 >>> 24 & 255;
  const g = rgba2 >>> 16 & 255 & 255;
  const b = rgba2 >>> 8 & 255 & 255;
  const a = (rgba2 & 255 & 255) / 255;
  return { isWhite: false, r, g, b, a };
}
function formatRgba({ a, r, g, b }) {
  return `rgba(${r},${g},${b},${a})`;
}

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/CanvasCoreTexture.js
var CanvasCoreTexture = class extends CoreContextTexture {
  constructor() {
    super(...arguments);
    __publicField(this, "image");
    __publicField(this, "tintCache");
  }
  load() {
    if (this.textureSource.state !== "freed") {
      return;
    }
    this.textureSource.setState("loading");
    this.onLoadRequest().then((size) => {
      this.textureSource.setState("loaded", size);
      this.updateMemSize();
    }).catch((err) => {
      this.textureSource.setState("failed", err);
    });
  }
  free() {
    this.image = void 0;
    this.tintCache = void 0;
    this.textureSource.setState("freed");
    this.setTextureMemUse(0);
  }
  updateMemSize() {
    const mult = this.tintCache ? 8 : 4;
    if (this.textureSource.dimensions) {
      const { width, height } = this.textureSource.dimensions;
      this.setTextureMemUse(width * height * mult);
    }
  }
  hasImage() {
    return this.image !== void 0;
  }
  getImage(color) {
    var _a2;
    const image = this.image;
    assertTruthy(image, "Attempt to get unloaded image texture");
    if (color.isWhite) {
      if (this.tintCache) {
        this.tintCache = void 0;
        this.updateMemSize();
      }
      return image;
    }
    const key = formatRgba(color);
    if (((_a2 = this.tintCache) == null ? void 0 : _a2.key) === key) {
      return this.tintCache.image;
    }
    const tintedImage = this.tintTexture(image, key);
    this.tintCache = {
      key,
      image: tintedImage
    };
    this.updateMemSize();
    return tintedImage;
  }
  tintTexture(source, color) {
    const { width, height } = source;
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (ctx) {
      ctx.fillStyle = color;
      ctx.globalCompositeOperation = "copy";
      ctx.fillRect(0, 0, width, height);
      ctx.globalCompositeOperation = "multiply";
      ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
      ctx.globalCompositeOperation = "destination-in";
      ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
    }
    return canvas;
  }
  async onLoadRequest() {
    const { data } = await this.textureSource.getTextureData();
    if (data instanceof ImageData) {
      const canvas = document.createElement("canvas");
      canvas.width = data.width;
      canvas.height = data.height;
      const ctx = canvas.getContext("2d");
      if (ctx)
        ctx.putImageData(data, 0, 0);
      this.image = canvas;
      return { width: data.width, height: data.height };
    } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
      this.image = data;
      return { width: data.width, height: data.height };
    }
    return { width: 0, height: 0 };
  }
};

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/internal/C2DShaderUtils.js
function getRadius(quad) {
  var _a2, _b;
  if (quad.shader instanceof UnsupportedShader) {
    const shType = quad.shader.shType;
    if (shType === ROUNDED_RECTANGLE_SHADER_TYPE) {
      return ((_a2 = quad.shaderProps) == null ? void 0 : _a2.radius) ?? 0;
    } else if (shType === "DynamicShader") {
      const effects = (_b = quad.shaderProps) == null ? void 0 : _b.effects;
      if (effects) {
        const effect2 = effects.find((effect3) => {
          var _a3;
          return effect3.type === "radius" && ((_a3 = effect3 == null ? void 0 : effect3.props) == null ? void 0 : _a3.radius);
        });
        return effect2 && effect2.type === "radius" && effect2.props.radius || 0;
      }
    }
  }
  return 0;
}
function getBorder(quad, direction = "") {
  var _a2;
  if (quad.shader instanceof UnsupportedShader) {
    const shType = quad.shader.shType;
    if (shType === "DynamicShader") {
      const effects = (_a2 = quad.shaderProps) == null ? void 0 : _a2.effects;
      if (effects && effects.length) {
        const effect2 = effects.find((effect3) => {
          return effect3.type === `border${direction}` && effect3.props && effect3.props.width;
        });
        return effect2 && effect2.props;
      }
    }
  }
  return void 0;
}
function strokeLine(ctx, x, y, width, height, lineWidth = 0, color, direction) {
  if (!lineWidth) {
    return;
  }
  let sx, sy = 0;
  let ex, ey = 0;
  switch (direction) {
    case "Top":
      sx = x;
      sy = y;
      ex = width + x;
      ey = y;
      break;
    case "Right":
      sx = x + width;
      sy = y;
      ex = x + width;
      ey = y + height;
      break;
    case "Bottom":
      sx = x;
      sy = y + height;
      ex = x + width;
      ey = y + height;
      break;
    case "Left":
      sx = x;
      sy = y;
      ex = x;
      ey = y + height;
      break;
  }
  ctx.beginPath();
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = formatRgba(parseColorRgba(color ?? 0));
  ctx.moveTo(sx, sy);
  ctx.lineTo(ex, ey);
  ctx.stroke();
}

// node_modules/@lightningjs/renderer/dist/src/core/renderers/canvas/CanvasCoreRenderer.js
var CanvasCoreRenderer = class extends CoreRenderer {
  constructor(options) {
    super(options);
    __publicField(this, "context");
    __publicField(this, "canvas");
    __publicField(this, "pixelRatio");
    __publicField(this, "clearColor");
    __publicField(this, "renderToTextureActive", false);
    __publicField(this, "activeRttNode", null);
    __publicField(this, "defShaderCtr");
    this.mode = "canvas";
    this.shManager.renderer = this;
    const { canvas, pixelRatio, clearColor } = options;
    this.canvas = canvas;
    this.context = canvas.getContext("2d");
    this.pixelRatio = pixelRatio;
    this.clearColor = clearColor ? getRgbaComponents(clearColor) : void 0;
    this.defShaderCtr = {
      type: "DefaultShader",
      props: {},
      shader: new UnsupportedShader("DefaultShader"),
      getResolvedProps: () => () => {
        return {};
      }
    };
  }
  reset() {
    this.canvas.width = this.canvas.width;
    const ctx = this.context;
    if (this.clearColor) {
      const [r, g, b, a] = this.clearColor;
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    ctx.scale(this.pixelRatio, this.pixelRatio);
  }
  render() {
  }
  addQuad(quad) {
    const ctx = this.context;
    const { tx, ty, width, height, alpha, colorTl, colorTr, colorBr, ta, tb, tc, td, clippingRect } = quad;
    let texture = quad.texture;
    let ctxTexture = void 0;
    let frame;
    if (texture) {
      if (texture instanceof SubTexture) {
        frame = texture.props;
        texture = texture.parentTexture;
      }
      ctxTexture = texture.ctxTexture;
      if (texture.state === "freed") {
        ctxTexture.load();
        return;
      }
      if (texture.state !== "loaded" || !ctxTexture.hasImage()) {
        return;
      }
    }
    const color = parseColor(colorTl);
    const hasTransform = ta !== 1;
    const hasClipping = clippingRect.width !== 0 && clippingRect.height !== 0;
    const hasGradient = colorTl !== colorTr || colorTl !== colorBr;
    const hasQuadShader = Boolean(quad.shader);
    const radius = hasQuadShader ? getRadius(quad) : 0;
    const border = hasQuadShader ? getBorder(quad) : void 0;
    if (hasTransform || hasClipping || radius) {
      ctx.save();
    }
    if (hasClipping) {
      const path = new Path2D();
      const { x, y, width: width2, height: height2 } = clippingRect;
      path.rect(x, y, width2, height2);
      ctx.clip(path);
    }
    if (hasTransform) {
      const scale = this.pixelRatio;
      ctx.setTransform(ta, tc, tb, td, tx * scale, ty * scale);
      ctx.scale(scale, scale);
      ctx.translate(-tx, -ty);
    }
    if (radius) {
      const path = new Path2D();
      path.roundRect(tx, ty, width, height, radius);
      ctx.clip(path);
    }
    if (ctxTexture) {
      const image = ctxTexture.getImage(color);
      ctx.globalAlpha = color.a ?? alpha;
      if (frame) {
        ctx.drawImage(image, frame.x, frame.y, frame.width, frame.height, tx, ty, width, height);
      } else {
        ctx.drawImage(image, tx, ty, width, height);
      }
      ctx.globalAlpha = 1;
    } else if (hasGradient) {
      let endX = tx;
      let endY = ty;
      let endColor;
      if (colorTl === colorTr) {
        endX = tx;
        endY = ty + height;
        endColor = parseColor(colorBr);
      } else {
        endX = tx + width;
        endY = ty;
        endColor = parseColor(colorTr);
      }
      const gradient = ctx.createLinearGradient(tx, ty, endX, endY);
      gradient.addColorStop(0, formatRgba(color));
      gradient.addColorStop(1, formatRgba(endColor));
      ctx.fillStyle = gradient;
      ctx.fillRect(tx, ty, width, height);
    } else {
      ctx.fillStyle = formatRgba(color);
      ctx.fillRect(tx, ty, width, height);
    }
    if (border && border.width) {
      const borderWidth = border.width;
      const borderInnerWidth = border.width / 2;
      const borderColor = formatRgba(parseColorRgba(border.color ?? 0));
      ctx.beginPath();
      ctx.lineWidth = borderWidth;
      ctx.strokeStyle = borderColor;
      ctx.globalAlpha = alpha;
      if (radius) {
        ctx.roundRect(tx + borderInnerWidth, ty + borderInnerWidth, width - borderWidth, height - borderWidth, radius);
        ctx.stroke();
      } else {
        ctx.strokeRect(tx + borderInnerWidth, ty + borderInnerWidth, width - borderWidth, height - borderWidth);
      }
      ctx.globalAlpha = 1;
    } else if (hasQuadShader) {
      const borderTop = getBorder(quad, "Top");
      const borderRight = getBorder(quad, "Right");
      const borderBottom = getBorder(quad, "Bottom");
      const borderLeft = getBorder(quad, "Left");
      if (borderTop) {
        strokeLine(ctx, tx, ty, width, height, borderTop.width, borderTop.color, "Top");
      }
      if (borderRight) {
        strokeLine(ctx, tx, ty, width, height, borderRight.width, borderRight.color, "Right");
      }
      if (borderBottom) {
        strokeLine(ctx, tx, ty, width, height, borderBottom.width, borderBottom.color, "Bottom");
      }
      if (borderLeft) {
        strokeLine(ctx, tx, ty, width, height, borderLeft.width, borderLeft.color, "Left");
      }
    }
    if (hasTransform || hasClipping || radius) {
      ctx.restore();
    }
  }
  createCtxTexture(textureSource) {
    return new CanvasCoreTexture(this.txMemManager, textureSource);
  }
  getShaderManager() {
    return this.shManager;
  }
  getDefShaderCtr() {
    return this.defShaderCtr;
  }
  renderRTTNodes() {
  }
  removeRTTNode(node) {
  }
  renderToTexture(node) {
  }
  getBufferInfo() {
    return null;
  }
};

// node_modules/@lightningjs/renderer/dist/src/main-api/Inspector.js
var stylePropertyMap = {
  alpha: (v) => {
    if (v === 1) {
      return null;
    }
    return { prop: "opacity", value: `${v}` };
  },
  x: (x) => {
    return { prop: "left", value: `${x}px` };
  },
  y: (y) => {
    return { prop: "top", value: `${y}px` };
  },
  width: (w) => {
    if (w === 0) {
      return null;
    }
    return { prop: "width", value: `${w}px` };
  },
  height: (h) => {
    if (h === 0) {
      return null;
    }
    return { prop: "height", value: `${h}px` };
  },
  zIndex: () => "z-index",
  fontFamily: () => "font-family",
  fontSize: () => "font-size",
  fontStyle: () => "font-style",
  fontWeight: () => "font-weight",
  fontStretch: () => "font-stretch",
  lineHeight: () => "line-height",
  letterSpacing: () => "letter-spacing",
  textAlign: () => "text-align",
  overflowSuffix: () => "overflow-suffix",
  maxLines: () => "max-lines",
  contain: () => "contain",
  verticalAlign: () => "vertical-align",
  clipping: (v) => {
    if (v === false) {
      return null;
    }
    return { prop: "overflow", value: v ? "hidden" : "visible" };
  },
  rotation: (v) => {
    if (v === 0) {
      return null;
    }
    return { prop: "transform", value: `rotate(${v}rad)` };
  },
  scale: (v) => {
    if (v === 1) {
      return null;
    }
    return { prop: "transform", value: `scale(${v})` };
  },
  scaleX: (v) => {
    if (v === 1) {
      return null;
    }
    return { prop: "transform", value: `scaleX(${v})` };
  },
  scaleY: (v) => {
    if (v === 1) {
      return null;
    }
    return { prop: "transform", value: `scaleY(${v})` };
  },
  color: (v) => {
    if (v === 0) {
      return null;
    }
    return { prop: "color", value: convertColorToRgba(v) };
  }
};
var convertColorToRgba = (color) => {
  const a = (color & 255) / 255;
  const b = color >> 8 & 255;
  const g = color >> 16 & 255;
  const r = color >> 24 & 255;
  return `rgba(${r},${g},${b},${a})`;
};
var domPropertyMap = {
  id: "test-id"
};
var knownProperties = /* @__PURE__ */ new Set([
  ...Object.keys(stylePropertyMap),
  ...Object.keys(domPropertyMap),
  // ...gradientColorPropertyMap,
  "src",
  "parent"
]);
var Inspector = class {
  constructor(canvas, settings2) {
    __publicField(this, "root", null);
    __publicField(this, "canvas", null);
    __publicField(this, "height", 1080);
    __publicField(this, "width", 1920);
    __publicField(this, "scaleX", 1);
    __publicField(this, "scaleY", 1);
    if (isProductionEnvironment())
      return;
    if (!settings2) {
      throw new Error("settings is required");
    }
    this.height = Math.ceil(settings2.appHeight ?? 1080 / (settings2.deviceLogicalPixelRatio ?? 1));
    this.width = Math.ceil(settings2.appWidth ?? 1920 / (settings2.deviceLogicalPixelRatio ?? 1));
    this.scaleX = settings2.deviceLogicalPixelRatio ?? 1;
    this.scaleY = settings2.deviceLogicalPixelRatio ?? 1;
    this.canvas = canvas;
    this.root = document.createElement("div");
    this.setRootPosition();
    document.body.appendChild(this.root);
    const mutationObserver = new MutationObserver(this.setRootPosition.bind(this));
    mutationObserver.observe(canvas, {
      attributes: true,
      childList: false,
      subtree: false
    });
    const resizeObserver = new ResizeObserver(this.setRootPosition.bind(this));
    resizeObserver.observe(canvas);
    window.addEventListener("resize", this.setRootPosition.bind(this));
    console.warn("Inspector is enabled, this will impact performance");
  }
  setRootPosition() {
    if (this.root === null || this.canvas === null) {
      return;
    }
    const rect = this.canvas.getBoundingClientRect();
    const top = document.documentElement.scrollTop + rect.top;
    const left = document.documentElement.scrollLeft + rect.left;
    this.root.id = "root";
    this.root.style.left = `${left}px`;
    this.root.style.top = `${top}px`;
    this.root.style.width = `${this.width}px`;
    this.root.style.height = `${this.height}px`;
    this.root.style.position = "absolute";
    this.root.style.transformOrigin = "0 0 0";
    this.root.style.transform = `scale(${this.scaleX}, ${this.scaleY})`;
    this.root.style.overflow = "hidden";
    this.root.style.zIndex = "65534";
  }
  createDiv(id, properties) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.id = id.toString();
    for (const key in properties) {
      this.updateNodeProperty(
        div,
        // really typescript? really?
        key,
        properties[key],
        properties
      );
    }
    return div;
  }
  createNode(node) {
    const div = this.createDiv(node.id, node.props);
    div.node = node;
    node.div = div;
    node.on("inViewport", () => div.setAttribute("state", "inViewport"));
    node.on("inBounds", () => div.setAttribute("state", "inBounds"));
    node.on("outOfBounds", () => div.setAttribute("state", "outOfBounds"));
    return this.createProxy(node, div);
  }
  createTextNode(node) {
    const div = this.createDiv(node.id, node.props);
    div.node = node;
    node.div = div;
    return this.createProxy(node, div);
  }
  createProxy(node, div) {
    knownProperties.forEach((property) => {
      let originalProp = Object.getOwnPropertyDescriptor(node, property);
      if (originalProp === void 0) {
        const proto = Object.getPrototypeOf(node);
        originalProp = Object.getOwnPropertyDescriptor(proto, property);
      }
      if (originalProp === void 0) {
        return;
      }
      Object.defineProperty(node, property, {
        get() {
          var _a2;
          return (_a2 = originalProp == null ? void 0 : originalProp.get) == null ? void 0 : _a2.call(node);
        },
        set: (value) => {
          var _a2;
          (_a2 = originalProp == null ? void 0 : originalProp.set) == null ? void 0 : _a2.call(node, value);
          this.updateNodeProperty(div, property, value, node.props);
        },
        configurable: true,
        enumerable: true
      });
    });
    const originalDestroy = node.destroy;
    Object.defineProperty(node, "destroy", {
      value: () => {
        this.destroyNode(node.id);
        originalDestroy.call(node);
      }
    });
    const originalAnimate = node.animate;
    Object.defineProperty(node, "animate", {
      value: (props, settings2) => {
        const animationController = originalAnimate.call(node, props, settings2);
        const originalStart = animationController.start.bind(animationController);
        animationController.start = () => {
          this.animateNode(div, props, settings2);
          return originalStart();
        };
        return animationController;
      }
    });
    return node;
  }
  destroyNode(id) {
    const div = document.getElementById(id.toString());
    div == null ? void 0 : div.remove();
  }
  updateNodeProperty(div, property, value, props) {
    var _a2;
    if (this.root === null || value === void 0 || value === null) {
      return;
    }
    if (property === "parent") {
      const parentId = value.id;
      if (parentId === 1) {
        this.root.appendChild(div);
        return;
      }
      const parent = document.getElementById(parentId.toString());
      parent == null ? void 0 : parent.appendChild(div);
      return;
    }
    if (property === "text") {
      div.innerHTML = String(value);
      div.style.visibility = "hidden";
      return;
    }
    if (property === "src" && value) {
      div.setAttribute(`data-src`, String(value));
      return;
    }
    if (stylePropertyMap[property]) {
      const mappedStyleResponse = (_a2 = stylePropertyMap[property]) == null ? void 0 : _a2.call(stylePropertyMap, value);
      if (mappedStyleResponse === null) {
        return;
      }
      if (typeof mappedStyleResponse === "string") {
        div.style.setProperty(mappedStyleResponse, String(value));
        return;
      }
      if (typeof mappedStyleResponse === "object") {
        let value2 = mappedStyleResponse.value;
        if (property === "x") {
          const mount = props.mountX;
          const width = props.width;
          if (mount) {
            value2 = `${parseInt(value2) - width * mount}px`;
          }
        } else if (property === "y") {
          const mount = props.mountY;
          const height = props.height;
          if (mount) {
            value2 = `${parseInt(value2) - height * mount}px`;
          }
        }
        div.style.setProperty(mappedStyleResponse.prop, value2);
      }
      return;
    }
    if (domPropertyMap[property]) {
      const domProperty = domPropertyMap[property];
      if (!domProperty) {
        return;
      }
      div.setAttribute(String(domProperty), String(value));
      return;
    }
    if (property === "data") {
      for (const key in value) {
        const keyValue = value[key];
        if (keyValue === void 0) {
          div.removeAttribute(`data-${key}`);
        } else {
          div.setAttribute(`data-${key}`, String(keyValue));
        }
      }
      return;
    }
  }
  // simple animation handler
  animateNode(div, props, settings2) {
    const {
      duration = 1e3,
      delay = 0
      // easing = 'linear',
      // repeat = 0,
      // loop = false,
      // stopMethod = false,
    } = settings2;
    const { x, y, width, height, alpha = 1, rotation = 0, scale = 1, color, mountX, mountY } = props;
    function animate() {
      setTimeout(() => {
        div.style.top = `${y - height * mountY}px`;
        div.style.left = `${x - width * mountX}px`;
        div.style.width = `${width}px`;
        div.style.height = `${height}px`;
        div.style.opacity = `${alpha}`;
        div.style.rotate = `${rotation}rad`;
        div.style.scale = `${scale}`;
        div.style.color = convertColorToRgba(color);
      }, duration);
    }
    setTimeout(animate, delay);
  }
};

// node_modules/@lightningjs/blits/src/constants.js
var DEFAULT_HOLD_TIMEOUT_MS = 50;
var SCREEN_RESOLUTIONS = {
  hd: 0.66666667,
  "720p": 0.66666667,
  720: 0.66666667,
  fhd: 1,
  fullhd: 1,
  "1080p": 1,
  1080: 1,
  "4k": 2,
  "2160p": 2,
  2160: 2
};

// node_modules/@lightningjs/blits/src/engines/L3/fontLoader.js
var fontLoader_default = () => {
  const stage2 = renderer.stage;
  settings_default.get("fonts", []).forEach((font) => {
    if (font.type === "sdf" || font.type === "msdf") {
      if (!font.png && font.file) {
        font.png = font.file.replace(/\.[^.]+$/, `.${font.type}.png`);
      }
      if (!font.json && font.file) {
        font.json = font.file.replace(/\.[^.]+$/, `.${font.type}.json`);
      }
      stage2.fontManager.addFontFace(
        new SdfTrFontFace(font.type, {
          fontFamily: font.family,
          descriptors: {},
          atlasUrl: font.png,
          atlasDataUrl: font.json,
          stage: stage2,
          metrics: font.metrics
        })
      );
    } else if (font.type === "web") {
      stage2.fontManager.addFontFace(
        new WebTrFontFace({
          fontFamily: font.family,
          fontUrl: font.file,
          descriptors: {},
          metrics: font.metrics
        })
      );
    }
  });
};

// node_modules/@lightningjs/blits/src/engines/L3/shaderLoader.js
var shaderLoader_default = () => {
  const stage2 = renderer.stage;
  settings_default.get("shaders", []).forEach((shader) => {
    stage2.shManager.registerShaderType(shader.name, shader.type);
  });
  settings_default.get("effects", []).forEach((effect2) => {
    stage2.shManager.registerShaderType(effect2.name, effect2.type);
  });
};

// node_modules/@lightningjs/blits/src/engines/L3/launch.js
var renderer = {};
var renderEngine = (settings2) => {
  const renderMode = "renderMode" in settings2 ? settings2.renderMode : "webgl";
  if (renderMode === "webgl") return WebGlCoreRenderer;
  if (renderMode === "canvas") return CanvasCoreRenderer;
};
var textRenderEngines = (settings2) => {
  const renderMode = "renderMode" in settings2 ? settings2.renderMode : "webgl";
  if (renderMode === "webgl") return [SdfTextRenderer, CanvasTextRenderer];
  if (renderMode === "canvas") return [CanvasTextRenderer];
};
var launch_default = (App, target, settings2 = {}) => {
  renderer = new RendererMain(
    {
      appWidth: settings2.w || 1920,
      appHeight: settings2.h || 1080,
      fpsUpdateInterval: settings2.fpsInterval || 1e3,
      deviceLogicalPixelRatio: settings2.pixelRatio || SCREEN_RESOLUTIONS[settings2.screenResolution] || SCREEN_RESOLUTIONS[window.innerHeight] || 1,
      numImageWorkers: "webWorkersLimit" in settings2 ? settings2.webWorkersLimit : window.navigator.hardwareConcurrency || 2,
      clearColor: settings2.canvasColor && colors_default.normalize(settings2.canvasColor) || 0,
      inspector: settings2.inspector === true ? Inspector : void 0,
      boundsMargin: settings2.viewportMargin || 0,
      // gpu memory limit, converted from mb to bytes - defaults to 200mb
      txMemByteThreshold: "gpuMemoryLimit" in settings2 ? settings2.gpuMemoryLimit * 1024 * 1024 : 200 * 1024 * 1024,
      renderEngine: renderEngine(settings2),
      fontEngines: textRenderEngines(settings2)
    },
    target
  );
  const initApp = () => {
    let app = App();
    app.quit = () => {
      Log.info("Closing App");
      app.destroy();
      app = null;
      renderer = null;
    };
  };
  shaderLoader_default();
  fontLoader_default();
  initApp();
  return renderer;
};

// node_modules/@lightningjs/blits/src/engines/L3/element.js
var layoutFn = function(config) {
  let offset = 0;
  const position = config.direction === "vertical" ? "y" : "x";
  const oppositePosition = config.direction === "vertical" ? "x" : "y";
  const oppositeMount = config.direction === "vertical" ? "mountX" : "mountY";
  const dimension = config.direction === "vertical" ? "height" : "width";
  const oppositeDimension = config.direction === "vertical" ? "width" : "height";
  const children = this.children;
  const childrenLength = children.length;
  let otherDimension = 0;
  const gap = config.gap || 0;
  for (let i = 0; i < childrenLength; i++) {
    const node = children[i];
    node[position] = offset;
    if (dimension === "width") {
      offset += node.width + (node.width !== ("text" in node ? 1 : 0) ? gap : 0);
    } else if (dimension === "height") {
      offset += "text" in node ? node.width > 1 ? node.height + gap : 0 : node.height !== 0 ? node.height + gap : 0;
    }
    otherDimension = Math.max(otherDimension, node[oppositeDimension]);
  }
  this[dimension] = offset - gap;
  this[oppositeDimension] = otherDimension;
  const align = {
    start: 0,
    end: 1,
    center: 0.5
  }[config["align-items"] || "start"];
  if (align !== 0) {
    for (let i = 0; i < childrenLength; i++) {
      const node = children[i];
      node[oppositePosition] = otherDimension;
      node[oppositeMount] = align;
    }
  }
};
var isTransition = (value) => {
  return value !== null && typeof value === "object" && "transition" in value === true;
};
var isObjectString = (str) => {
  return typeof str === "string" && str.startsWith("{") && str.endsWith("}");
};
var parseToObject = (str) => {
  return JSON.parse(str.replace(/'/g, '"').replace(/([\w-_]+)\s*:/g, '"$1":'));
};
var parsePercentage = function(v, base) {
  if (typeof v !== "string") {
    return v;
  } else if (v.indexOf("%") === v.length - 1) {
    return this.element.config.parent && (this.element.config.parent.node[base] || 0) * (parseFloat(v) / 100) || 0;
  }
  return v;
};
var unpackTransition = (v) => {
  if (typeof v !== "object" || v === null) return v;
  if (v.constructor === Object) {
    if ("value" in v === true) {
      return v.value;
    }
    if ("transition" in v === true) {
      return unpackTransition(v.transition);
    }
  }
  return v;
};
var colorMap = {
  top: "colorTop",
  bottom: "colorBottom",
  left: "colorLeft",
  right: "colorRight"
};
var textDefaults = null;
var propsTransformer = {
  set parent(v) {
    this.props["parent"] = v === "root" ? renderer.root : v.node;
  },
  set rotation(v) {
    this.props["rotation"] = v * (Math.PI / 180);
  },
  set w(v) {
    this.props["width"] = parsePercentage.call(this, v, "width");
  },
  set width(v) {
    this.props["width"] = parsePercentage.call(this, v, "width");
  },
  set h(v) {
    this.props["height"] = parsePercentage.call(this, v, "height");
  },
  set height(v) {
    this.props["height"] = parsePercentage.call(this, v, "height");
  },
  set x(v) {
    this.props["x"] = parsePercentage.call(this, v, "width");
  },
  set y(v) {
    this.props["y"] = parsePercentage.call(this, v, "height");
  },
  set z(v) {
    this.props["zIndex"] = v;
  },
  set zIndex(v) {
    this.props["zIndex"] = v;
  },
  set color(v) {
    if (typeof v === "string" && v.startsWith("{") === false) {
      this.props["color"] = colors_default.normalize(v);
    } else if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      this.props["color"] = 0;
      Object.entries(v).forEach((color) => {
        this.props[colorMap[color[0]]] = colors_default.normalize(color[1]);
      });
    }
  },
  set src(v) {
    this.props["src"] = v;
    if (this.raw["color"] === void 0) {
      this.props["color"] = this.props["src"] ? 4294967295 : 0;
    }
  },
  set texture(v) {
    this.props["texture"] = v;
    if (this.raw["color"] === void 0 && (v === null || v === void 0)) {
      this.props["color"] = 0;
    } else if (this.raw["color"] === void 0) {
      this.props["color"] = 4294967295;
    }
  },
  set fit(v) {
    const resizeMode = {};
    if (v === "cover" || v === "contain") {
      this.props["textureOptions"] = { resizeMode: { type: v } };
      return;
    }
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      resizeMode["type"] = v.type || "cover";
      if (typeof v.position === "number") {
        resizeMode["clipY"] = resizeMode["clipX"] = v.position;
      }
      if (typeof v.position === "object") {
        resizeMode["clipX"] = "x" in v.position === true ? v.position.x : null;
        resizeMode["clipY"] = "y" in v.position === true ? v.position.y : null;
      }
      this.props["textureOptions"] = { resizeMode };
    }
  },
  set rtt(v) {
    this.props["rtt"] = v;
    if (v === true && this.raw["color"] === void 0) {
      this.props["color"] = 4294967295;
    }
  },
  set mount(v) {
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      if ("x" in v === true) {
        this.props["mountX"] = v.x;
      }
      if ("y" in v === true) {
        this.props["mountY"] = v.y;
      }
    } else {
      this.props["mountX"] = v;
      this.props["mountY"] = v;
    }
  },
  set pivot(v) {
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      if ("x" in v === true) {
        this.props["pivotX"] = v.x;
      }
      if ("y" in v === true) {
        this.props["pivotY"] = v.y;
      }
    } else {
      this.props["pivotX"] = v;
      this.props["pivotY"] = v;
    }
  },
  set scale(v) {
    if (typeof v === "object" || isObjectString(v) === true && (v = parseToObject(v))) {
      if ("x" in v === true) {
        this.props["scaleX"] = v.x;
      }
      if ("y" in v === true) {
        this.props["scaleY"] = v.y;
      }
    } else {
      this.props["scale"] = v;
    }
  },
  set show(v) {
    if (v) {
      this.props["alpha"] = 1;
      this.props["width"] = this.raw["w"] || this.raw["width"];
      this.props["height"] = this.raw["h"] || this.raw["height"];
    } else {
      this.props["alpha"] = 0;
      this.props["width"] = 0;
      this.props["height"] = 0;
    }
  },
  set alpha(v) {
    this.props["alpha"] = v;
  },
  set shader(v) {
    if (v !== null) {
      this.props["shader"] = renderer.createShader(v.type, v.props);
    } else {
      this.props["shader"] = renderer.createShader("DefaultShader");
    }
  },
  set effects(v) {
    for (let i = 0; i < v.length; i++) {
      if (v[i].props && v[i].props.color) {
        v[i].props.color = colors_default.normalize(v[i].props.color);
      }
    }
    this.props["shader"] = renderer.createShader("DynamicShader", {
      effects: v
    });
  },
  set clipping(v) {
    this.props["clipping"] = v;
  },
  set overflow(v) {
    this.props["clipping"] = !!!v;
  },
  set font(v) {
    this.props["fontFamily"] = v;
  },
  set size(v) {
    this.props["fontSize"] = v;
  },
  set wordwrap(v) {
    this.props["width"] = v;
    this.props["contain"] = "width";
  },
  set maxheight(v) {
    this.props["height"] = v;
    this.props["contain"] = "both";
  },
  set contain(v) {
    this.props["contain"] = v;
  },
  set maxlines(v) {
    this.props["maxLines"] = v;
  },
  set textoverflow(v) {
    this.props["overflowSuffix"] = v === false ? " " : v === true ? void 0 : v;
  },
  set letterspacing(v) {
    this.props["letterSpacing"] = v || 1;
  },
  set lineheight(v) {
    this.props["lineHeight"] = v;
  },
  set align(v) {
    this.props["textAlign"] = v;
  },
  set content(v) {
    this.props["text"] = "" + v;
  }
};
var Element = {
  populate(data) {
    const props = data;
    props["node"] = this.config.node;
    if (props[symbols_default.isSlot] === true) {
      this[symbols_default.isSlot] = true;
    }
    this.props.element = this;
    this.props["parent"] = props["parent"] || this.config.parent;
    delete props.parent;
    this.props.raw = data;
    const propKeys = Object.keys(props);
    const length = propKeys.length;
    for (let i = 0; i < length; i++) {
      const key = propKeys[i];
      const value = props[key];
      if (value !== void 0) {
        this.props[key] = unpackTransition(value);
      }
    }
    if (this.props.props["color"] === void 0 && "__textnode" in props === false) {
      this.props.props["color"] = 0;
    }
    this.node = props.__textnode ? renderer.createTextNode({ ...textDefaults, ...this.props.props }) : renderer.createNode(this.props.props);
    if (props["@loaded"] !== void 0 && typeof props["@loaded"] === "function") {
      this.node.on("loaded", (el, { type, dimensions }) => {
        props["@loaded"]({ w: dimensions.width, h: dimensions.height, type }, this);
      });
    }
    if (props["@error"] !== void 0 && typeof props["@error"] === "function") {
      this.node.on("failed", (el, error) => {
        props["@error"](error, this);
      });
    }
    if (props.__layout === true) {
      this.triggerLayout = layoutFn.bind(this.node);
    }
    if (this.config.parent.props !== void 0 && this.config.parent.props.__layout === true) {
      this.config.parent.triggerLayout(this.config.parent.props);
      this.node.on("loaded", () => {
        this.config.parent.triggerLayout(this.config.parent.props);
      });
    }
  },
  set(prop, value) {
    if (value === void 0) return;
    if (this.props.raw[prop] === value) return;
    this.props.raw[prop] = value;
    this.props.props = {};
    this.props[prop] = unpackTransition(value);
    const propsKeys = Object.keys(this.props.props);
    if (propsKeys.length === 1) {
      if (isTransition(value) === true) {
        return this.animate(propsKeys[0], this.props.props[propsKeys[0]], value.transition);
      }
      this.node[propsKeys[0]] = this.props.props[propsKeys[0]];
    } else {
      for (let i = 0; i < propsKeys.length; i++) {
        if (isTransition(value) === true) {
          return this.animate(propsKeys[i], this.props.props[propsKeys[i]], value.transition);
        }
        this.node[propsKeys[i]] = this.props.props[propsKeys[i]];
      }
    }
    if (this.config.parent.props && this.config.parent.props.__layout === true) {
      this.config.parent.triggerLayout(this.config.parent.props);
    }
  },
  animate(prop, value, transition) {
    if (this.scheduledTransitions[prop] !== void 0 && this.scheduledTransitions[prop].f.state === "scheduled") {
      this.scheduledTransitions[prop].f.stop();
    }
    if (this.node[prop] === value) return;
    const props = {};
    props[prop] = value;
    const f = this.node.animate(props, {
      duration: typeof transition === "object" ? "duration" in transition ? transition.duration : 300 : 300,
      easing: typeof transition === "object" ? "easing" in transition ? transition.easing : "ease" : "ease",
      delay: typeof transition === "object" ? "delay" in transition ? transition.delay : 0 : 0
    });
    const startValue = this.node[prop];
    this.scheduledTransitions[prop] = {
      v: props[prop],
      f
    };
    if (transition.start !== void 0 && typeof transition.start === "function") {
      f.once("animating", () => {
        transition.start.call(this.component, this, prop, startValue);
      });
    }
    if (this.config.parent.props && this.config.parent.props.__layout === true) {
      f.on("tick", () => {
        this.config.parent.triggerLayout(this.config.parent.props);
      });
    }
    if (transition.progress !== void 0 && typeof transition.progress === "function") {
      let prevProgress = 0;
      f.on("tick", (_node, { progress }) => {
        transition.progress.call(this.component, this, prop, progress, prevProgress);
        prevProgress = progress;
      });
    }
    f.once("stopped", () => {
      this.scheduledTransitions[prop] = void 0;
      if (transition.end && typeof transition.end === "function") {
        transition.end.call(this.component, this, prop, this.node[prop]);
      }
    });
    f.start();
  },
  destroy() {
    Log.debug("Deleting  Node", this.nodeId);
    this.node.destroy();
  },
  get nodeId() {
    return this.node && this.node.id;
  },
  get ref() {
    return this.props.ref || null;
  },
  get parent() {
    return this.node && this.node.parent;
  },
  get children() {
    return this.component[symbols_default.getChildren]().filter((child) => {
      return child.parent === (this[symbols_default.isSlot] ? this.node.children[0] : this.node);
    });
  }
};
var element_default = (config, component) => {
  if (textDefaults === null) {
    textDefaults = {
      fontSize: 32,
      fontFamily: settings_default.get("defaultFont", "sans-serif")
    };
  }
  return Object.assign(Object.create(Element), {
    props: Object.assign(Object.create(propsTransformer), { props: {} }),
    scheduledTransitions: {},
    config,
    component
  });
};

// node_modules/@lightningjs/blits/src/engines/L3/index.js
var L3_default = {
  Element: element_default,
  Launch: launch_default
};

// node_modules/@lightningjs/blits/src/launch.js
var renderer2 = {};
var stage = {};
var launch_default2 = (App, target, settings2) => {
  settings_default.set(settings2);
  initLog();
  stage.element = L3_default.Element;
  renderer2 = L3_default.Launch(App, target, settings2);
};

// node_modules/@lightningjs/blits/src/router/transitions/fadeInOut.js
var fadeInOut_default = {
  before: {
    prop: "alpha",
    value: 0
  },
  in: {
    prop: "alpha",
    value: 1,
    duration: 200
  },
  out: {
    prop: "alpha",
    value: 0,
    duration: 100
  }
};

// node_modules/@lightningjs/blits/src/announcer/speechSynthesis.js
var syn = window.speechSynthesis;
var getUA = () => (window.navigator || {}).userAgent || "";
var isAndroid = () => /android/i.test(getUA());
var initialized = false;
var infinityTimer = null;
var clear = () => infinityTimer && clearTimeout(infinityTimer);
var resumeInfinity = (target) => {
  if (!target || infinityTimer) {
    return clear();
  }
  syn.pause();
  syn.resume();
  infinityTimer = setTimeout(() => {
    resumeInfinity(target);
  }, 5e3);
};
var utterProps = {
  lang: "en-US",
  pitch: 1,
  rate: 1,
  voice: null,
  volume: 1
};
var initialize = () => {
  utterProps.voice = syn.getVoices()[0];
  initialized = true;
};
var utterance = (scope, e) => {
  const utter = new SpeechSynthesisUtterance(e.value);
  utter.lang = e.lang || utterProps.lang;
  utter.pitch = e.pitch || utterProps.pitch;
  utter.rate = e.rate || utterProps.rate;
  utter.voice = e.voice || utterProps.voice;
  utter.volume = e.volume || utterProps.volume;
  utter.onstart = () => {
    if (!isAndroid()) {
      resumeInfinity(utter);
    }
    scope.onstart();
  };
  utter.onresume = () => {
    if (!isAndroid()) {
      resumeInfinity(utter);
    }
    scope.onresume();
  };
  utter.onpause = () => {
    scope.onpause();
  };
  utter.onend = () => {
    scope.onend();
  };
  utter.onerror = () => {
    clear();
    scope.onerror();
  };
  syn.speak(utter);
};
var speechSynthesis_default = {
  speak(e) {
    if (!initialized) {
      initialize();
    }
    this.cancel();
    utterance(this, e);
  },
  resume() {
    syn.resume();
  },
  pause() {
    syn.pause();
  },
  cancel() {
    syn.cancel();
    clear();
  },
  getVoices() {
    return syn.getVoices();
  },
  onend() {
  },
  onerror() {
  },
  onstart() {
  },
  onresume() {
  },
  onpause() {
  }
};

// node_modules/@lightningjs/blits/src/announcer/announcer.js
var debounce;
var speak = (message, politeness = "off") => {
  clearTimeout(debounce);
  speechSynthesis_default.cancel();
  if (politeness === "assertive") {
    speechSynthesis_default.speak({ value: message });
  } else {
    debounce = setTimeout(() => {
      speechSynthesis_default.speak({ value: message });
    }, 400);
  }
};
var polite = (message) => speak(message, "polite");
var assertive = (message) => speak(message, "assertive");
var stop = () => {
  speechSynthesis_default.cancel();
};
var announcer_default = {
  speak,
  polite,
  assertive,
  stop
};

// node_modules/@lightningjs/blits/src/router/router.js
var currentRoute;
var navigating = false;
var cacheMap = /* @__PURE__ */ new WeakMap();
var history = [];
var overrideOptions = {};
var navigationData = {};
var navigatingBack = false;
var previousFocus;
var getHash = () => {
  return (document.location.hash || "/").replace(/^#/, "");
};
var normalizePath = (path) => {
  return path.replace(/^\/+|\/+$/g, "").toLowerCase();
};
var isObject = (v) => typeof v === "object" && v !== null;
var isString = (v) => typeof v === "string";
var matchHash = (path, routes = []) => {
  const originalPath = path;
  path = normalizePath(path);
  let matchingRoute = false;
  let i = 0;
  while (!matchingRoute && i < routes.length) {
    const route = routes[i];
    route.path = normalizePath(route.path);
    if (route.path === path) {
      route.params = {};
      matchingRoute = route;
    } else if (route.path.indexOf(":") > -1) {
      const dynamicRouteParts = [...route.path.matchAll(/:([^\s/]+)/gi)];
      let dynamicRoutePartsRegex = route.path;
      dynamicRouteParts.reverse().forEach((part) => {
        dynamicRoutePartsRegex = dynamicRoutePartsRegex.substring(0, part.index) + "([^\\s/]+)" + dynamicRoutePartsRegex.substring(part.index + part[0].length);
      });
      const match = originalPath.match(new RegExp(`${dynamicRoutePartsRegex}`, "i"));
      if (match) {
        route.params = dynamicRouteParts.reverse().reduce((acc, part, index) => {
          acc[part[1]] = match[index + 1];
          return acc;
        }, {});
        matchingRoute = route;
      }
    } else if (route.path.endsWith("*")) {
      const regex = new RegExp(route.path.replace(/\/?\*/, "/?([^\\s]*)"), "i");
      const match = path.match(regex);
      if (match) {
        if (match[1]) route.params = { path: match[1] };
        matchingRoute = route;
      }
    }
    i++;
  }
  if (matchingRoute) {
    matchingRoute.options = { ...matchingRoute.options, ...overrideOptions };
    if (!matchingRoute.data) {
      matchingRoute.data = {};
    }
    currentRoute = matchingRoute;
  }
  return matchingRoute;
};
var navigate = async function() {
  navigating = true;
  if (this.parent[symbols_default.routes]) {
    const previousRoute = currentRoute;
    const hash = getHash();
    let route = matchHash(hash, this.parent[symbols_default.routes]);
    let beforeHookOutput;
    if (route) {
      if (route.hooks) {
        if (route.hooks.before) {
          beforeHookOutput = await route.hooks.before(route, previousRoute);
          if (isString(beforeHookOutput)) {
            currentRoute = previousRoute;
            to(beforeHookOutput);
            return;
          }
        }
      }
      route = isObject(beforeHookOutput) ? beforeHookOutput : route;
      if (navigatingBack === false && previousRoute && previousRoute.options.inHistory === true) {
        history.push(previousRoute);
      }
      if (!("transition" in route)) {
        route.transition = fadeInOut_default;
      }
      if (typeof route.transition === "function") {
        route.transition = route.transition(previousRoute, route);
      }
      let holder;
      let { view, focus } = cacheMap.get(route) || {};
      if (!view) {
        holder = stage.element({ parent: this[symbols_default.children][0] });
        holder.populate({});
        holder.set("w", "100%");
        holder.set("h", "100%");
        const props = { ...this[symbols_default.props], ...route.params, ...navigationData, ...route.data };
        view = await route.component({ props }, holder, this);
        if (view[Symbol.toStringTag] === "Module") {
          if (view.default && typeof view.default === "function") {
            view = view.default({ props }, holder, this);
          } else {
            Log.error("Dynamic import doesn't have a default export or default is not a function");
          }
        }
        if (typeof view === "function") {
          view = view({ props }, holder, this);
        }
      } else {
        holder = view[symbols_default.holder];
      }
      this[symbols_default.children].push(view);
      previousFocus = focus_default.get();
      focus ? focus_default.set(focus) : focus_default.set(view);
      if (route.transition.before) {
        if (Array.isArray(route.transition.before)) {
          for (let i = 0; i < route.transition.before.length; i++) {
            holder.set(route.transition.before[i].prop, route.transition.before[i].value);
          }
        } else {
          holder.set(route.transition.before.prop, route.transition.before.value);
        }
      }
      let shouldAnimate = false;
      if (previousRoute) {
        shouldAnimate = true;
        const oldView = this[symbols_default.children].splice(1, 1).pop();
        if (oldView) {
          removeView(previousRoute, oldView, route.transition.out);
        }
      }
      if (route.transition.in) {
        if (Array.isArray(route.transition.in)) {
          for (let i = 0; i < route.transition.in.length; i++) {
            i === route.transition.length - 1 ? await setOrAnimate(holder, route.transition.in[i], shouldAnimate) : setOrAnimate(holder, route.transition.in[i], shouldAnimate);
          }
        } else {
          await setOrAnimate(holder, route.transition.in, shouldAnimate);
        }
      }
      if (route.announce) {
        if (typeof route.announce === "string") {
          route.announce = {
            message: route.announce
          };
        }
        announcer_default.speak(route.announce.message, route.announce.politeness);
      }
      this.activeView = this[symbols_default.children][this[symbols_default.children].length - 1];
    } else {
      Log.error(`Route ${hash} not found`);
    }
  }
  navigatingBack = false;
  navigating = false;
};
var removeView = async (route, view, transition) => {
  if (transition) {
    if (Array.isArray(transition)) {
      for (let i = 0; i < transition.length; i++) {
        i === transition.length - 1 ? await setOrAnimate(view[symbols_default.holder], transition[i]) : setOrAnimate(view[symbols_default.holder], transition[i]);
      }
    } else {
      await setOrAnimate(view[symbols_default.holder], transition);
    }
  }
  if (route.options && route.options.keepAlive === true) {
    cacheMap.set(route, { view, focus: previousFocus });
  } else {
    view.destroy();
    view = null;
  }
};
var setOrAnimate = (node, transition, shouldAnimate = true) => {
  return new Promise((resolve) => {
    if (shouldAnimate) {
      const existingEndCallback = transition.end;
      transition.end = existingEndCallback ? (...args) => {
        existingEndCallback(...args);
        resolve();
      } : resolve;
      node.set(transition.prop, { transition });
    } else {
      node.set(transition.prop, transition.value);
      resolve();
    }
  });
};
var to = (location, data = {}, options = {}) => {
  navigationData = data;
  overrideOptions = options;
  window.location.hash = `#${location}`;
};
var back = () => {
  const route = history.pop();
  if (route) {
    navigatingBack = true;
    let targetRoutePath = route.path;
    if (targetRoutePath.indexOf(":") > -1) {
      Object.keys(route.params).forEach((item) => {
        targetRoutePath = targetRoutePath.replace(`:${item}`, route.params[item]);
      });
    }
    to(targetRoutePath);
    return true;
  } else {
    return false;
  }
};
var router_default = {
  navigate,
  to,
  back
};

// node_modules/@lightningjs/blits/src/focus.js
var focusedComponent = null;
var focusChain = [];
var setFocusTimeout;
var keyUpCallbacks = /* @__PURE__ */ new Map();
var focus_default = {
  _hold: false,
  set hold(v) {
    this._hold = v;
  },
  get hold() {
    return this._hold;
  },
  get() {
    return focusedComponent;
  },
  set(component, event) {
    if (component === focusedComponent) return;
    clearTimeout(setFocusTimeout);
    focusedComponent && focusedComponent !== component.parent && focusedComponent.unfocus();
    focusChain.reverse().forEach((cmp) => cmp.unfocus());
    if (component !== focusedComponent) {
      setFocusTimeout = setTimeout(
        () => {
          focusedComponent = component;
          focusedComponent.lifecycle.state = "focus";
          if (event instanceof KeyboardEvent) {
            document.dispatchEvent(new KeyboardEvent("keydown", event));
          } else {
            focusChain = [];
          }
        },
        this.hold ? settings_default.get("holdTimeout", DEFAULT_HOLD_TIMEOUT_MS) : 0
      );
    }
  },
  input(key, event) {
    if (navigating === true) return;
    focusChain = walkChain([focusedComponent], key);
    const componentWithInputEvent = focusChain.shift();
    if (componentWithInputEvent) {
      let cb;
      if (componentWithInputEvent[symbols_default.inputEvents][key]) {
        cb = componentWithInputEvent[symbols_default.inputEvents][key].call(componentWithInputEvent, event);
      } else if (componentWithInputEvent[symbols_default.inputEvents].any) {
        cb = componentWithInputEvent[symbols_default.inputEvents].any.call(componentWithInputEvent, event);
      }
      if (cb !== void 0) {
        keyUpCallbacks.set(event.code, cb);
      }
    }
  }
};
var walkChain = (components, key) => {
  if (components[0][symbols_default.inputEvents] && (typeof components[0][symbols_default.inputEvents][key] === "function" || typeof components[0][symbols_default.inputEvents].any === "function")) {
    return components;
  } else if (components[0].parent) {
    components.unshift(components[0].parent);
    return walkChain(components, key);
  } else return [];
};

// node_modules/@lightningjs/blits/src/lib/eventListeners.js
var eventsMap = /* @__PURE__ */ new Map();
var callbackCache = /* @__PURE__ */ new Map();
var eventListeners_default = {
  registerListener(component, event, cb, priority = 0) {
    let componentsMap = eventsMap.get(event);
    if (componentsMap === void 0) {
      componentsMap = /* @__PURE__ */ new Map();
      eventsMap.set(event, componentsMap);
    }
    let components = componentsMap.get(component);
    if (components === void 0) {
      components = /* @__PURE__ */ new Set();
      componentsMap.set(component, components);
    }
    components.add({ cb, priority });
    callbackCache.delete(event);
  },
  executeListeners(event, params) {
    const componentsMap = eventsMap.get(event);
    if (componentsMap === void 0 || componentsMap.size === 0) {
      return true;
    }
    if (callbackCache.has(event) === false) {
      const allCallbacks = [];
      for (const [component, components] of componentsMap) {
        for (const callbackObj of components) {
          allCallbacks.push({ ...callbackObj, component });
        }
      }
      allCallbacks.sort((a, b) => b.priority - a.priority);
      callbackCache.set(event, allCallbacks);
    }
    const callbacks = callbackCache.get(event);
    for (let i = 0; i < callbacks.length; i++) {
      const { cb, component } = callbacks[i];
      const result = cb.call(component, params);
      if (result === false) {
        return false;
      }
    }
    return true;
  },
  removeListeners(component) {
    for (const [event, componentsMap] of eventsMap) {
      if (componentsMap.has(component)) {
        componentsMap.delete(component);
        callbackCache.delete(event);
        if (componentsMap.size === 0) {
          eventsMap.delete(event);
        }
      }
    }
  }
};

// node_modules/@lightningjs/blits/src/component/base/methods.js
var methods_default = {
  focus: {
    value: function(e) {
      Log.warn("this.focus is deprecated, use this.$focus instead");
      return this.$focus(e);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $focus: {
    value: function(e) {
      this[symbols_default.state].hasFocus = true;
      focus_default.set(this, e);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  unfocus: {
    value: function() {
      this[symbols_default.state].hasFocus = false;
      this.lifecycle.state = "unfocus";
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  destroy: {
    value: function() {
      this.lifecycle.state = "destroy";
      this.$clearTimeouts();
      this.$clearIntervals();
      eventListeners_default.removeListeners(this);
      deleteChildren(this[symbols_default.children]);
      removeGlobalEffects(this[symbols_default.effects]);
      Log.debug(`Destroyed component ${this.componentId}`);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  select: {
    value: function(ref) {
      Log.warn("this.select is deprecated, use this.$select instead");
      return this.$select(ref);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $select: {
    value: function(ref) {
      let selected = null;
      this[symbols_default.children].forEach((child) => {
        if (Array.isArray(child)) {
          child.forEach((c) => {
            if (c["ref"] === ref) selected = c;
          });
        } else if (Object.getPrototypeOf(child) === Object.prototype) {
          Object.keys(child).forEach((k) => {
            if (child[k]["ref"] === ref) selected = child[k];
          });
        } else {
          if (child["ref"] === ref) selected = child;
        }
      });
      return selected;
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  trigger: {
    value: function(key) {
      Log.warn("this.trigger is deprecated, use this.$trigger instead");
      return this.$trigger(key);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $trigger: {
    value: function(key) {
      let target = this[symbols_default.originalState];
      if (key.indexOf(".") > -1) {
        const keys = key.split(".");
        key = keys.pop(keys);
        for (let i = 0; i < keys.length; i++) {
          target = target[keys[i]];
        }
      }
      trigger(target, key, true);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  shader: {
    value: function(type, args) {
      return {
        type,
        props: args
      };
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};
var deleteChildren = function(children) {
  for (let i = 0; i < children.length; i++) {
    if (!children[i]) return;
    if (children[i].destroy && typeof children[i].destroy === "function") {
      children[i].destroy();
    } else if (Object.getPrototypeOf(children[i]) === Object.prototype) {
      deleteChildren(Object.values(children[i]));
    }
    children[i] = null;
  }
  children.length = 0;
};

// node_modules/@lightningjs/blits/src/component/base/timeouts_intervals.js
var timeouts_intervals_default = {
  $setTimeout: {
    value: function(fn, ms, ...params) {
      const timeoutId = setTimeout(
        () => {
          this[symbols_default.timeouts] = this[symbols_default.timeouts].filter((id) => id !== timeoutId);
          fn.apply(null, params);
        },
        ms,
        params
      );
      this[symbols_default.timeouts].push(timeoutId);
      return timeoutId;
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $clearTimeout: {
    value: function(timeoutId) {
      if (this[symbols_default.timeouts].indexOf(timeoutId) > -1) {
        this[symbols_default.timeouts] = this[symbols_default.timeouts].filter((id) => id !== timeoutId);
        clearTimeout(timeoutId);
      }
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $clearTimeouts: {
    value: function() {
      for (let i = 0; i < this[symbols_default.timeouts].length; i++) {
        clearTimeout(this[symbols_default.timeouts][i]);
      }
      this[symbols_default.timeouts] = [];
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $setInterval: {
    value: function(fn, ms, ...params) {
      const intervalId = setInterval(() => fn.apply(null, params), ms, params);
      this[symbols_default.intervals].push(intervalId);
      return intervalId;
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $clearInterval: {
    value: function(intervalId) {
      if (this[symbols_default.intervals].indexOf(intervalId) > -1) {
        this[symbols_default.intervals] = this[symbols_default.intervals].filter((id) => id !== intervalId);
        clearInterval(intervalId);
      }
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $clearIntervals: {
    value: function() {
      for (let i = 0; i < this[symbols_default.intervals].length; i++) {
        clearInterval(this[symbols_default.intervals][i]);
      }
      this[symbols_default.intervals] = [];
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/events.js
var events_default = {
  $emit: {
    value: function(event, params) {
      return eventListeners_default.executeListeners(event, params);
    },
    writable: false,
    enumerable: true,
    configurable: false
  },
  $listen: {
    value: function(event, callback, priority = 0) {
      eventListeners_default.registerListener(this, event, callback, priority);
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/router.js
var router_default2 = {
  $router: {
    value: {
      to,
      back,
      get currentRoute() {
        return currentRoute;
      },
      get routes() {
        return this[symbols_default.routes];
      },
      get navigating() {
        return navigating;
      }
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/announcer.js
var announcer_default2 = {
  $announcer: {
    value: announcer_default,
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/utils.js
var utils_default = {
  [symbols_default.renderer]: {
    value: () => renderer2,
    writable: false,
    enumerable: true,
    configurable: false
  },
  [symbols_default.getChildren]: {
    value() {
      const parent = this.rootParent || this.parent;
      return (this[symbols_default.children] || []).concat(
        parent && parent[symbols_default.getChildren]().map((child) => {
          if (Object.getPrototypeOf(child) === Object.prototype) {
            return Object.values(child).map((c) => {
              c.forComponent = c.config && c.config.parent.component;
              return c;
            });
          }
          return child;
        }).flat().filter((child) => {
          if (child && child.component) {
            return child.component && child.component.componentId === this.componentId || child.forComponent && child.forComponent.componentId === this.componentId;
          }
        }) || []
      );
    },
    writable: false,
    enumerable: true,
    configurable: false
  }
};

// node_modules/@lightningjs/blits/src/component/base/index.js
var base_default = Object.defineProperties(
  {
    [symbols_default["launched"]]: false
  },
  { ...methods_default, ...timeouts_intervals_default, ...events_default, ...router_default2, ...announcer_default2, ...utils_default }
);

// node_modules/@lightningjs/blits/src/component/setup/props.js
var baseProp = {
  cast: (v) => v,
  required: false
};
var props_default = (component, props = []) => {
  if (props.indexOf("ref") === -1) {
    props.push("ref");
  }
  component[symbols_default.propKeys] = [];
  const propsLength = props.length;
  for (let i = 0; i < propsLength; i++) {
    const prop = { ...baseProp, ...typeof props[i] === "object" ? props[i] : { key: props[i] } };
    component[symbols_default.propKeys].push(prop.key);
    Object.defineProperty(component, prop.key, {
      get() {
        const value = prop.cast(
          this[symbols_default.props] !== void 0 && prop.key in this[symbols_default.props] ? this[symbols_default.props][prop.key] : "default" in prop ? prop.default : void 0
        );
        if (prop.required === true && value === void 0) {
          Log.warn(`${prop.key} is required`);
        }
        return value;
      },
      set(v) {
        Log.warn(`Warning! Avoid mutating props directly (${prop.key})`);
        this[symbols_default.props][prop.key] = v;
      }
    });
  }
};

// node_modules/@lightningjs/blits/src/component/setup/methods.js
var methods_default2 = (component, methods) => {
  component[symbols_default.methodKeys] = [];
  for (let method in methods) {
    if (component[symbols_default.propKeys] && component[symbols_default.propKeys].indexOf(method) > -1) {
      Log.error(`${method} already exists as a prop`);
    } else {
      if (typeof methods[method] !== "function") {
        Log.warn(`${method} is not a function`);
      }
      component[symbols_default.methodKeys].push(method);
      component[method] = methods[method];
    }
  }
};

// node_modules/@lightningjs/blits/src/component/setup/state.js
var state_default = (component, state = () => {
}) => {
  Object.defineProperty(component, symbols_default.stateKeys, {
    value: [],
    enumerable: false,
    configurable: false,
    writable: false
  });
  const stateKeys = Object.keys(state.apply(component) || {});
  stateKeys.push(["hasFocus"]);
  const stateKeysLength = stateKeys.length;
  for (let i = 0; i < stateKeysLength; i++) {
    const key = stateKeys[i];
    if (component[symbols_default.propKeys] !== void 0 && component[symbols_default.propKeys].indexOf(key) > -1) {
      Log.error(`State ${key} already exists as a prop`);
    }
    if (component[symbols_default.methodKeys] !== void 0 && component[symbols_default.methodKeys].indexOf(key) > -1) {
      Log.error(`State ${key} already exists as a method`);
    }
    component[symbols_default.stateKeys].push(key);
    Object.defineProperty(component, key, {
      get() {
        return this[symbols_default.state][key];
      },
      set(v) {
        this[symbols_default.state][key] = v;
      }
    });
  }
};

// node_modules/@lightningjs/blits/src/component/setup/computed.js
var computed_default = (component, computeds) => {
  component[symbols_default.computedKeys] = [];
  for (let computed in computeds) {
    if (component[symbols_default.stateKeys] && component[symbols_default.stateKeys].indexOf(computed) > -1) {
      Log.error(`${computed} already exists as a state variable`);
    } else if (component[symbols_default.propKeys] && component[symbols_default.propKeys].indexOf(computed) > -1) {
      Log.error(`${computed} already exists as a prop`);
    } else if (component[symbols_default.methodKeys] && component[symbols_default.methodKeys].indexOf(computed) > -1) {
      Log.error(`${computed} already exists as a method`);
    } else {
      if (typeof computeds[computed] !== "function") {
        Log.warn(`${computed} is not a function`);
      }
      component[symbols_default.computedKeys].push(computed);
      Object.defineProperty(component, computed, {
        get() {
          return computeds[computed].apply(this);
        }
      });
    }
  }
};

// node_modules/@lightningjs/blits/src/component/setup/input.js
var input_default = (component, input) => {
  component[symbols_default.inputEvents] = [];
  Object.keys(input).forEach((key) => {
    if (typeof input[key] !== "function") {
      Log.warn(`${input[key]} is not a function`);
    }
    component[symbols_default.inputEvents][key] = input[key];
  });
};

// node_modules/@lightningjs/blits/src/component/setup/routes.js
var routes_default = (component, routes) => {
  component[symbols_default.routes] = [];
  Object.keys(routes).forEach((key) => {
    component[symbols_default.routes][key] = {
      ...routes[key],
      ...{
        // merge default route options with route specific options
        options: {
          ...{
            inHistory: true
          },
          ...routes[key].options
        }
      }
    };
  });
};

// node_modules/@lightningjs/blits/src/component/setup/watch.js
var watch_default = (component, watchers) => {
  component[symbols_default.watchKeys] = [];
  component[symbols_default.watchers] = {};
  for (let watch in watchers) {
    if (typeof watchers[watch] !== "function") {
      console.warn(`${watch} is not a function`);
    }
    component[symbols_default.watchKeys].push(watch);
    component[symbols_default.watchers][watch] = function(v, old) {
      watchers[watch].call(this, v, old);
    };
  }
};

// node_modules/@lightningjs/blits/src/component/setup/index.js
var counter3 = 0;
function setup_default(component, config) {
  component[symbols_default.identifier] = ++counter3;
  component[symbols_default.effects] = [];
  registerHooks(config.hooks, component[symbols_default.identifier]);
  props_default(component, config.props);
  if (config.methods) methods_default2(component, config.methods);
  state_default(component, config.state);
  if (config.computed) computed_default(component, config.computed);
  if (config.watch) watch_default(component, config.watch);
  if (config.routes) routes_default(component, config.routes);
  if (config.input) input_default(component, config.input);
  return component;
}

// node_modules/@lightningjs/blits/src/components/Circle.js
var Circle_default = () => component_default("Circle", {
  /* eslint-disable no-unused-vars */
  code: {
    render: function anonymous(parent, component, context, components, effect2, getRaw2) {
      const elms = [];
      let componentType;
      const rootComponent = component;
      let propData;
      const elementConfig0 = {};
      elms[0] = this.element({ parent: parent || "root" }, component);
      elementConfig0["color"] = component.color;
      elementConfig0["w"] = component.size;
      elementConfig0["h"] = component.size;
      elementConfig0["effects"] = [component.shader("radius", { radius: component.radius })];
      elms[0].populate(elementConfig0);
      return elms;
    },
    effects: [
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("color", component.color);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("w", component.size);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("h", component.size);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("effects", [component.shader("radius", { radius: component.radius })]);
      }
    ],
    context: {}
  },
  props: [{ key: "size", default: 40 }, "color"],
  computed: {
    radius() {
      return this.size / 2;
    }
  }
});

// node_modules/@lightningjs/blits/src/components/RouterView.js
var handler;
var RouterView_default = () => component_default("RouterView", {
  /* eslint-disable no-unused-vars */
  code: {
    render: function anonymous(parent, component, context, components, effect2, getRaw2) {
      const elms = [];
      let componentType;
      const rootComponent = component;
      let propData;
      const elementConfig0 = {};
      elms[0] = this.element({ parent: parent || "root" }, component);
      elementConfig0["w"] = parent.node.width * (100 / 100);
      elementConfig0["height"] = parent.node.height * (100 / 100);
      elms[0].populate(elementConfig0);
      return elms;
    },
    effects: [],
    context: {}
  },
  state() {
    return {
      activeView: null
    };
  },
  hooks: {
    ready() {
      handler = () => router_default.navigate.apply(this);
      router_default.navigate.apply(this);
      window.addEventListener("hashchange", handler);
    },
    destroy() {
      window.removeEventListener("hashchange", handler, false);
    },
    focus() {
      this.activeView && this.activeView.$focus();
    }
  },
  input: {
    back(e) {
      const navigating2 = router_default.back();
      if (navigating2 === false) {
        this.parent.$focus(e);
      }
    }
  }
});

// node_modules/@lightningjs/blits/src/components/Sprite.js
var Sprite_default = () => component_default("Sprite", {
  /* eslint-disable no-unused-vars */
  code: {
    render: function anonymous(parent, component, context, components, effect2, getRaw2) {
      const elms = [];
      let componentType;
      const rootComponent = component;
      let propData;
      const elementConfig0 = {};
      elms[0] = this.element({ parent: parent || "root" }, component);
      elementConfig0["w"] = parent.node.width * (100 / 100);
      elementConfig0["h"] = parent.node.height * (100 / 100);
      elementConfig0["texture"] = component.texture;
      elementConfig0["color"] = component.color;
      elms[0].populate(elementConfig0);
      return elms;
    },
    effects: [
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("texture", component.texture);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[0].set("color", component.color);
      }
    ],
    context: {}
  },
  props: ["image", "map", "frame", "color"],
  state() {
    return {
      spriteTexture: false
    };
  },
  computed: {
    texture() {
      const options = "frames" in this.map ? Object.assign({}, this.map.defaults || {}, this.map.frames[this.frame]) : this.map[this.frame];
      if (this.spriteTexture && options) {
        return this[symbols_default.renderer]().createTexture("SubTexture", {
          texture: this.spriteTexture,
          x: options.x,
          y: options.y,
          width: options.w,
          height: options.h
        });
      }
    }
  },
  hooks: {
    ready() {
      this.spriteTexture = this[symbols_default.renderer]().createTexture("ImageTexture", {
        src: this.image
      });
    }
  }
});

// node_modules/@lightningjs/blits/public/assets/fps_sprite.base64.js
var fps_sprite_base64_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAaMAAAAbCAYAAADRe+BYAAAAAXNSR0IArs4c6QAAGn9JREFUeF7tXQ1UVdWePxcWFg7ZA0sym5n0Tmk1z4+0YeVU4yo1h1jvPVBo1ETU8QvTdJlhsmKpi0he5jyXX0CKIWkpl3OlME3RGcdJixVEas+nJtq0sMwXN/kIgbxn1m+791n/ezifF0hr7lmrVV3O2Wfv/977//v//h/7uKTQFZJASAIhCYQkEJLADZaAy+j9iqIMkCRpliRJGeSeWkmSClwuV25X9VtRlOGSJI3m7wq6bd5Osqa/6OZSSZJKXC4X+h7UpSgKZABZQCbiKuHt4t+dvri8z5GG3E77rChKtCRJ9TY647ht0aaiKJAx5LCK/4Y5m23jneotiqJgvg84eCaYd6Cf4h/xqgo+ZwUO3h1wK5cx1oIYP/5eJUlSrsvl6tRakGUZbYr9tjQpKanL9lmw4w09F5LAzyUBXTDiih3KAspN76pwuVxjgu2koijYzGibbmg0tzQYoOPt5Zv0xydJ0hiXywWlYfviAAE5UBDSPu9YUep1QFEUvAdKWlyOAYPP26c2BhhM25ivXZo+4lWOxx8EGEHRw6iwdXHjQbu26LMwTlJsNUZusrEeHMuC9kGWZRgSYs/VJiUluZ32MXR/SAK/VAkYgREsdKaAKysr58fFxd0Di23Xrl1ScjKMTUl69913906cODHe6cDNFAVvcyAUHCxNO21rGIVv7969ufHx8djQGatWrZIyMq4bmj6frz4mJuYRSZJsMyQNQJS43e4/19bWThk+fPiA/Px8afhwkDpJKikpKUhJSXHEDujY9MDU7XZLtbWsq1BItvrMWQsAQxozZoxUUQEiYHrZapuzAYCcAOWSnJycv2RmZjZThiRJklMZGDIkyHfWLNgskkRkgXVh+g4N0NUuWLCgYN26dcMHDBiQjPUr5qyoqOjttLS0KVYC0syTui/q6+tX9O7duyU6OnoV2h09+rodEexakGUZG4vNnbiWL18uHT9+HCBsay84Gcv/13s9Hs/osLAwlZW7XK6KxMRES8Pa6/Ue4GuLic7v94+ZMGGC5Qb7OeXcXWMrLS3Nd7lcs+zKKtgxdwAjupnPnDlTNHDgwN9RhlRfXy9FR0dDuUsxMTGYDMuJ1GxooAO0eNWgQYNaX3jhhcfnzp2bhHuWLl0q5eayfWd7AyqKoro2uIJ5jr7vwIEDqqKIi4trqKysfJK7VUxlRl1ebW1tX99yyy3tlCFB+aBtroCklJQUS0Wp90L+Hii5ABYaJBhBtowRjBgxQqqqsiSCdsEISpJZIZcuXVp01113PaPHkKyAQmf8umCE9XXu3Dm2zgCoAFZ+YXGYMiS6HjZt2iSnp6eztYVLZ87gVrPFkCjQX758+d0+ffr8k1gP6Oenn34qDRgwgBkQbrfb8VqQZVnIGCyerYX9+/dLeXl5MERuSoYky7JiU/GoLE+r1A2eh4cEIKG7gD0ez4CwsDCsxwD2qygKmGlFUlKSobtUq7A5sLgnTJhgaPDx91EX+i8CjLpqbHSeXS7XCKN5sbkWDG/TAyNVuSckJHyzZ8+evvxpbNoSRVHgDmMmK1d4toFD0wumOGH9wgruBBip7q2YmBgGkiBCXDGiv6qCnj17tlRQUGBrc5PYgJSZmTk1JyfnAd5/LPTZBESowoTV7igeoSiKUEK1ly5dCo+Njf17vKezYERkAU0etAVHjZPm5uaiqKioxylD4uMNun0DgFbnbNq0aXveeustgB8TixVLpOuTsEPMeYqiKFgXTKkQkLM1ZxTkNPuCrf8rV678qVevXi+QfWGrXdxfXl4e3dbWxmJ933zzzbHz588/OnLkSKmpqUlKT0/Hv9U51CjGDq482hZk1aNHjxEJCQlsU3D2JYxB/MRiXTQG6Pf7TRUzna9uBCPxmg5xM1mW1bVhovxKkpKSdI0MPTAqLi6WvF6voWGt907OWtGFTu2vzipw+nx3jU0wo6+++qpu0aJF/bg+cURC7IxTD4xUK5goRNUipco9JSUFbgks9Bg7L9MBo+EbN24M7wwzIm3S4K+qCKgSIcpphB12xNumSQEqkFElDTYHVgewtmtp42ZqbX/99dfTzp07VzBq1KiIToCRaii4XOrUOhlrh2mk8nv66acr9u/fL+JatpWtk7VBmaLf778QHh5+O2cKtli4jvGB17O+0jkrKCiQYJzYnTMKcnpuQ+pqdWL0cJBQFeybb7557Nq1a4/OmTOHiS0vLw8MKYBpERYlaS1VjbsvNykpiS1MCyWOdc1csMGCUVKSSkDNprvW6/XWCncXUejqM2PHjpXE2PFjdXX10uzsbOYu0Shb39mzZ7MyMjL+BkYt5mTKlCnS4MGDWVunTp0qy8zM/IO2M3oKGyx8yZIlbNvpGTuyLMNFfd0nz69fChh18dgoE+6UXtFbJHpgpDINsulU9DfY7EF3jG7iYNx0ZFA0AQDg6KOK7erVqy2RkZGR/H4nihRgdD14cZ1xCaUGxT/A7/dfue+++27n8R1bCpMDEdoVcRgE1OH2SxaxhyCZEZMBxrpt27ZIEXPhfQdQMjeGQ3BgG7G9vb0pPj4+Cm2KuCFvJ6ikE6M+0PWgcbPZskDpnGNOYDBVVVWNURQFCheGFlMqRL625syAcdF9gTXCKD5Zx7b2hVB2iqL8MHXq1N+gjW3btjERcWWCdQdFyRiO1+udxfsjcateBSuakQcFi+fvvffeD9asWSPiu779+/e/lZeX9wRkAcUPABDX3Llz4Yo1VMx03igz6iowQvsUkI4fPy4tX76csU8Kwh6PZ/uOHTsm0/5ERUVJGzdulPBvXDNmzCjz+XwBgETBCOOMjY1l93JZdfDyeL3e4YqisKSgpqam+qioKGZ43+xg1E1jE8aurT3jRM/gXrtgpFoMBmDEXHhOX86Vst4mDtb1F9AFatVv3br18PTp0/+F32BLsdHGqDIiv1ekpqZuKy4uvq45rrs8bGV9kb75EhMTs3bv3r2OxreCBCM1wG4yFylOUpAVRWHWUEtLy9XIyMhbDdqtgoUezPxrn1EUhY0BivmOO+6Q6uvroZxtuVZFW8gqrKurK+vXrx9cCtqrdv369fnz588XSQG24jt03RNWRfeFyswJGFkaPVTZnT9//sTixYt/iw5v2LDhWN++fR8lilJti7riuLJWvRMiI6+xsVEFtldffbXsgQce+D3a2rdvn1xQUBBAY15//XUGzri6AIwMy0XQPo0ZGSl0Oj64KlNTU/FoCgdaxuBIP1WXPH7Pz88vvfPOO9n4Vq9eLR09ejRgT1Iw8nq9UmJiIhs3/ru4uBhuy4B1TMF93759344bN+4u3K/Xd85KA8oJYPwhlkXjWBp21sHVKsuyuo9RNpGYmGjL9d9dY6P9SUpKYvNL3cUYn6IoyHjNQKID2XCOyhO6CowsN52RoupCZhTwCtruTz/9VBMREYFYDNhIUG5FPTACW5gxY0ZzcXExzCu0i4VsmflG3UU8KwtZXQOqq6svDRs2jJlqQYIR3D0Zp0+fDp88eXKvqqoq9KkkIyNjFjILcTU3N7c9+eSTz1ZWVu62Ag9t7RMSItLT05EEMn7o0KGLNm/eHC+y04LNrqR9oG7L3bt3y4mJiUJpOlpfkK/f738zLCzsXu0YwWRnzpz5fWFhocgMtIxDoQ1togkHHGbUUKMH9zph+FTZbdiwofbgwYPol2/Lli0ro6Oj/8NIUVKWAGXd1NQ0AgpVWPFQnAUFBVCcPlmWsSYZI+T34j9VJU4B4mYAI3ROh3VV8PExNzF3XzKQ0jGEsc9pUhDzlHAlqmbTgVUOGTKEufbAJDB2vofVxAkB7j/88EPF+++/PxquQD0wEnEVkz0VoJg196t/o6wX4zKKfem9h4JRV47NCox4yAPrtkMpEIBq/PjxtrJsf5VgpEnv9Y0cOXLXsWPHhEA6y7ryR48ezZS7UMRz5sw5kZ+fD3eAJRBxxSYsHzAKUF6AiK+xsfHPUVFR/xwsGJEF2oEh0VRpriwt2SwFI7i8kLDiu54hwhYdssfgBsLFs8g6WJZWgKcBI9XVOnDgwK/PnDnzt1yJqC4qq/ZorVVTU9Op+Ph46ciRIw+gr5CBcIOmpqZeKi4uRualbbclBUudfqhxFx4zYrhklZYtlJ3f729IS0vrBSYAJVReXj5bJDUQdqC6/ajS4gxgqSzLeJZZHcJFB9esLMvMWqVsScTRONipacs3AxhRpUpiHj6v17tUuCcJIBkZE2r8lAKWVmE3NzerMSrOdlQmRe997733Prxy5crTemDk9XrB5JmLFvt50aJF2y9cuBDvdruTX3zxRdUVuGrVqvmVlZXrcR/YX0tLy/+Gh4dHYX7nzZt34Z133nm4ra1NgKjv+eefb7p48SL2AC5Lg6w7xob9oQEj1hmPx+MOCwtTMwyPHj0qFRYWFtXX168cMWLE6wsWLEgS7tL09PQV33777XKrvfurAyNt4eeMGTNyCgsLl3FBdEpZ8jbYIqeK+LPPPrv28MMPT7TjqqTunldeeSU9Ozt7I28XGw1WH7P8gmFGZLIZQ+LgiEVcpRO8D4hD6C0UCkaaFGvIkbXb0tJy4tZbb/1HPM8z+CwVsMG71DTv48ePVwwZMkQkSjhqj9aGpaamphYXF2MTMBZEU8YvXLjg79+//7/ZmTPa39OnT//hiy++2JmYmNgDv6N+LTo6+mVaxE3S6k37TpMNvvzyy7+89NJLg/i7mKFA2Y/W5URdWTwFvMrr9SJOOhqxjdTUVJFUBPcWq186ffp0w8svv9yLv0NlC13BjEwUTYAbyspNx2WCPcYMHsKAmK7XnFIhtbe3/xgREbHS7/eXmKVni/5pXVlgW1u2bGmJiIiI1KbSE/biS01NdT333HO/EfE16qaTZRl9ZWtsyZIlQ8+dO4d1xS64AQWA8bGoa4IaFHh3ZGTk3scff/xf8dwnn3wi5+bmCs+ArcSo7hibHTAirBJ6gTEkjFm4QPnatXSH282m040Z8Ww6W6httFi70k2nPTli/fr1GSQ2YNuNZoXg4u/Nzc0Xe/bsyVLfefaaKdtwcFyP2oUDBw6kjh07tthun0zkjEXCLJmSkhIW2Ley3Gl/CRiBAcBCZ24PnSwzR/Ed0V/aTkpKSnVJScnD/G+23GikHRbjunr1al1kZKSIGang2djY+D8a9mnJEHVk2qFAVRSEX7lyBSAXxksMTK1ZCjZW8wvLc/Xq1QEuZvG8SAEXSQ8ffPDBic2bNyP2xO4XLi+iNALm6EaBkdWYz58/v3Px4sXP8vtUQ3LatGn5Dz744CwR5yLtwNNQYBZjoQqbg4/0xhtvnOjfv/9vCQNl7lfBWuvq6vbMnz//GZrsYRDvUuPfnHGneL3eZE2yCbqrrumdO3f+V0REhIhls6EoinJh/PjxIovUtt7qrrFZMSMetxTTwEpfOBtnLJ0YFKoBpDf3pnVGBGwoGKmp38QCtKSQ3Q1G3IpH1guzqD766KOcxx57TDAi/GQrs4koNXFmHn4S7rSAYYhgOwEjU+alc/6c1X5Ehp0tMOLMR6Sf4rimgIJBg7RmS2uFxyCG8yJn9Dcgk4YyEVLbZLrotIOmcvnuu++qY2NjBRBZ9k+nLQZGFy9ebOnXr5/InqTrV5stGhR4kvMUkylLPnLkSOUTTzyBgljTNaepB7JcB7iBx3tU8KTMCjECYYFnZGQ0nD17FgyIyY+mJvM2AuawK8DIRjYdk7PNotdcj8fTtmPHjudJHEKrY5DOnYF4Dyxw4RLie7EiIiIiRdRXUeHqKewJEyaUTZo0iSV4CCtelmXIiDHKDRs27Dl48OAz8+bNa33qqaduwW96YJSVlfV2bGxsXN++ff9Bb0J55iP+pI6FJrCIZwoLCzeXl5f/O/9/256B7hqbAzBS9xItJbCI76miMj2BwSBriJ2fxY/XUV0BTt0dROl3OptOe2bY559/vm7o0KGIB4iAWjDZc1Ds4py3DmfxUQV64sSJ1sGDB7NFqpehqLMwdQ80NcimE4+bjkETz+hwRhplHiTAbkn/deq0VEWmiSn91e1238E765TNqP7911577ciyZctQWIsrmHlTa0K4q5PWhqmB7aampvbbbruN1XTZKaY1QwsKyMOGDfugpqYGadSmblC6WQmT6fAa6u7gykydMw5oLMYAqx4KuaGhoTYtLU0kZwgLX83044ohAIApWHVBzMhIVB3ASK/OyOBhoyxVcTDycIASAFHUGV2+fPnU7NmzH9S2p6eweVwNbUULBsrBCL/5ONBG5+Tk1A4aNIjJloJReXl5VVtbG4ycgFok7bsJGAUADJU/Ya943JGh1B1js+OmI8xI1Q0GYGRKWozOplM3NGdH4vQFlRWtXbv2xMKFC1kaqlPWQSeps2467blptbW1f3S73TNNLCozvRLwN8p8uMWbybOnsOigQNniW7hw4V/Xrl0rFLFpait/geoyoy/sDBihHdpfnt32Co8XqUWVyACMjY2N4m4kS+ZBs8jwzMSJE5s+/PDD2zgQqXU7mZmZp8gpFbaZEW2fH7skArZB1TLQmByy/yZNmoREiL/j71EPevV4PHXJycnCjecIPMWcaU9z52vvJf53U9lSBUSSDTqsTQAqUq9xkWC+Kl+tq+/QoUOH169fD7eP6tKjabgALQDS0aNHWRvaLDAKRvw5duaV3llsBnVGwaR2G+1JgBDWgVWSifBiZGzatCla1A5lZWVVnjx5cpxwKeMlVGETJYokD8iLHWQJGWzatIn1iRfPMta0devW6ttvv52xdgpGpaWlySKlGQkMa9asOYWkGbBnWjOlB0Z6ZxISJuHIGOuOsd0MYIQiR/gyr1ePdbzAFLAAYGk6Qm9tU10ARnaOB1Ff6yJHE1ihEmJQ165dOxQeHi6Cvh0eqaury7/nnntEpl6nEiSohR1MAgP629TUtCcqKup6JV/Hy5eQkPCfe/bsEYFRWy4Aq1O2OyMDCh55eXmVc+fOFS6uzrh+aSZVBym0trYevvvuu4fwGiZHqf4mspjtcrlgSYvEC0OAo66Z77//vm7mzJkCFHXnQwe41Pu0yoy46ALYhCZl2HDpUzAqLS1V60b0UnS7EIwsla5mnIYpz+vWrSvv168fOz6KK/UAo8ZIYXu9XtTKME8IQEowrJUrV1bU1NRgTpHNJxKBAsBIlmVWAI9n09LSahoaGoYKAdsAI5H56vvxxx979ezZM1xk1zU2Nva30lH0790xthsORhggLN+cnJz/XrZsGS0cFN8zAhBdP77bRvqqmUBvZjDicohesWLFl1OmTIlBbIBcBTt27KiZPHnyDELPg1ag/F16p184strBANDfBQsWxCB7jFxLR40aFXP48GFhuVtm09GHy8rKhp09e/bo4sWLaeFrRWVlZVlcXFxaMDKgrKgzRa566ys7O/vtuLi4ySKVm99TVV9fX967d2+kzwvQsGSHtH0NGDGr3e12R+I0d3JmnynIUzZSWlpat337drHHdOOa1OUhMudEcSZ11RHmhC53UPBZWVlTwsLCtglFC5der169cIIGTnRg8jBiRgZFnurxMCRmFAwzsgQjTYzN16NHD7deTIjGpHj8B8NS5WqgsBlg0dgIHmpvbz/57LPPskxRpOhzI4LJSZNNB8Yd3dra2jpx4kThrkebSLfH/SyQr2VGdF5ramq2f/zxx5PFUUh8nh3pk+4Y200BRnwCADqm3zVyemq3CTDRTBRbFrumLUcMyWZsR7zCSg5ssdo9fcEMnPnf6NFGjsCIzBs2iNF3mNj3nRyczye6bPVRvM7IgM5fMPOvJ1ZThiQynqgbx8bcWMnCiQKhcUk7rJqekaYFLno2oxnbo/uMjYWewECKYum6o3KkRw/9bGCEflLlDeA9dOjQsb17947E3wBWra2tq4S7rKGhgdVt8clS58RCYQfokLKysi+LiopEMgKKilfpnKsHEINMmXFOAAdZjAEfYaRg5PF4SkidTu3UqVPDGhsb783Ly/P36dMnDG1xlovCbXHQrehfLXebBtQ1dsfYuhqMPB5PBf+EB3RTQCGw3fiG9rh2xpCsCvocbGzcejODEfonzqjTfvEVckBQ2cqv7UQcnQUj2l8sYEqR2Jdv7Rbo6nRa7wvAGLuQg5NxintpxbwjxmbjZVi7mDP64UIofsigM98JosAs4hqQAVMcNi+q5O0AMFWWWkZH+9PBKOBuLgT5MW7ci7ZGI74i4iN1dXUN8+fPFwqcghFtW2UxP6ebTshz+/btf4qMjGSno5tcvqysrLMnT54ULl81A9FMYWs/FUGAmRkKRjVSvL7LyGhXi6H5kUPo9lKv1ztaABs9oikhIWHz9OnTWSYdZ7oU/E2PCeqOsXU1GPFTNMSHUANq0OyAkc19FbotJIGQBG5GCXAlK8oe6NEzOARUTcQpKir6qqysjH3ChJ/EbwqsNwKM0LGHHnoo9/77739Jm9INpt/Y2Fg+depU1P6JM9ICYtpmChttC8DR1M4wQ8GsYBcyrqqqOvDII48wb0R7ezsKaVf06NGjQJykITLlZs2aJY8bN47FbTWuQFbD5/V6dwmg4myKsWDBDFHUvGTJkphLly7hfhgHjCF119gcpHZbZtNRZrRz5876nTt3IpGGyTcERjej9gj1KSSBLpQAXFjt7e2qgtNruqGh4d20tDRxcoAdlyFthn5awK5OoezfMmak02fqljSSlpk7Wsts6fd5tNmu2uxQo76bufNVhqRx6dO2qIuX9k87H/S4Lz23cHeMjZE14voX80xlpZcBS9k87Sv1hDGDwe7C6cKtEWoqJIGQBG6EBHJzc5+vr69/Iy4ujh1lxK+S6urqquzsbLgzRZ2Mk7gXmrkRYIT3QhGKWiPqirbjhjVT2GhbgISegjUDUvQJCph+dgZuU7jb2AcUSQYyVch6BgB9D3XjqrEjyozInHbX2LoSjCAnjI/FjkLM6EZohNA7QxK4cRKAwlZrrQy64Si78MYNJfTmX5sEQszo1zajofGEJGAtAfHNHVGegSeQ2CD+sW4hdEdIAl0sgRAYdbFAQ82FJBCSQEgCIQk4l0AIjJzLLPRESAIhCYQkEJJAF0vg/wBMng85iZWBHAAAAABJRU5ErkJggg==";

// node_modules/@lightningjs/blits/src/components/FPScounter.js
var FPScounter_default = () => component_default("FPScounter", {
  /* eslint-disable no-unused-vars */
  code: {
    render: function anonymous(parent, component, context, components, effect2, getRaw2) {
      const elms = [];
      let componentType;
      const rootComponent = component;
      let propData;
      const elementConfig0 = {};
      elms[0] = this.element({ parent: parent || "root" }, component);
      elms[0].populate(elementConfig0);
      parent = elms[0];
      const elementConfig1 = {};
      elms[1] = this.element({ parent: parent || "root" }, component);
      elementConfig1["y"] = 15;
      elementConfig1["x"] = 20;
      elms[1].populate(elementConfig1);
      parent = elms[1];
      const elementConfig2 = {};
      elms[2] = this.element({ parent: parent || "root" }, component);
      elms[2].populate(elementConfig2);
      const cmp3 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[2];
      const elementConfig3 = {};
      elms[3] = this.element({ parent: parent || "root" }, component);
      elementConfig3["image"] = component.image;
      elementConfig3["w"] = 43;
      elementConfig3["h"] = 25;
      elementConfig3["map"] = component.sprite;
      elementConfig3["frame"] = "fps";
      const skip3 = [];
      if (typeof cmp3 !== "undefined") {
        for (let key in cmp3.config.props) {
          delete elementConfig3[cmp3.config.props[key]];
          skip3.push(cmp3.config.props[key]);
        }
      }
      elms[3].populate(elementConfig3);
      parent = elms[3];
      const props4 = {};
      props4["image"] = component.image;
      props4["w"] = 43;
      props4["h"] = 25;
      props4["map"] = component.sprite;
      props4["frame"] = "fps";
      componentType = props4["is"] || "Sprite";
      let component4;
      if (typeof componentType === "string") {
        component4 = context.components && context.components[componentType] || components[componentType];
        if (!component4) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component4 = componentType;
      }
      elms[4] = component4.call(null, { props: props4 }, elms[3], component);
      if (elms[4][Symbol.for("slots")][0]) {
        parent = elms[4][Symbol.for("slots")][0];
        component = elms[4];
      } else {
        parent = elms[4][Symbol.for("children")][0];
      }
      parent = elms[2];
      const elementConfig5 = {};
      elms[5] = this.element({ parent: parent || "root" }, component);
      elementConfig5["x"] = 58;
      elementConfig5["y"] = 2;
      elms[5].populate(elementConfig5);
      const cmp6 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[5];
      const elementConfig6 = {};
      elms[6] = this.element({ parent: parent || "root" }, component);
      elementConfig6["image"] = component.image;
      elementConfig6["x"] = 0;
      elementConfig6["h"] = 20;
      elementConfig6["w"] = 20;
      elementConfig6["map"] = component.sprite;
      elementConfig6["frame"] = component.fps[0];
      const skip62 = [];
      if (typeof cmp6 !== "undefined") {
        for (let key in cmp6.config.props) {
          delete elementConfig6[cmp6.config.props[key]];
          skip62.push(cmp6.config.props[key]);
        }
      }
      elms[6].populate(elementConfig6);
      parent = elms[6];
      const props7 = {};
      props7["image"] = component.image;
      props7["x"] = 0;
      props7["h"] = 20;
      props7["w"] = 20;
      props7["map"] = component.sprite;
      propData = component.fps[0];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props7["frame"] = propData;
      componentType = props7["is"] || "Sprite";
      let component7;
      if (typeof componentType === "string") {
        component7 = context.components && context.components[componentType] || components[componentType];
        if (!component7) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component7 = componentType;
      }
      elms[7] = component7.call(null, { props: props7 }, elms[6], component);
      if (elms[7][Symbol.for("slots")][0]) {
        parent = elms[7][Symbol.for("slots")][0];
        component = elms[7];
      } else {
        parent = elms[7][Symbol.for("children")][0];
      }
      const cmp8 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[5];
      const elementConfig8 = {};
      elms[8] = this.element({ parent: parent || "root" }, component);
      elementConfig8["image"] = component.image;
      elementConfig8["x"] = 18;
      elementConfig8["h"] = 20;
      elementConfig8["w"] = 20;
      elementConfig8["map"] = component.sprite;
      elementConfig8["frame"] = component.fps[1];
      const skip82 = [];
      if (typeof cmp8 !== "undefined") {
        for (let key in cmp8.config.props) {
          delete elementConfig8[cmp8.config.props[key]];
          skip82.push(cmp8.config.props[key]);
        }
      }
      elms[8].populate(elementConfig8);
      parent = elms[8];
      const props9 = {};
      props9["image"] = component.image;
      props9["x"] = 18;
      props9["h"] = 20;
      props9["w"] = 20;
      props9["map"] = component.sprite;
      propData = component.fps[1];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props9["frame"] = propData;
      componentType = props9["is"] || "Sprite";
      let component9;
      if (typeof componentType === "string") {
        component9 = context.components && context.components[componentType] || components[componentType];
        if (!component9) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component9 = componentType;
      }
      elms[9] = component9.call(null, { props: props9 }, elms[8], component);
      if (elms[9][Symbol.for("slots")][0]) {
        parent = elms[9][Symbol.for("slots")][0];
        component = elms[9];
      } else {
        parent = elms[9][Symbol.for("children")][0];
      }
      const cmp10 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[5];
      const elementConfig10 = {};
      elms[10] = this.element({ parent: parent || "root" }, component);
      elementConfig10["image"] = component.image;
      elementConfig10["x"] = 36;
      elementConfig10["h"] = 20;
      elementConfig10["w"] = 20;
      elementConfig10["map"] = component.sprite;
      elementConfig10["frame"] = component.fps[2];
      const skip102 = [];
      if (typeof cmp10 !== "undefined") {
        for (let key in cmp10.config.props) {
          delete elementConfig10[cmp10.config.props[key]];
          skip102.push(cmp10.config.props[key]);
        }
      }
      elms[10].populate(elementConfig10);
      parent = elms[10];
      const props11 = {};
      props11["image"] = component.image;
      props11["x"] = 36;
      props11["h"] = 20;
      props11["w"] = 20;
      props11["map"] = component.sprite;
      propData = component.fps[2];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props11["frame"] = propData;
      componentType = props11["is"] || "Sprite";
      let component11;
      if (typeof componentType === "string") {
        component11 = context.components && context.components[componentType] || components[componentType];
        if (!component11) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component11 = componentType;
      }
      elms[11] = component11.call(null, { props: props11 }, elms[10], component);
      if (elms[11][Symbol.for("slots")][0]) {
        parent = elms[11][Symbol.for("slots")][0];
        component = elms[11];
      } else {
        parent = elms[11][Symbol.for("children")][0];
      }
      parent = elms[1];
      const elementConfig12 = {};
      elms[12] = this.element({ parent: parent || "root" }, component);
      elementConfig12["x"] = 150;
      elms[12].populate(elementConfig12);
      const cmp13 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[12];
      const elementConfig13 = {};
      elms[13] = this.element({ parent: parent || "root" }, component);
      elementConfig13["image"] = component.image;
      elementConfig13["y"] = 2;
      elementConfig13["w"] = 48;
      elementConfig13["h"] = 25;
      elementConfig13["map"] = component.sprite;
      elementConfig13["frame"] = "avg";
      const skip13 = [];
      if (typeof cmp13 !== "undefined") {
        for (let key in cmp13.config.props) {
          delete elementConfig13[cmp13.config.props[key]];
          skip13.push(cmp13.config.props[key]);
        }
      }
      elms[13].populate(elementConfig13);
      parent = elms[13];
      const props14 = {};
      props14["image"] = component.image;
      props14["y"] = 2;
      props14["w"] = 48;
      props14["h"] = 25;
      props14["map"] = component.sprite;
      props14["frame"] = "avg";
      componentType = props14["is"] || "Sprite";
      let component14;
      if (typeof componentType === "string") {
        component14 = context.components && context.components[componentType] || components[componentType];
        if (!component14) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component14 = componentType;
      }
      elms[14] = component14.call(null, { props: props14 }, elms[13], component);
      if (elms[14][Symbol.for("slots")][0]) {
        parent = elms[14][Symbol.for("slots")][0];
        component = elms[14];
      } else {
        parent = elms[14][Symbol.for("children")][0];
      }
      parent = elms[12];
      const elementConfig15 = {};
      elms[15] = this.element({ parent: parent || "root" }, component);
      elementConfig15["x"] = 63;
      elementConfig15["y"] = 2;
      elms[15].populate(elementConfig15);
      const cmp16 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[15];
      const elementConfig16 = {};
      elms[16] = this.element({ parent: parent || "root" }, component);
      elementConfig16["image"] = component.image;
      elementConfig16["x"] = 0;
      elementConfig16["h"] = 20;
      elementConfig16["w"] = 20;
      elementConfig16["map"] = component.sprite;
      elementConfig16["frame"] = component.avgFps[0];
      const skip162 = [];
      if (typeof cmp16 !== "undefined") {
        for (let key in cmp16.config.props) {
          delete elementConfig16[cmp16.config.props[key]];
          skip162.push(cmp16.config.props[key]);
        }
      }
      elms[16].populate(elementConfig16);
      parent = elms[16];
      const props17 = {};
      props17["image"] = component.image;
      props17["x"] = 0;
      props17["h"] = 20;
      props17["w"] = 20;
      props17["map"] = component.sprite;
      propData = component.avgFps[0];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props17["frame"] = propData;
      componentType = props17["is"] || "Sprite";
      let component17;
      if (typeof componentType === "string") {
        component17 = context.components && context.components[componentType] || components[componentType];
        if (!component17) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component17 = componentType;
      }
      elms[17] = component17.call(null, { props: props17 }, elms[16], component);
      if (elms[17][Symbol.for("slots")][0]) {
        parent = elms[17][Symbol.for("slots")][0];
        component = elms[17];
      } else {
        parent = elms[17][Symbol.for("children")][0];
      }
      const cmp18 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[15];
      const elementConfig18 = {};
      elms[18] = this.element({ parent: parent || "root" }, component);
      elementConfig18["image"] = component.image;
      elementConfig18["x"] = 18;
      elementConfig18["h"] = 20;
      elementConfig18["w"] = 20;
      elementConfig18["map"] = component.sprite;
      elementConfig18["frame"] = component.avgFps[1];
      const skip182 = [];
      if (typeof cmp18 !== "undefined") {
        for (let key in cmp18.config.props) {
          delete elementConfig18[cmp18.config.props[key]];
          skip182.push(cmp18.config.props[key]);
        }
      }
      elms[18].populate(elementConfig18);
      parent = elms[18];
      const props19 = {};
      props19["image"] = component.image;
      props19["x"] = 18;
      props19["h"] = 20;
      props19["w"] = 20;
      props19["map"] = component.sprite;
      propData = component.avgFps[1];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props19["frame"] = propData;
      componentType = props19["is"] || "Sprite";
      let component19;
      if (typeof componentType === "string") {
        component19 = context.components && context.components[componentType] || components[componentType];
        if (!component19) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component19 = componentType;
      }
      elms[19] = component19.call(null, { props: props19 }, elms[18], component);
      if (elms[19][Symbol.for("slots")][0]) {
        parent = elms[19][Symbol.for("slots")][0];
        component = elms[19];
      } else {
        parent = elms[19][Symbol.for("children")][0];
      }
      const cmp20 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[15];
      const elementConfig20 = {};
      elms[20] = this.element({ parent: parent || "root" }, component);
      elementConfig20["image"] = component.image;
      elementConfig20["x"] = 36;
      elementConfig20["h"] = 20;
      elementConfig20["w"] = 20;
      elementConfig20["map"] = component.sprite;
      elementConfig20["frame"] = component.avgFps[2];
      const skip202 = [];
      if (typeof cmp20 !== "undefined") {
        for (let key in cmp20.config.props) {
          delete elementConfig20[cmp20.config.props[key]];
          skip202.push(cmp20.config.props[key]);
        }
      }
      elms[20].populate(elementConfig20);
      parent = elms[20];
      const props21 = {};
      props21["image"] = component.image;
      props21["x"] = 36;
      props21["h"] = 20;
      props21["w"] = 20;
      props21["map"] = component.sprite;
      propData = component.avgFps[2];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props21["frame"] = propData;
      componentType = props21["is"] || "Sprite";
      let component21;
      if (typeof componentType === "string") {
        component21 = context.components && context.components[componentType] || components[componentType];
        if (!component21) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component21 = componentType;
      }
      elms[21] = component21.call(null, { props: props21 }, elms[20], component);
      if (elms[21][Symbol.for("slots")][0]) {
        parent = elms[21][Symbol.for("slots")][0];
        component = elms[21];
      } else {
        parent = elms[21][Symbol.for("children")][0];
      }
      parent = elms[1];
      const elementConfig22 = {};
      elms[22] = this.element({ parent: parent || "root" }, component);
      elementConfig22["x"] = 0;
      elementConfig22["y"] = 40;
      elms[22].populate(elementConfig22);
      const cmp23 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[22];
      const elementConfig23 = {};
      elms[23] = this.element({ parent: parent || "root" }, component);
      elementConfig23["image"] = component.image;
      elementConfig23["x"] = -2;
      elementConfig23["w"] = 47;
      elementConfig23["h"] = 25;
      elementConfig23["map"] = component.sprite;
      elementConfig23["frame"] = "min";
      const skip23 = [];
      if (typeof cmp23 !== "undefined") {
        for (let key in cmp23.config.props) {
          delete elementConfig23[cmp23.config.props[key]];
          skip23.push(cmp23.config.props[key]);
        }
      }
      elms[23].populate(elementConfig23);
      parent = elms[23];
      const props24 = {};
      props24["image"] = component.image;
      props24["x"] = -2;
      props24["w"] = 47;
      props24["h"] = 25;
      props24["map"] = component.sprite;
      props24["frame"] = "min";
      componentType = props24["is"] || "Sprite";
      let component24;
      if (typeof componentType === "string") {
        component24 = context.components && context.components[componentType] || components[componentType];
        if (!component24) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component24 = componentType;
      }
      elms[24] = component24.call(null, { props: props24 }, elms[23], component);
      if (elms[24][Symbol.for("slots")][0]) {
        parent = elms[24][Symbol.for("slots")][0];
        component = elms[24];
      } else {
        parent = elms[24][Symbol.for("children")][0];
      }
      parent = elms[22];
      const elementConfig25 = {};
      elms[25] = this.element({ parent: parent || "root" }, component);
      elementConfig25["x"] = 58;
      elementConfig25["y"] = 2;
      elms[25].populate(elementConfig25);
      const cmp26 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[25];
      const elementConfig26 = {};
      elms[26] = this.element({ parent: parent || "root" }, component);
      elementConfig26["image"] = component.image;
      elementConfig26["x"] = 0;
      elementConfig26["h"] = 20;
      elementConfig26["w"] = 20;
      elementConfig26["map"] = component.sprite;
      elementConfig26["frame"] = component.minFps[0];
      const skip262 = [];
      if (typeof cmp26 !== "undefined") {
        for (let key in cmp26.config.props) {
          delete elementConfig26[cmp26.config.props[key]];
          skip262.push(cmp26.config.props[key]);
        }
      }
      elms[26].populate(elementConfig26);
      parent = elms[26];
      const props27 = {};
      props27["image"] = component.image;
      props27["x"] = 0;
      props27["h"] = 20;
      props27["w"] = 20;
      props27["map"] = component.sprite;
      propData = component.minFps[0];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props27["frame"] = propData;
      componentType = props27["is"] || "Sprite";
      let component27;
      if (typeof componentType === "string") {
        component27 = context.components && context.components[componentType] || components[componentType];
        if (!component27) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component27 = componentType;
      }
      elms[27] = component27.call(null, { props: props27 }, elms[26], component);
      if (elms[27][Symbol.for("slots")][0]) {
        parent = elms[27][Symbol.for("slots")][0];
        component = elms[27];
      } else {
        parent = elms[27][Symbol.for("children")][0];
      }
      const cmp28 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[25];
      const elementConfig28 = {};
      elms[28] = this.element({ parent: parent || "root" }, component);
      elementConfig28["image"] = component.image;
      elementConfig28["x"] = 18;
      elementConfig28["h"] = 20;
      elementConfig28["w"] = 20;
      elementConfig28["map"] = component.sprite;
      elementConfig28["frame"] = component.minFps[1];
      const skip282 = [];
      if (typeof cmp28 !== "undefined") {
        for (let key in cmp28.config.props) {
          delete elementConfig28[cmp28.config.props[key]];
          skip282.push(cmp28.config.props[key]);
        }
      }
      elms[28].populate(elementConfig28);
      parent = elms[28];
      const props29 = {};
      props29["image"] = component.image;
      props29["x"] = 18;
      props29["h"] = 20;
      props29["w"] = 20;
      props29["map"] = component.sprite;
      propData = component.minFps[1];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props29["frame"] = propData;
      componentType = props29["is"] || "Sprite";
      let component29;
      if (typeof componentType === "string") {
        component29 = context.components && context.components[componentType] || components[componentType];
        if (!component29) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component29 = componentType;
      }
      elms[29] = component29.call(null, { props: props29 }, elms[28], component);
      if (elms[29][Symbol.for("slots")][0]) {
        parent = elms[29][Symbol.for("slots")][0];
        component = elms[29];
      } else {
        parent = elms[29][Symbol.for("children")][0];
      }
      const cmp30 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[25];
      const elementConfig30 = {};
      elms[30] = this.element({ parent: parent || "root" }, component);
      elementConfig30["image"] = component.image;
      elementConfig30["x"] = 36;
      elementConfig30["h"] = 20;
      elementConfig30["w"] = 20;
      elementConfig30["map"] = component.sprite;
      elementConfig30["frame"] = component.minFps[2];
      const skip302 = [];
      if (typeof cmp30 !== "undefined") {
        for (let key in cmp30.config.props) {
          delete elementConfig30[cmp30.config.props[key]];
          skip302.push(cmp30.config.props[key]);
        }
      }
      elms[30].populate(elementConfig30);
      parent = elms[30];
      const props31 = {};
      props31["image"] = component.image;
      props31["x"] = 36;
      props31["h"] = 20;
      props31["w"] = 20;
      props31["map"] = component.sprite;
      propData = component.minFps[2];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props31["frame"] = propData;
      componentType = props31["is"] || "Sprite";
      let component31;
      if (typeof componentType === "string") {
        component31 = context.components && context.components[componentType] || components[componentType];
        if (!component31) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component31 = componentType;
      }
      elms[31] = component31.call(null, { props: props31 }, elms[30], component);
      if (elms[31][Symbol.for("slots")][0]) {
        parent = elms[31][Symbol.for("slots")][0];
        component = elms[31];
      } else {
        parent = elms[31][Symbol.for("children")][0];
      }
      parent = elms[1];
      const elementConfig32 = {};
      elms[32] = this.element({ parent: parent || "root" }, component);
      elementConfig32["x"] = 150;
      elementConfig32["y"] = 40;
      elms[32].populate(elementConfig32);
      const cmp33 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[32];
      const elementConfig33 = {};
      elms[33] = this.element({ parent: parent || "root" }, component);
      elementConfig33["image"] = component.image;
      elementConfig33["w"] = 53;
      elementConfig33["h"] = 25;
      elementConfig33["map"] = component.sprite;
      elementConfig33["frame"] = "max";
      const skip33 = [];
      if (typeof cmp33 !== "undefined") {
        for (let key in cmp33.config.props) {
          delete elementConfig33[cmp33.config.props[key]];
          skip33.push(cmp33.config.props[key]);
        }
      }
      elms[33].populate(elementConfig33);
      parent = elms[33];
      const props34 = {};
      props34["image"] = component.image;
      props34["w"] = 53;
      props34["h"] = 25;
      props34["map"] = component.sprite;
      props34["frame"] = "max";
      componentType = props34["is"] || "Sprite";
      let component34;
      if (typeof componentType === "string") {
        component34 = context.components && context.components[componentType] || components[componentType];
        if (!component34) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component34 = componentType;
      }
      elms[34] = component34.call(null, { props: props34 }, elms[33], component);
      if (elms[34][Symbol.for("slots")][0]) {
        parent = elms[34][Symbol.for("slots")][0];
        component = elms[34];
      } else {
        parent = elms[34][Symbol.for("children")][0];
      }
      parent = elms[32];
      const elementConfig35 = {};
      elms[35] = this.element({ parent: parent || "root" }, component);
      elementConfig35["x"] = 63;
      elementConfig35["y"] = 2;
      elms[35].populate(elementConfig35);
      const cmp36 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[35];
      const elementConfig36 = {};
      elms[36] = this.element({ parent: parent || "root" }, component);
      elementConfig36["image"] = component.image;
      elementConfig36["x"] = 0;
      elementConfig36["h"] = 20;
      elementConfig36["w"] = 20;
      elementConfig36["map"] = component.sprite;
      elementConfig36["frame"] = component.maxFps[0];
      const skip362 = [];
      if (typeof cmp36 !== "undefined") {
        for (let key in cmp36.config.props) {
          delete elementConfig36[cmp36.config.props[key]];
          skip362.push(cmp36.config.props[key]);
        }
      }
      elms[36].populate(elementConfig36);
      parent = elms[36];
      const props37 = {};
      props37["image"] = component.image;
      props37["x"] = 0;
      props37["h"] = 20;
      props37["w"] = 20;
      props37["map"] = component.sprite;
      propData = component.maxFps[0];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props37["frame"] = propData;
      componentType = props37["is"] || "Sprite";
      let component37;
      if (typeof componentType === "string") {
        component37 = context.components && context.components[componentType] || components[componentType];
        if (!component37) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component37 = componentType;
      }
      elms[37] = component37.call(null, { props: props37 }, elms[36], component);
      if (elms[37][Symbol.for("slots")][0]) {
        parent = elms[37][Symbol.for("slots")][0];
        component = elms[37];
      } else {
        parent = elms[37][Symbol.for("children")][0];
      }
      const cmp38 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[35];
      const elementConfig38 = {};
      elms[38] = this.element({ parent: parent || "root" }, component);
      elementConfig38["image"] = component.image;
      elementConfig38["x"] = 18;
      elementConfig38["h"] = 20;
      elementConfig38["w"] = 20;
      elementConfig38["map"] = component.sprite;
      elementConfig38["frame"] = component.maxFps[1];
      const skip382 = [];
      if (typeof cmp38 !== "undefined") {
        for (let key in cmp38.config.props) {
          delete elementConfig38[cmp38.config.props[key]];
          skip382.push(cmp38.config.props[key]);
        }
      }
      elms[38].populate(elementConfig38);
      parent = elms[38];
      const props39 = {};
      props39["image"] = component.image;
      props39["x"] = 18;
      props39["h"] = 20;
      props39["w"] = 20;
      props39["map"] = component.sprite;
      propData = component.maxFps[1];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props39["frame"] = propData;
      componentType = props39["is"] || "Sprite";
      let component39;
      if (typeof componentType === "string") {
        component39 = context.components && context.components[componentType] || components[componentType];
        if (!component39) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component39 = componentType;
      }
      elms[39] = component39.call(null, { props: props39 }, elms[38], component);
      if (elms[39][Symbol.for("slots")][0]) {
        parent = elms[39][Symbol.for("slots")][0];
        component = elms[39];
      } else {
        parent = elms[39][Symbol.for("children")][0];
      }
      const cmp40 = context.components && context.components["Sprite"] || components["Sprite"];
      parent = elms[35];
      const elementConfig40 = {};
      elms[40] = this.element({ parent: parent || "root" }, component);
      elementConfig40["image"] = component.image;
      elementConfig40["x"] = 36;
      elementConfig40["h"] = 20;
      elementConfig40["w"] = 20;
      elementConfig40["map"] = component.sprite;
      elementConfig40["frame"] = component.maxFps[2];
      const skip402 = [];
      if (typeof cmp40 !== "undefined") {
        for (let key in cmp40.config.props) {
          delete elementConfig40[cmp40.config.props[key]];
          skip402.push(cmp40.config.props[key]);
        }
      }
      elms[40].populate(elementConfig40);
      parent = elms[40];
      const props41 = {};
      props41["image"] = component.image;
      props41["x"] = 36;
      props41["h"] = 20;
      props41["w"] = 20;
      props41["map"] = component.sprite;
      propData = component.maxFps[2];
      if (Array.isArray(propData) === true) {
        propData = getRaw2(propData).slice(0);
      }
      props41["frame"] = propData;
      componentType = props41["is"] || "Sprite";
      let component41;
      if (typeof componentType === "string") {
        component41 = context.components && context.components[componentType] || components[componentType];
        if (!component41) {
          throw new Error('Component "Sprite" not found');
        }
      } else if (typeof componentType === "function" && componentType[Symbol.for("isComponent")] === true) {
        component41 = componentType;
      }
      elms[41] = component41.call(null, { props: props41 }, elms[40], component);
      if (elms[41][Symbol.for("slots")][0]) {
        parent = elms[41][Symbol.for("slots")][0];
        component = elms[41];
      } else {
        parent = elms[41][Symbol.for("children")][0];
      }
      return elms;
    },
    effects: [
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip6 === "undefined" || skip6.indexOf("frame") === -1)
          elms[6].set("frame", component.fps[0]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[7][Symbol.for("props")]["frame"] = component.fps[0];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip8 === "undefined" || skip8.indexOf("frame") === -1)
          elms[8].set("frame", component.fps[1]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[9][Symbol.for("props")]["frame"] = component.fps[1];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip10 === "undefined" || skip10.indexOf("frame") === -1)
          elms[10].set("frame", component.fps[2]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[11][Symbol.for("props")]["frame"] = component.fps[2];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip16 === "undefined" || skip16.indexOf("frame") === -1)
          elms[16].set("frame", component.avgFps[0]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[17][Symbol.for("props")]["frame"] = component.avgFps[0];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip18 === "undefined" || skip18.indexOf("frame") === -1)
          elms[18].set("frame", component.avgFps[1]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[19][Symbol.for("props")]["frame"] = component.avgFps[1];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip20 === "undefined" || skip20.indexOf("frame") === -1)
          elms[20].set("frame", component.avgFps[2]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[21][Symbol.for("props")]["frame"] = component.avgFps[2];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip26 === "undefined" || skip26.indexOf("frame") === -1)
          elms[26].set("frame", component.minFps[0]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[27][Symbol.for("props")]["frame"] = component.minFps[0];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip28 === "undefined" || skip28.indexOf("frame") === -1)
          elms[28].set("frame", component.minFps[1]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[29][Symbol.for("props")]["frame"] = component.minFps[1];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip30 === "undefined" || skip30.indexOf("frame") === -1)
          elms[30].set("frame", component.minFps[2]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[31][Symbol.for("props")]["frame"] = component.minFps[2];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip36 === "undefined" || skip36.indexOf("frame") === -1)
          elms[36].set("frame", component.maxFps[0]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[37][Symbol.for("props")]["frame"] = component.maxFps[0];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip38 === "undefined" || skip38.indexOf("frame") === -1)
          elms[38].set("frame", component.maxFps[1]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[39][Symbol.for("props")]["frame"] = component.maxFps[1];
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        if (typeof skip40 === "undefined" || skip40.indexOf("frame") === -1)
          elms[40].set("frame", component.maxFps[2]);
      },
      function anonymous(component, elms, context, components, rootComponent, effect2) {
        elms[41][Symbol.for("props")]["frame"] = component.maxFps[2];
      }
    ],
    context: {}
  },
  state() {
    return {
      image: fps_sprite_base64_default,
      sprite: {
        defaults: {
          y: 1,
          w: 20,
          h: 20
        },
        frames: {
          "-": { x: -1e3 },
          0: { x: 1 },
          1: { x: 23 },
          2: { x: 45 },
          3: { x: 67 },
          4: { x: 89 },
          5: { x: 111 },
          6: { x: 133 },
          7: { x: 155 },
          8: { x: 177 },
          9: { x: 199 },
          avg: { x: 221, w: 48, h: 25 },
          fps: { x: 271, w: 43, h: 25 },
          max: { x: 316, w: 53, h: 25 },
          min: { x: 371, w: 47, h: 25 }
        }
      },
      fps: "---",
      avgFps: "---",
      minFps: "---",
      maxFps: "---"
    };
  },
  hooks: {
    ready() {
      let minFps = 1e4;
      let maxFps = 0;
      let avgFps = 0;
      let totalFps = 0;
      let fpsUpdateCounter = 0;
      renderer2.on("fpsUpdate", (rM, { fps }) => {
        minFps = Math.min(fps, minFps);
        maxFps = Math.max(fps, maxFps);
        totalFps += fps;
        fpsUpdateCounter++;
        avgFps = Math.round(totalFps / fpsUpdateCounter);
        this.fps = fps.toString().padStart(3, "0");
        this.avgFps = avgFps.toString().padStart(3, "0");
        this.minFps = minFps.toString().padStart(3, "0");
        this.maxFps = maxFps.toString().padStart(3, "0");
      });
    }
  }
});

// node_modules/@lightningjs/blits/src/components/index.js
var components_default = () => ({
  Circle: Circle_default(),
  RouterView: RouterView_default(),
  Sprite: Sprite_default(),
  FPScounter: FPScounter_default()
});

// node_modules/@lightningjs/blits/src/plugins/log.js
var log_default2 = {
  name: "log",
  plugin() {
    return log_default("App");
  }
};

// node_modules/@lightningjs/blits/src/plugin.js
var plugins = {
  // log plugin added by default
  log: log_default2
};
var registerPlugin = (plugin, nameOrOptions = "", options = {}) => {
  let name = void 0;
  if (typeof nameOrOptions === "object") {
    options = nameOrOptions;
  } else {
    name = nameOrOptions;
  }
  if (typeof plugin === "function") {
    if (name === void 0) {
      throw Error("Error registering plugin: name is required for plugin");
    }
    plugins[name] = { plugin, options };
  } else if (plugin.plugin) {
    registerPlugin(plugin.plugin, name || plugin.name, options);
  }
};
var plugin_default = registerPlugin;

// node_modules/@lightningjs/blits/src/component.js
var globalComponents;
var required = (name) => {
  throw new Error(`Parameter ${name} is required`);
};
var Component = (name = required("name"), config = required("config")) => {
  let base = void 0;
  const component = function(opts, parentEl, parentComponent, rootComponent) {
    this.componentId = createHumanReadableId(name);
    this.lifecycle = Object.assign(Object.create(lifecycle_default), {
      component: this,
      previous: null,
      current: null
    });
    this.parent = parentComponent;
    this.rootParent = rootComponent;
    this[symbols_default.holder] = parentEl;
    this[symbols_default.id] = createInternalId();
    this[symbols_default.props] = reactive(opts.props || {}, settings_default.get("reactivityMode"));
    this[symbols_default.timeouts] = [];
    this[symbols_default.intervals] = [];
    this[symbols_default.originalState] = config.state && typeof config.state === "function" && config.state.apply(this) || {};
    this[symbols_default.originalState]["hasFocus"] = false;
    this[symbols_default.state] = reactive(this[symbols_default.originalState], settings_default.get("reactivityMode"));
    this.lifecycle.state = "init";
    this[symbols_default.children] = config.code.render.apply(stage, [parentEl, this, config, globalComponents, effect, getRaw]) || [];
    this[symbols_default.wrapper] = this[symbols_default.children][0];
    this[symbols_default.slots] = this[symbols_default.children].filter((child) => child[symbols_default.isSlot]);
    if (config.hooks) {
      if (config.hooks.frameTick) {
        renderer2.on(
          "frameTick",
          (r, data) => emit("frameTick", this[symbols_default.identifier], this, [data])
        );
      }
      if (config.hooks.idle) {
        renderer2.on("idle", () => {
          emit("idle", this[symbols_default.identifier], this);
        });
      }
      if (config.hooks.attach) {
        this[symbols_default.wrapper].node.on("inBounds", () => {
          this.lifecycle.state = "attach";
        });
      }
      if (config.hooks.detach) {
        this[symbols_default.wrapper].node.on("outOfBounds", (node, { previous }) => {
          if (previous > 0) this.lifecycle.state = "detach";
        });
      }
      if (config.hooks.enter) {
        this[symbols_default.wrapper].node.on("inViewport", () => {
          this.lifecycle.state = "enter";
        });
      }
      if (config.hooks.exit) {
        this[symbols_default.wrapper].node.on("outOfViewport", () => {
          this.lifecycle.state = "exit";
        });
      }
    }
    const effects = config.code.effects;
    for (let i = 0; i < effects.length; i++) {
      const eff = () => {
        effects[i](this, this[symbols_default.children], config, globalComponents, rootComponent, effect);
      };
      this[symbols_default.effects].push(eff);
      effect(eff);
    }
    if (this[symbols_default.watchers]) {
      const watcherkeys = Object.keys(this[symbols_default.watchers]);
      const watcherkeysLength = watcherkeys.length;
      for (let i = 0; i < watcherkeysLength; i++) {
        let target = this;
        let key = watcherkeys[i];
        const watchKey = key;
        if (key.indexOf(".") > -1) {
          const keys = key.split(".");
          key = keys.pop();
          for (let i2 = 0; i2 < keys.length; i2++) {
            target = target[keys[i2]];
          }
        }
        let old = this[key];
        effect((force = false) => {
          const newValue = target[key];
          if (old !== newValue || force === true) {
            this[symbols_default.watchers][watchKey].apply(this, [newValue, old]);
            old = newValue;
          }
        });
      }
    }
    setTimeout(() => this.lifecycle.state = "ready");
    return this;
  };
  const factory = (options = {}, parentEl, parentComponent, rootComponent) => {
    if (base_default[symbols_default["launched"]] === false) {
      const pluginKeys = Object.keys(plugins);
      const pluginKeysLength = pluginKeys.length;
      for (let i = 0; i < pluginKeysLength; i++) {
        const pluginName = pluginKeys[i];
        const prefixedPluginName = `$${pluginName}`;
        if (prefixedPluginName in base_default) {
          Log.warn(
            `"${pluginName}" (this.${prefixedPluginName}) already exists as a property or plugin on the Base Component. You may be overwriting built-in functionality. Proceed with care!`
          );
        }
        const plugin = plugins[pluginName];
        Object.defineProperty(base_default, prefixedPluginName, {
          // instantiate the plugin, passing in provided options
          value: plugin.plugin(plugin.options),
          writable: false,
          enumerable: true,
          configurable: false
        });
      }
      globalComponents = components_default();
      base_default[symbols_default["launched"]] = true;
    }
    if (base === void 0) {
      Log.debug(`Setting up ${name} component`);
      base = setup_default(Object.create(base_default), config);
    }
    if (config.code === void 0) {
      Log.debug(`Generating code for ${name} component`);
      config.code = generator_default.call(config, parser_default(config.template, name));
    }
    return component.call(Object.create(base), options, parentEl, parentComponent, rootComponent);
  };
  factory.config = config;
  factory[symbols_default.isComponent] = true;
  return factory;
};
var component_default = Component;

// node_modules/@lightningjs/blits/src/application.js
var Application = (config) => {
  const defaultKeyMap = {
    ArrowLeft: "left",
    ArrowRight: "right",
    ArrowUp: "up",
    ArrowDown: "down",
    Enter: "enter",
    " ": "space",
    Backspace: "back",
    Escape: "escape",
    37: "left",
    39: "right",
    38: "up",
    40: "down",
    13: "enter",
    32: "space",
    8: "back",
    27: "escape"
  };
  config.hooks = config.hooks || {};
  let keyDownHandler;
  let keyUpHandler;
  let holdTimeout;
  config.hooks[symbols_default.destroy] = function() {
    document.removeEventListener("keydown", keyDownHandler);
    document.removeEventListener("keyup", keyUpHandler);
  };
  config.hooks[symbols_default.init] = function() {
    const keyMap = { ...defaultKeyMap, ...settings_default.get("keymap", {}) };
    keyDownHandler = (e) => {
      const key = keyMap[e.key] || keyMap[e.keyCode] || e.key || e.keyCode;
      focus_default.input(key, e);
      clearTimeout(holdTimeout);
      holdTimeout = setTimeout(() => {
        focus_default.hold = true;
      }, settings_default.get("holdTimeout", DEFAULT_HOLD_TIMEOUT_MS));
    };
    keyUpHandler = (e) => {
      const cb = keyUpCallbacks.get(e.code);
      if (cb !== void 0 && typeof cb === "function") {
        keyUpCallbacks.delete(e.code);
        cb();
      }
      clearTimeout(holdTimeout);
      focus_default.hold = false;
    };
    document.addEventListener("keydown", keyDownHandler);
    document.addEventListener("keyup", keyUpHandler);
    setTimeout(() => focus_default.set(this));
  };
  return component_default("App", config);
};
var application_default = Application;

// node_modules/@lightningjs/blits/index.js
var blits_default = {
  Component: component_default,
  Application: application_default,
  Launch: launch_default2,
  Plugin: plugin_default
};
export {
  blits_default as default
};
//# sourceMappingURL=@lightningjs_blits.js.map

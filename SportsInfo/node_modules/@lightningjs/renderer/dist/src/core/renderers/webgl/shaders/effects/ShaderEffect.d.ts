import type { EffectMap } from '../../../../CoreShaderManager.js';
import type { ExtractProps } from '../../../../CoreTextureManager.js';
import type { AlphaShaderProp, DimensionsShaderProp } from '../../WebGlCoreShader.js';
import type { UniformInfo, UniformMethodMap } from '../../internal/ShaderUtils.js';
export interface BaseEffectDesc {
    name?: string;
    type: keyof EffectMap;
    props: Record<string, any>;
}
export interface EffectDesc<T extends {
    name?: string;
    type: keyof EffectMap;
} = {
    name?: string;
    type: keyof EffectMap;
}> extends BaseEffectDesc {
    name?: T['name'];
    type: T['type'];
    props: ExtractProps<EffectMap[T['type']]>;
}
/**
 * Allows the `keyof EffectMap` to be mapped over and form an discriminated
 * union of all the EffectDescs structures individually.
 *
 * @remarks
 * When used like the following:
 * ```
 * MapEffectDescs<keyof EffectMap>[]
 * ```
 * The resultant type will be a discriminated union like so:
 * ```
 * (
 *   {
 *     name: 'effect1',
 *     type: 'radius',
 *     props?: {
 *       radius?: number | number[];
 *     }
 *   } |
 *   {
 *     name: 'effect2',
 *     type: 'border',
 *     props?: {
 *       width?: number;
 *       color?: number;
 *     }
 *   } |
 *   // ...
 * )[]
 * ```
 * Which means TypeScript will now base its type checking on the `type` field
 * and will know exactly what the `props` field should be based on the `type`
 * field.
 */
type MapEffectDescs<T extends keyof EffectMap> = T extends keyof EffectMap ? EffectDesc<{
    type: T;
    name: string;
}> : never;
export type EffectDescUnion = MapEffectDescs<keyof EffectMap>;
export interface ShaderEffectUniform {
    value: number | number[] | boolean | string;
    type: string;
    method: keyof UniformMethodMap;
    name?: string;
    size?: (value: Record<string, unknown>) => number;
    updateOnBind?: boolean;
    updateProgramValue?: (programValues: ShaderEffectValueMap, shaderProps?: Record<string, unknown>) => void;
    validator?: (value: any, props: Record<string, unknown>) => number | number[] | number[][];
}
export interface ShaderEffectValueMap extends DimensionsShaderProp, AlphaShaderProp {
    value: ShaderEffectUniform['value'];
    programValue: number | Float32Array | undefined;
    method: keyof UniformMethodMap;
    setUniformValue?: () => void | null;
    hasValidator: boolean;
    hasProgramValueUpdater: boolean;
    updateOnBind: boolean;
    validatedValue?: number | number[];
}
export interface ShaderEffectUniforms {
    [key: string]: ShaderEffectUniform;
}
export interface DefaultEffectProps {
    [key: string]: unknown;
}
export interface ShaderEffectOptions {
    ref: string;
    target: string;
    props?: Record<string, unknown>;
    uniforms?: ShaderEffectUniforms;
    methods?: Record<string, string>;
    onShaderMask?: ((value: Record<string, unknown>) => string) | string;
    onColorize?: ((value: Record<string, unknown>) => string) | string;
    onEffectMask?: ((value: Record<string, unknown>) => string) | string;
}
export declare abstract class ShaderEffect {
    readonly priority = 1;
    readonly name: string;
    ref: string;
    target: string;
    passParameters: string;
    declaredUniforms: string;
    uniformInfo: Record<string, UniformInfo>;
    static uniforms: ShaderEffectUniforms;
    static methods?: Record<string, string>;
    static onShaderMask?: ((value: Record<string, unknown>) => string) | string;
    static onColorize?: ((value: Record<string, unknown>) => string) | string;
    static onEffectMask?: ((value: Record<string, unknown>) => string) | string;
    static getEffectKey(props: Record<string, unknown>): string;
    static getMethodParameters(uniforms: ShaderEffectUniforms, props: Record<string, unknown>): string;
    constructor(options: ShaderEffectOptions);
    static resolveDefaults(props: Record<string, unknown>): Record<string, unknown>;
    static makeEffectKey(props: Record<string, unknown>): string | false;
}
export {};

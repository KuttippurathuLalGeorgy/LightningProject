/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2023 Comcast Cable Communications Management, LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ImageWorkerManager } from './lib/ImageWorker.js';
import { ColorTexture } from './textures/ColorTexture.js';
import { ImageTexture } from './textures/ImageTexture.js';
import { NoiseTexture } from './textures/NoiseTexture.js';
import { SubTexture } from './textures/SubTexture.js';
import { RenderTexture } from './textures/RenderTexture.js';
export class CoreTextureManager {
    /**
     * Map of textures by cache key
     */
    keyCache = new Map();
    /**
     * Map of cache keys by texture
     */
    inverseKeyCache = new WeakMap();
    /**
     * Map of texture constructors by their type name
     */
    txConstructors = {};
    imageWorkerManager = null;
    hasCreateImageBitmap = !!self.createImageBitmap;
    hasWorker = !!self.Worker;
    /**
     * Renderer that this texture manager is associated with
     *
     * @remarks
     * This MUST be set before the texture manager is used. Otherwise errors
     * will occur when using the texture manager.
     */
    renderer;
    /**
     * The current frame time in milliseconds
     *
     * @remarks
     * This is used to populate the `lastRenderableChangeTime` property of
     * {@link Texture} instances when their renderable state changes.
     *
     * Set by stage via `updateFrameTime` method.
     */
    frameTime = 0;
    constructor(numImageWorkers) {
        // Register default known texture types
        if (this.hasCreateImageBitmap && this.hasWorker && numImageWorkers > 0) {
            this.imageWorkerManager = new ImageWorkerManager(numImageWorkers);
        }
        if (!this.hasCreateImageBitmap) {
            console.warn('[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.');
        }
        this.registerTextureType('ImageTexture', ImageTexture);
        this.registerTextureType('ColorTexture', ColorTexture);
        this.registerTextureType('NoiseTexture', NoiseTexture);
        this.registerTextureType('SubTexture', SubTexture);
        this.registerTextureType('RenderTexture', RenderTexture);
    }
    registerTextureType(textureType, textureClass) {
        this.txConstructors[textureType] = textureClass;
    }
    loadTexture(textureType, props) {
        let texture;
        const TextureClass = this.txConstructors[textureType];
        if (!TextureClass) {
            throw new Error(`Texture type "${textureType}" is not registered`);
        }
        if (!texture) {
            const cacheKey = TextureClass.makeCacheKey(props);
            if (cacheKey && this.keyCache.has(cacheKey)) {
                // console.log('Getting texture by cache key', cacheKey);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                texture = this.keyCache.get(cacheKey);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
                texture = new TextureClass(this, props);
                if (cacheKey) {
                    this.initTextureToCache(texture, cacheKey);
                }
            }
        }
        return texture;
    }
    initTextureToCache(texture, cacheKey) {
        const { keyCache, inverseKeyCache } = this;
        keyCache.set(cacheKey, texture);
        inverseKeyCache.set(texture, cacheKey);
    }
    /**
     * Remove a texture from the cache
     *
     * @remarks
     * Called by Texture Cleanup when a texture is freed.
     *
     * @param texture
     */
    removeTextureFromCache(texture) {
        const { inverseKeyCache, keyCache } = this;
        const cacheKey = inverseKeyCache.get(texture);
        if (cacheKey) {
            keyCache.delete(cacheKey);
        }
    }
}
//# sourceMappingURL=CoreTextureManager.js.map
import { CoreRenderer, type BufferInfo, type CoreRendererOptions, type QuadOptions } from '../CoreRenderer.js';
import { WebGlCoreRenderOp } from './WebGlCoreRenderOp.js';
import type { CoreContextTexture } from '../CoreContextTexture.js';
import { type CoreWebGlParameters, type CoreWebGlExtensions } from './internal/RendererUtils.js';
import { Texture } from '../../textures/Texture.js';
import { CoreShaderManager } from '../../CoreShaderManager.js';
import { BufferCollection } from './internal/BufferCollection.js';
import { WebGlCoreShader } from './WebGlCoreShader.js';
import { WebGlContextWrapper } from '../../lib/WebGlContextWrapper.js';
import type { CoreNode } from '../../CoreNode.js';
import type { BaseShaderController } from '../../../main-api/ShaderController.js';
export type WebGlCoreRendererOptions = CoreRendererOptions;
interface CoreWebGlSystem {
    parameters: CoreWebGlParameters;
    extensions: CoreWebGlExtensions;
}
export declare class WebGlCoreRenderer extends CoreRenderer {
    glw: WebGlContextWrapper;
    system: CoreWebGlSystem;
    quadBuffer: ArrayBuffer;
    fQuadBuffer: Float32Array;
    uiQuadBuffer: Uint32Array;
    renderOps: WebGlCoreRenderOp[];
    curBufferIdx: number;
    curRenderOp: WebGlCoreRenderOp | null;
    rttNodes: CoreNode[];
    activeRttNode: CoreNode | null;
    defShaderCtrl: BaseShaderController;
    defaultShader: WebGlCoreShader;
    quadBufferCollection: BufferCollection;
    /**
     * White pixel texture used by default when no texture is specified.
     */
    defaultTexture: Texture;
    quadBufferUsage: number;
    /**
     * Whether the renderer is currently rendering to a texture.
     */
    renderToTextureActive: boolean;
    constructor(options: WebGlCoreRendererOptions);
    reset(): void;
    getShaderManager(): CoreShaderManager;
    createCtxTexture(textureSource: Texture): CoreContextTexture;
    /**
     * This function adds a quad (a rectangle composed of two triangles) to the WebGL rendering pipeline.
     *
     * It takes a set of options that define the quad's properties, such as its dimensions, colors, texture, shader, and transformation matrix.
     * The function first updates the shader properties with the current dimensions if necessary, then sets the default texture if none is provided.
     * It then checks if a new render operation is needed, based on the current shader and clipping rectangle.
     * If a new render operation is needed, it creates one and updates the current render operation.
     * The function then adjusts the texture coordinates based on the texture options and adds the texture to the texture manager.
     *
     * Finally, it calculates the vertices for the quad, taking into account any transformations, and adds them to the quad buffer.
     * The function updates the length and number of quads in the current render operation, and updates the current buffer index.
     */
    addQuad(params: QuadOptions): void;
    /**
     * Replace the existing RenderOp with a new one that uses the specified Shader
     * and starts at the specified buffer index.
     *
     * @param shader
     * @param bufferIdx
     */
    private newRenderOp;
    /**
     * Add a texture to the current RenderOp. If the texture cannot be added to the
     * current RenderOp, a new RenderOp will be created and the texture will be added
     * to that one.
     *
     * If the texture cannot be added to the new RenderOp, an error will be thrown.
     *
     * @param texture
     * @param bufferIdx
     * @param recursive
     * @returns Assigned Texture Index of the texture in the render op
     */
    private addTexture;
    /**
     * Test if the current Render operation can be reused for the specified parameters.
     * @param params
     * @returns
     */
    reuseRenderOp(params: QuadOptions): boolean;
    /**
     * add RenderOp to the render pipeline
     */
    addRenderOp(renderable: WebGlCoreRenderOp): void;
    /**
     * Render the current set of RenderOps to render to the specified surface.
     *
     * TODO: 'screen' is the only supported surface at the moment.
     *
     * @param surface
     */
    render(surface?: 'screen' | CoreContextTexture): void;
    renderToTexture(node: CoreNode): void;
    /**
     * Inserts an RTT node into `this.rttNodes` while maintaining the correct rendering order based on hierarchy.
     *
     * Rendering order for RTT nodes is critical when nested RTT nodes exist in a parent-child relationship.
     * Specifically:
     *  - Child RTT nodes must be rendered before their RTT-enabled parents to ensure proper texture composition.
     *  - If an RTT node is added and it has existing RTT children, it should be rendered after those children.
     *
     * This function addresses both cases by:
     * 1. **Checking Upwards**: It traverses the node's hierarchy upwards to identify any RTT parent
     *    already in `rttNodes`. If an RTT parent is found, the new node is placed before this parent.
     * 2. **Checking Downwards**: It traverses the nodeâ€™s children recursively to find any RTT-enabled
     *    children that are already in `rttNodes`. If such children are found, the new node is inserted
     *    after the last (highest index) RTT child node.
     *
     * The final calculated insertion index ensures the new node is positioned in `rttNodes` to respect
     * both parent-before-child and child-before-parent rendering rules, preserving the correct order
     * for the WebGL renderer.
     *
     * @param node - The RTT-enabled CoreNode to be added to `rttNodes` in the appropriate hierarchical position.
     */
    private insertRTTNodeInOrder;
    private findMaxChildRTTIndex;
    renderRTTNodes(): void;
    removeRTTNode(node: CoreNode): void;
    getBufferInfo(): BufferInfo | null;
    getDefShaderCtr(): BaseShaderController;
}
export {};

import { AnimationManager } from './animations/AnimationManager.js';
import { CoreNode, type CoreNodeProps } from './CoreNode.js';
import { CoreTextureManager } from './CoreTextureManager.js';
import { TrFontManager } from './text-rendering/TrFontManager.js';
import { CoreShaderManager, type ShaderMap } from './CoreShaderManager.js';
import { TextRenderer, type TextRendererMap, type TrProps } from './text-rendering/renderers/TextRenderer.js';
import { EventEmitter } from '../common/EventEmitter.js';
import { ContextSpy } from './lib/ContextSpy.js';
import type { FpsUpdatePayload, FrameTickPayload } from '../common/CommonTypes.js';
import { TextureMemoryManager, type TextureMemoryManagerSettings } from './TextureMemoryManager.js';
import { CoreRenderer } from './renderers/CoreRenderer.js';
import type { WebGlCoreRenderer } from './renderers/webgl/WebGlCoreRenderer.js';
import type { CanvasCoreRenderer } from './renderers/canvas/CanvasCoreRenderer.js';
import type { BaseShaderController } from '../main-api/ShaderController.js';
import { CoreTextNode, type CoreTextNodeProps } from './CoreTextNode.js';
import type { SdfTextRenderer } from './text-rendering/renderers/SdfTextRenderer/SdfTextRenderer.js';
import type { CanvasTextRenderer } from './text-rendering/renderers/CanvasTextRenderer.js';
import { type Bound } from './lib/utils.js';
export interface StageOptions {
    appWidth: number;
    appHeight: number;
    textureMemory: TextureMemoryManagerSettings;
    boundsMargin: number | [number, number, number, number];
    deviceLogicalPixelRatio: number;
    devicePhysicalPixelRatio: number;
    canvas: HTMLCanvasElement | OffscreenCanvas;
    clearColor: number;
    fpsUpdateInterval: number;
    enableContextSpy: boolean;
    forceWebGL2: boolean;
    numImageWorkers: number;
    renderEngine: typeof WebGlCoreRenderer | typeof CanvasCoreRenderer;
    eventBus: EventEmitter;
    quadBufferSize: number;
    fontEngines: (typeof CanvasTextRenderer | typeof SdfTextRenderer)[];
    inspector: boolean;
    strictBounds: boolean;
}
export type StageFpsUpdateHandler = (stage: Stage, fpsData: FpsUpdatePayload) => void;
export type StageFrameTickHandler = (stage: Stage, frameTickData: FrameTickPayload) => void;
export declare class Stage {
    readonly options: StageOptions;
    readonly animationManager: AnimationManager;
    readonly txManager: CoreTextureManager;
    readonly txMemManager: TextureMemoryManager;
    readonly fontManager: TrFontManager;
    readonly textRenderers: Partial<TextRendererMap>;
    readonly shManager: CoreShaderManager;
    readonly renderer: CoreRenderer;
    readonly root: CoreNode;
    readonly boundsMargin: [number, number, number, number];
    readonly defShaderCtr: BaseShaderController;
    readonly strictBound: Bound;
    readonly preloadBound: Bound;
    readonly strictBounds: boolean;
    /**
     * Renderer Event Bus for the Stage to emit events onto
     *
     * @remarks
     * In reality this is just the RendererMain instance, which is an EventEmitter.
     * this allows us to directly emit events from the Stage to RendererMain
     * without having to set up forwarding handlers.
     */
    readonly eventBus: EventEmitter;
    deltaTime: number;
    lastFrameTime: number;
    currentFrameTime: number;
    private fpsNumFrames;
    private fpsElapsedTime;
    private renderRequested;
    private frameEventQueue;
    private fontResolveMap;
    contextSpy: ContextSpy | null;
    /**
     * Stage constructor
     */
    constructor(options: StageOptions);
    updateFrameTime(): void;
    /**
     * Update animations
     */
    updateAnimations(): void;
    /**
     * Check if the scene has updates
     */
    hasSceneUpdates(): boolean;
    /**
     * Start a new frame draw
     */
    drawFrame(): void;
    /**
     * Queue an event to be emitted after the current/next frame is rendered
     *
     * @remarks
     * When we are operating in the context of the render loop, we may want to
     * emit events that are related to the current frame. However, we generally do
     * NOT want to emit events directly in the middle of the render loop, since
     * this could enable event handlers to modify the scene graph and cause
     * unexpected behavior. Instead, we queue up events to be emitted and then
     * flush the queue after the frame has been rendered.
     *
     * @param name
     * @param data
     */
    queueFrameEvent(name: string, data: unknown): void;
    /**
     * Emit all queued frame events
     *
     * @remarks
     * This method should be called after the frame has been rendered to emit
     * all events that were queued during the frame.
     *
     * See {@link queueFrameEvent} for more information.
     */
    flushFrameEvents(): void;
    calculateFps(): void;
    addQuads(node: CoreNode): void;
    /**
     * Request a render pass without forcing an update
     */
    requestRender(): void;
    /**
     * Given a font name, and possible renderer override, return the best compatible text renderer.
     *
     * @remarks
     * Will try to return a canvas renderer if no other suitable renderer can be resolved.
     *
     * @param fontFamily
     * @param textRendererOverride
     * @returns
     */
    resolveTextRenderer(trProps: TrProps, textRendererOverride?: keyof TextRendererMap | null): TextRenderer | null;
    /**
     * Create a shader controller instance
     *
     * @param type
     * @param props
     * @returns
     */
    createShaderCtr(type: keyof ShaderMap, props: Record<string, unknown>): BaseShaderController;
    createNode(props: Partial<CoreNodeProps>): CoreNode;
    createTextNode(props: Partial<CoreTextNodeProps>): CoreTextNode;
    /**
     * Resolves the default property values for a Node
     *
     * @remarks
     * This method is used internally by the RendererMain to resolve the default
     * property values for a Node. It is exposed publicly so that it can be used
     * by Core Driver implementations.
     *
     * @param props
     * @returns
     */
    protected resolveNodeDefaults(props: Partial<CoreNodeProps>): CoreNodeProps;
}
